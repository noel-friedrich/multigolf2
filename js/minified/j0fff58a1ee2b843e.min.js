const Lang = {
DE: "Deutsch",
EN: "English",
get() {
return document.documentElement.lang == "en"
? Lang.EN : Lang.DE
}
}
const Text = {
ConnectionFailed: {
[Lang.EN]: "Connection failed.",
[Lang.DE]: "Verbindung fehlgeschlagen.",
},
TryingAgainInSeconds: seconds => ({
[Lang.EN]: `⌛ Trying again in ${seconds} seconds.`,
[Lang.DE]: `⌛ Versuche nochmal in ${seconds} sekunden`
}),
TryingAgainIn10: {
[Lang.EN]: "⌛ Trying again in 10 seconds.",
[Lang.DE]: "⌛ Versuche nochmal in 10 sekunden"
},
ConnectingToHost: {
[Lang.EN]: "Connecting to Host...",
[Lang.DE]: "Verbinde zu Server..."
},
ConnectedToHost: {
[Lang.EN]: "Connected to Host.",
[Lang.DE]: "Verbindung erfolgreich."
},
ConnectionEstablished: {
[Lang.EN]: "✅ Connection established.",
[Lang.DE]: "✅ Verbindung erfolgreich.",
},
ConnectionDied: {
[Lang.EN]: "❌ Connection died",
[Lang.DE]: "❌ Verbindung abgebrochen.",
},
CouldNotConnect: {
[Lang.EN]: "❌ Could not connect to Host.",
[Lang.DE]: "❌ Verbindung fehlgeschlagen.",
},
CreatedPool: poolUid => ({
[Lang.EN]: `✅ Created Game (${poolUid})`,
[Lang.DE]: `✅ Spiel erstellt (${poolUid})`
}),
InitializingPeerToPeer: {
[Lang.EN]: "🫂 Initializing Peer-To-Peer...",
[Lang.DE]: "🫂 Verbindung wird aufgebaut...",
},
SuccessfullySentObject: objName => ({
[Lang.EN]: `✅ ${objName} successfully sent.`,
[Lang.DE]: `✅ ${objName} gesendet.`,
}),
FailedSendingObject: (name, err) => ({
[Lang.EN]: `⚠️ Couldn't upload ${name}: ${err}`,
[Lang.EN]: `⚠️ Upload von ${name} fehlgeschlagen: ${err}`,
}),
CouldntFetchServer: err => ({
[Lang.EN]: `❌ Couldn't fetch Server: ${err}`,
[Lang.DE]: `❌ Server blöd: ${err}`,
}),
GoodConnection: {
[Lang.EN]: "Good Connection",
[Lang.DE]: "Gute Verbindung"
},
ConnectionBeingInitialized: {
[Lang.EN]: "Connection is being initialized",
[Lang.DE]: "Verbindung wird hergestellt"
},
ConnectionTimedOut: {
[Lang.EN]: "Connecton timed out",
[Lang.DE]: "Verbindung abgebrochen"
},
ConnectionIsSlow: pingMs => ({
[Lang.EN]: `Connection is slow (${pingMs}ms Ping)`,
[Lang.DE]: `Verbindung ist langsam (${pingMs}ms Ping)`
}),
ConnectionInvitation: {
[Lang.EN]: "Connection Invitation",
[Lang.DE]: "Verbindungs-Einladung"
},
RTCAnswer: {
[Lang.EN]: "RTC Answer",
[Lang.DE]: "RTC Antwort"
},
ConnectionAnswer: {
[Lang.EN]: "Connection Answer",
[Lang.DE]: "Verbindungs-Antwort"
},
PleaseEnterCode: {
[Lang.EN]: "Please enter an ID.",
[Lang.DE]: "Bitte gib eine ID ein.",
},
CodeMustBeCharsLong: numChars => ({
[Lang.EN]: `ID must be ${numChars} characters long.`,
[Lang.DE]: `ID muss ${numChars} Buchstaben lang sein.`
}),
IsServerDown: {
[Lang.EN]: "Couldn't request site: Server down?",
[Lang.DE]: "Server hat nicht geantwortet: Server down?"
},
UnknownID: {
[Lang.EN]: "Unknown ID",
[Lang.DE]: "Unbekannte ID"
},
MultigolfScoreboard: {
[Lang.EN]: "Multigolf Scoreboard",
[Lang.DE]: "Multigolf Ergebnisse"
},
ShareText: {
[Lang.EN]: "Look! Scores! We played Multigolf! You should too!",
[Lang.DE]: "Guck mal! Wir haben Multigolf gespielt!"
},
LeavingWarning: {
[Lang.EN]: "You're in an active game of multigolf. Leaving this website will break the game!",
[Lang.DE]: "Du bist in einem aktiven Multigolf-Spiel. Das Verlassen der Website beendet das Spiel!"
},
NameTooLong: name => ({
[Lang.EN]: `Name "${name}..." is too long.`,
[Lang.DE]: `Der Name "${name}..." ist zu lang.`,
}),
PleaseFillOutFields: {
[Lang.EN]: "Please fill out all fields.",
[Lang.DE]: "Bitte fülle alle Felder aus."
},
FilloutOneName: {
[Lang.EN]: "Fill out at least one name to continue.",
[Lang.DE]: "Bitte fülle mindestens einen Namen aus."
},
TwoPlayersSameName: {
[Lang.EN]: "Two players cannot have the same name.",
[Lang.DE]: "Es kann sich kein Name doppeln."
},
DeviceGravity: {
[Lang.EN]: "Device Gravity",
[Lang.DE]: "Gerät-Gravitation"
},
DeviceGravityDescription: {
[Lang.EN]: "If enabled, phones that are tilted in real life will apply a gravity effect on balls.",
[Lang.DE]: "Wenn aktiviert wird die Orientierung von Handys als Gravitation einberechnet."
},
DeviceGravityWarning: {
[Lang.EN]: "Only works for phones with accelorometers.",
[Lang.DE]: "Funktioniert nur für Handys mit Zugriff auf Beschleunigungssensor"
},
BallCollisions: {
[Lang.EN]: "Ball Collisisions",
[Lang.DE]: "Ball-Kollisionen"
},
BallCollisionsDescription: {
[Lang.EN]: "If enabled, balls can kick each other. If disabled, balls will fly over each other.",
[Lang.DE]: "Wenn aktiviert können Bälle sich gegenseitig schubsen."
},
Soundeffects: {
[Lang.EN]: "Soundeffects",
[Lang.DE]: "Soundeffekte"
},
SoundeffectsDescription: {
[Lang.EN]: "If enabled, the host device will play sound effects when balls collide with something.",
[Lang.DE]: "Wenn aktiviert spielen Soundeffekte auf dem Server-Gerät wenn Bälle mit etwas kollidieren."
},
ReadNames: {
[Lang.EN]: "Read Names",
[Lang.DE]: "Namen Vorlesen"
},
ReadNamesDescription: {
[Lang.EN]: "If enabled, the host device will read the name of the player whose turn it is out loud.",
[Lang.DE]: "Wenn aktiviert wird das Server-Gerät den Namen des aktiven Spielers vorlesen."
},
MaximumKicksPerRound: {
[Lang.EN]: "Maximum Kicks per Round",
[Lang.DE]: "Maximale Schläge pro Runde"
},
MaximumKicksPerRoundDescription: {
[Lang.EN]: "Decide how many kicks each player can have per round before failing and getting a 2 point penalty.",
[Lang.DE]: "Entscheide wieviele Schläge jede Spielerin bekommt, bevor sie 2 Strafpunkte bekommt."
},
OnceYouConnectPlayers: {
[Lang.EN]: "Once you connect players, they will show up here.",
[Lang.DE]: "Sobald du Geräte verbindest, tauchen sie hier auf."
},
DeviceNum: num => ({
[Lang.EN]: `Device #${num}`,
[Lang.DE]: `Gerät #${num}`,
}),
NoDevicesError: {
[Lang.EN]: "You haven't connected any devices yet. Connect one and try again!",
[Lang.DE]: "Du hast noch keine Geräte verbunden. Verbinde mindestens eines und versuche nochmal!"
},
CourseHasOverlap: {
[Lang.EN]: "Your course has overlapping parts. Try reconnecting the phones in a different way and draw lines in the same directions on connecting phones. Do you still want to proceed?",
[Lang.DE]: "Der Kurs hat überlappende Teile. Versuche, die Geräte neu miteinander zu verbinden. Willst du trotzdem weiter (nicht empfohlen)?"
},
NoStartYet: {
[Lang.EN]: "You haven't placed a start yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Start. Platzier einen und probier nochmal."
},
NoHoleYet: {
[Lang.EN]: "You haven't placed a hole yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Loch. Platzier eins und probier nochmal."
},
HaventPlacedHoleFor: name => ({
[Lang.EN]: `You haven't placed a hole for ${name} yet.`,
[Lang.DE]: `Du hast noch kein Loch für ${name} platziert.`
}),
ObjectStart: {
[Lang.EN]: "Start",
[Lang.DE]: "Start"
},
ObjectHole: {
[Lang.EN]: "Hole",
[Lang.DE]: "Loch"
},
ObjectLava: {
[Lang.EN]: "Lava",
[Lang.DE]: "Lava"
},
ObjectCannon: {
[Lang.EN]: "Cannon",
[Lang.DE]: "Kanone"
},
ObjectEraser: {
[Lang.EN]: "Eraser",
[Lang.DE]: "Radierer"
},
ObjectDuellHole: num => ({
[Lang.EN]: `Hole ${num}`,
[Lang.DE]: `Loch ${num}`,
}),
ObjectCustomWall: {
[Lang.EN]: "Extra Wall",
[Lang.DE]: "Extra Wand"
},
ObjectGravityBox: {
[Lang.EN]: "Gravity Box",
[Lang.DE]: "Gravitations-Box"
},
ObjectStartDescription: {
[Lang.EN]: "Place where all balls start",
[Lang.DE]: "Platz wo alle Bälle starten"
},
ObjectHoleDescription: {
[Lang.EN]: "Goal that all balls must reach",
[Lang.DE]: "Ziel, welches alle Bälle erreichen müssen"
},
ObjectLavaDescription: {
[Lang.EN]: "Balls falling into Lava are reset to the start",
[Lang.DE]: "In Lava fallen = Zum Start zurück"
},
ObjectCannonDescription: {
[Lang.EN]: "Rotates and shoots balls",
[Lang.DE]: "Dreht sich und schießt Bälle weg"
},
ObjectEraserDescriptiom: {
[Lang.EN]: "Erase placed objects",
[Lang.DE]: "Radiere platzierte Objekte"
},
ObjectDuellHoleDescription: playername => ({
[Lang.EN]: `Goal that ${playername} has to reach`,
[Lang.DE]: `Ziel das ${playername} erreichen muss`
}),
ObjectCustomWallDescription: {
[Lang.EN]: "A wall that balls will bounce off",
[Lang.DE]: "Eine Wand an der Bälle abprallen"
},
ObjectGravityBoxDescription: {
[Lang.EN]: "Balls inside will experience gravity",
[Lang.DE]: "Bälle werden in die Richtung geschubst"
},
NotConstructedYet: {
[Lang.EN]: "You haven't constructed a course layout yet.",
[Lang.DE]: "Du hast noch kein Layout erstellt."
},
ThanksForFeedback: {
[Lang.EN]: "Thanks for the feedback! You're the best!",
[Lang.DE]: "Feedback erfolgreich abgeschickt! Vielen Dank!"
},
FeedbackTooLong: {
[Lang.EN]: "That's too long feedback for this box. Maybe send me an email instead?",
[Lang.DE]: "Das ist zu viel Feedback für diese Box. Vielleicht ist eine Email besser?"
}
}
function getLangText(textObject) {
return textObject[Lang.get()]
}
for (const [key, val] of Object.entries(Text)) {
if (typeof val === "function") {
Text[key] = function () {
return getLangText(val(...arguments))
}
} else {
Object.defineProperty(Text, key, {
get: () => getLangText(val)
})
}
}
Object.freeze(Text)
const Sprite = {
BallBlue:      "../assets/compressed/objects/balls/blue.png",
BallCyan:      "../assets/compressed/objects/balls/cyan.png",
BallLightblue: "../assets/compressed/objects/balls/light_blue.png",
BallOrange:    "../assets/compressed/objects/balls/orange.png",
BallPink:      "../assets/compressed/objects/balls/pink.png",
BallRed:       "../assets/compressed/objects/balls/red.png",
BallViolet:    "../assets/compressed/objects/balls/violet.png",
BallWhite:     "../assets/compressed/objects/balls/white.png",
BallYellow:    "../assets/compressed/objects/balls/yellow.png",
Grid:          "../assets/compressed/objects/grid.png",
Hole:          "../assets/compressed/objects/hole.png",
Start:         "../assets/compressed/objects/start.png",
DuellHole1:    "../assets/compressed/objects/duellHole1.png",
DuellHole2:    "../assets/compressed/objects/duellHole2.png",
Lava:          "../assets/compressed/objects/lava.png",
Cannon:        "../assets/compressed/objects/cannon.png",
GravityBox:    "../assets/compressed/objects/gravity-box.png",
Eraser:        "../assets/objects/eraser.svg",
ZoomIcon:      "../assets/zoom-icon.svg",
CustomWall:    "../assets/objects/wall.svg",
}
const AudioSprite = {
Plop: "../assets/audio/plop.mp3",
WinSound: "../assets/audio/win_sound.mp3",
Lava: "../assets/audio/lava.mp3",
Bonk: "../assets/audio/bonk.mp3",
Shot: "../assets/audio/shot.mp3",
Cannon: "../assets/audio/cannon.mp3",
Note1: "../assets/audio/notes/1.mp3",
Note2: "../assets/audio/notes/2.mp3",
Note3: "../assets/audio/notes/3.mp3",
Note4: "../assets/audio/notes/4.mp3",
Note5: "../assets/audio/notes/5.mp3",
Note6: "../assets/audio/notes/6.mp3",
Note7: "../assets/audio/notes/7.mp3",
Note8: "../assets/audio/notes/8.mp3",
Note9: "../assets/audio/notes/9.mp3",
}
const allNoteSprites = [
AudioSprite.Note1,
AudioSprite.Note2,
AudioSprite.Note3,
AudioSprite.Note4,
AudioSprite.Note5,
AudioSprite.Note6,
AudioSprite.Note7,
AudioSprite.Note8,
AudioSprite.Note9
]
const AllBallSprites = [
Sprite.BallBlue,
Sprite.BallRed,
Sprite.BallYellow,
Sprite.BallPink,
Sprite.BallOrange,
Sprite.BallCyan,
Sprite.BallViolet,
Sprite.BallLightblue,
Sprite.BallWhite,
]
function setSpritePath(prePath) {
const spriteObjects = [Sprite, AudioSprite]
const spriteLists = [allNoteSprites, AllBallSprites]
for (const obj of spriteObjects) {
for (const [key, value] of Object.entries(obj)) {
obj[key] = prePath + value
}
}
for (const lst of spriteLists) {
for (let i = 0; i < lst.length; i++) {
lst[i] = prePath + lst[i]
}
}
try {
golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
} catch (e) {
console.log("Couldn't update golfObjectTypeSpriteMap")
if (!(e instanceof ReferenceError)) {
throw e
}
}
}
/*
The MIT License (MIT)
Copyright (c) Rich Tibbett
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const noSleep_webm = "data:video/webm;base64,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"
const noSleep_mp4 = "data:video/mp4;base64,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"
const oldIOS = () =>
typeof navigator !== "undefined" &&
parseFloat(
(
"" +
(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(
navigator.userAgent
) || [0, ""])[1]
)
.replace("undefined", "3_2")
.replace("_", ".")
.replace("_", "")
) < 10 &&
!window.MSStream;
const nativeWakeLock = () => "wakeLock" in navigator;
class NoSleep {
constructor() {
this.enabled = false;
if (nativeWakeLock()) {
this._wakeLock = null;
const handleVisibilityChange = () => {
if (this._wakeLock !== null && document.visibilityState === "visible") {
this.enable();
}
};
document.addEventListener("visibilitychange", handleVisibilityChange);
document.addEventListener("fullscreenchange", handleVisibilityChange);
} else if (oldIOS()) {
this.noSleepTimer = null;
} else {
this.noSleepVideo = document.createElement("video");
this.noSleepVideo.setAttribute("title", "No Sleep");
this.noSleepVideo.setAttribute("playsinline", "");
this._addSourceToVideo(this.noSleepVideo, "webm", noSleep_webm);
this._addSourceToVideo(this.noSleepVideo, "mp4", noSleep_mp4);
this.noSleepVideo.addEventListener("loadedmetadata", () => {
if (this.noSleepVideo.duration <= 1) {
this.noSleepVideo.setAttribute("loop", "");
} else {
this.noSleepVideo.addEventListener("timeupdate", () => {
if (this.noSleepVideo.currentTime > 0.5) {
this.noSleepVideo.currentTime = Math.random();
}
});
}
});
}
}
_addSourceToVideo(element, type, dataURI) {
var source = document.createElement("source");
source.src = dataURI;
source.type = `video/${type}`;
element.appendChild(source);
}
get isEnabled() {
return this.enabled;
}
enable() {
if (nativeWakeLock()) {
return navigator.wakeLock
.request("screen")
.then((wakeLock) => {
this._wakeLock = wakeLock;
this.enabled = true;
console.log("Wake Lock active.");
this._wakeLock.addEventListener("release", () => {
console.log("Wake Lock released.");
});
})
.catch((err) => {
this.enabled = false;
console.error(`${err.name}, ${err.message}`);
throw err;
});
} else if (oldIOS()) {
this.disable();
console.warn(`
NoSleep enabled for older iOS devices. This can interrupt
active or long-running network requests from completing successfully.
See https://github.com/richtr/NoSleep.js/issues/15 for more details.
`);
this.noSleepTimer = window.setInterval(() => {
if (!document.hidden) {
window.location.href = window.location.href.split("#")[0];
window.setTimeout(window.stop, 0);
}
}, 15000);
this.enabled = true;
return Promise.resolve();
} else {
let playPromise = this.noSleepVideo.play();
return playPromise
.then((res) => {
this.enabled = true;
return res;
})
.catch((err) => {
this.enabled = false;
throw err;
});
}
}
disable() {
if (nativeWakeLock()) {
if (this._wakeLock) {
this._wakeLock.release();
}
this._wakeLock = null;
} else if (oldIOS()) {
if (this.noSleepTimer) {
console.warn(`
NoSleep now disabled for older iOS devices.
`);
window.clearInterval(this.noSleepTimer);
this.noSleepTimer = null;
}
} else {
this.noSleepVideo.pause();
}
this.enabled = false;
}
}
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
static fromObject(obj) {
if (obj == null) return null
if (obj.x == undefined || obj.y == undefined) {
throw new Error(`Vector object must have x and y properties`)
}
return new Vector2d(obj.x, obj.y)
}
toObject() {
return {
x: this.x,
y: this.y
}
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get squaredLength() {
return this.x * this.x + this.y * this.y
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
scaleX(x) {
return new Vector2d(this.x * x, this.y)
}
scaleY(y) {
return new Vector2d(this.x, this.y * y)
}
iscaleX(x) {
this.x *= x
}
iscaleY(y) {
this.y *= y
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
distanceSquared(v) {
return this.sub(v).squaredLength
}
cross(v) {
return this.x * v.y - this.y * v.x
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
this.x = x
this.y = y
}
setVector2d(v) {
this.x = v.x
this.y = v.y
}
interpolate(v, t) {
return this.add(v.sub(this).scale(t))
}
iinterpolate(v, t) {
this.iadd(v.sub(this).scale(t))
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
toArray() {
return [this.x, this.y]
}
normalizeToCanvas(canvas) {
return new Vector2d(
this.x / canvas.width,
this.y / canvas.height
)
}
static fromTouchEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX && event.clientY) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
static fromEvent(event, element) {
return Vector2d.fromTouchEvent(event, element)
}
clampX(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.x - clampValue) <= maxDelta) {
newVector.x = clampValue
}
}
return newVector
}
clampY(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.y - clampValue) <= maxDelta) {
newVector.y = clampValue
}
}
return newVector
}
min() {
return Math.min(this.x, this.y)
}
max() {
return Math.max(this.x, this.y)
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
iround() {
this.x = Math.round(this.x)
this.y = Math.round(this.y)
}
toString() {
return `${this.x}, ${this.y}`
}
static fromString(str) {
const parts = str.split(",")
if (parts.length != 2) {
throw new Error("String must be made up of two numbers seperated by comma")
}
const x = parseFloat(parts[0])
const y = parseFloat(parts[1])
if (isNaN(x) || isNaN(y)) {
throw new Error("String contains invalid number(s)")
}
return new Vector2d(x, y)
}
}
function calcLineIntersection(s1, e1, s2, e2) {
const denominator = (e2.y - s2.y)*(e1.x - s1.x) - (e2.x - s2.x)*(e1.y - s1.y)
if (denominator == 0) {
return null
}
const ua = ((e2.x - s2.x) * (s1.y - s2.y) - (e2.y - s2.y) * (s1.x - s2.x)) / denominator
const ub = ((e1.x - s1.x) * (s1.y - s2.y) - (e1.y - s1.y) * (s1.x - s2.x)) / denominator
if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null
return new Vector2d(
s1.x + ua * (e1.x - s1.x),
s1.y + ua * (e1.y - s1.y),
)
}
function calcAveragePos(vecs) {
return vecs.reduce((p,c) => p.add(c), new Vector2d(0,0)).scale(1 / vecs.length)
}
class ConstructionLine {
constructor(startPos, endPos) {
this.startPos = startPos
this.endPos = endPos
}
get start() {
return this.startPos
}
get end() {
return this.endPos
}
static fromObject(obj) {
return new ConstructionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end)
)
}
toObject() {
return {
start: this.startPos.toObject(),
end: this.endPos.toObject()
}
}
}
class PhoneCoordinates {
constructor(topLeft, topRight, bottomLeft, bottomRight, angle, scalar, gravity) {
this.topLeft = topLeft
this.topRight = topRight
this.bottomLeft = bottomLeft
this.bottomRight = bottomRight
this.angle = angle ?? 0
this.scalar = scalar ?? 1
this.gravity = gravity ?? new Vector2d(0, 0)
}
static fromWidthHeight(width, height) {
return new PhoneCoordinates(
new Vector2d(0, 0),
new Vector2d(width, 0),
new Vector2d(0, height),
new Vector2d(width, height),
0, 1,
new Vector2d(0, 0)
)
}
toObject() {
return {
coords: [
this.topLeft.toObject(),
this.topRight.toObject(),
this.bottomLeft.toObject(),
this.bottomRight.toObject(),
],
angle: this.angle,
scalar: this.scalar,
gravity: this.gravity.toObject()
}
}
static fromObject(obj) {
return new PhoneCoordinates(
...obj.coords.map(coord => Vector2d.fromObject(coord)),
obj.angle,
obj.scalar,
Vector2d.fromObject(obj.gravity)
)
}
get points() {
return [this.topLeft, this.topRight, this.bottomRight, this.bottomLeft]
}
get midPos() {
return this.topLeft.add(this.bottomRight).scale(0.5)
}
randomPosInside() {
const x = Math.random()
const y = Math.random()
return this.topLeft.add(this.topRight.sub(this.topLeft).scale(x))
.add(this.bottomLeft.sub(this.topLeft).scale(y))
}
scale(scalar) {
this.scalar *= scalar
for (let vec of this.points) {
vec.iscale(scalar)
}
}
rotate(angle) {
this.angle += angle
for (let vec of this.points) {
vec.irotate(angle)
}
}
translate(point) {
for (let vec of this.points) {
vec.iadd(point)
}
}
copy() {
return PhoneCoordinates.fromObject(this.toObject())
}
get width() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.topRight.rotate(-this.angle)
return rotated2.x - rotated1.x
}
get height() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.bottomLeft.rotate(-this.angle)
return rotated2.y - rotated1.y
}
get area() {
return this.size.x * this.size.y
}
creditCardScalingFactor(screenSize) {
return this.height / screenSize.y
}
screenPosToBoardPos(screenPos, screenSize) {
const scaledScreenPos = screenPos.copy()
scaledScreenPos.iscaleX(this.width / screenSize.x)
scaledScreenPos.iscaleY(this.height / screenSize.y)
const pos = scaledScreenPos.rotate(this.angle)
return this.topLeft.add(pos.scale(this.scalar))
}
boardPosToScreenPos(boardPos, screenSize) {
const relativePos = boardPos.sub(this.topLeft).scale(1 / this.scalar)
const rawScreenPos = relativePos.rotate(-this.angle)
rawScreenPos.iscaleX(screenSize.x / this.width)
rawScreenPos.iscaleY(screenSize.y / this.height)
return rawScreenPos
}
containsPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY
}
distanceToPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
const dx = Math.max(minX - pos.x, 0, pos.x - maxX)
const dy = Math.max(minY - pos.y, 0, pos.y - maxY)
return Math.sqrt(dx * dx + dy * dy)
}
get walls() {
return [
[this.points[0], this.points[1]],
[this.points[1], this.points[2]],
[this.points[2], this.points[3]],
[this.points[3], this.points[0]],
]
}
get corners() {
return this.points
}
get minXY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get maxXY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get minXmaxY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get maxXminY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get size() {
return this.maxXY.sub(this.minXY)
}
hasOverlap(other) {
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (intersection) return true
}
}
return false
}
getOverlap(other) {
const wallIntersections = []
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (!intersection) continue
wallIntersections.push(intersection)
}
}
const uniqueIntersections = []
const epsilon = 0.1
const insidePoints = this.points.filter(p => other.distanceToPos(p) < epsilon)
.concat(other.points.filter(p => this.distanceToPos(p) < epsilon))
for (const point of wallIntersections.concat(insidePoints)) {
let foundSimilar = false
for (const other of uniqueIntersections) {
if (point.distance(other) < epsilon) {
foundSimilar = true
break
}
}
if (!foundSimilar) {
uniqueIntersections.push(point)
}
}
if (uniqueIntersections.length == 4) {
const minXY = new Vector2d(
Math.min(...uniqueIntersections.map(p => p.x)),
Math.min(...uniqueIntersections.map(p => p.y)),
)
const maxXY = new Vector2d(
Math.max(...uniqueIntersections.map(p => p.x)),
Math.max(...uniqueIntersections.map(p => p.y)),
)
const size = maxXY.sub(minXY)
return new PhoneCoordinates(
minXY, minXY.addX(size.x),
minXY.addY(size.y), maxXY
)
} else {
return null
}
}
}
class PhoneConnectionLine {
getRandomColor() {
const hue = Math.round(Math.random() * 360)
if (hue > 65 && hue < 185) {
return this.getRandomColor()
}
return `hsl(${hue}deg 100% 50%)`
}
constructor(start, end, color="random") {
this.start = start ?? new Vector2d(0, 0)
this.end = end ?? new Vector2d(1, 0)
if (color == "random") {
this.color = this.getRandomColor()
} else {
this.color = color
}
}
get length() {
return this.start.distance(this.end)
}
get points() {
return [this.start, this.end]
}
translate(vec) {
this.start.iadd(vec)
this.end.iadd(vec)
return this
}
rotate(angle) {
for (let vec of this.points) {
vec.irotate(angle)
}
}
scale(scalar) {
for (let vec of this.points) {
vec.iscale(scalar)
}
}
static fromObject(obj) {
return new PhoneConnectionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end),
obj.color
)
}
toObject() {
return {
start: this.start.toObject(),
end: this.end.toObject(),
color: this.color
}
}
}
class Course {
constructor(phones, lines) {
this.phones = phones ?? []
this.lines = lines ?? []
}
reset() {
this.phones = []
this.lines = []
}
toObject() {
return {
phones: this.phones.map(p => p.toObject()),
lines: this.lines.map(l => l.toObject()),
}
}
static fromObject(obj) {
return new Course(
obj.phones.map(p => PhoneCoordinates.fromObject(p)),
obj.lines?.map(l => PhoneConnectionLine.fromObject(l))
)
}
copy() {
return Course.fromObject(this.toObject())
}
scale(scalar) {
this.phones.forEach(p => p.scale(scalar))
this.lines.forEach(l => l.scale(scalar))
}
rotate(angle) {
this.phones.forEach(p => p.rotate(angle))
this.lines.forEach(l => l.rotate(angle))
}
translate(point) {
this.phones.forEach(p => p.translate(point))
this.lines.forEach(l => l.translate(point))
}
addPhone(phone) {
this.phones.push(phone)
}
addLine(line) {
this.lines.push(line)
}
containsPos(pos) {
return this.phones.some(p => p.containsPos(pos))
}
getOverlaps() {
const overlaps = []
for (let i = 0; i < this.phones.length; i++) {
for (let j = 0; j < this.phones.length; j++) {
if (i >= j) continue
const overlap = this.phones[i].getOverlap(this.phones[j])
if (overlap) {
overlaps.push(overlap)
}
}
}
return overlaps
}
}
class Ball {
constructor(pos, vel, inHole, radius, spriteUrl, kicks, active, uid, rotationAngle, lastImmobilePos, immobileTickCount, objectMemory, generallyAbleToCollide) {
this.pos = pos
this.vel = vel ?? new Vector2d(0, 0)
this.inHole = inHole ?? false
this.radius = radius ?? 18
this.spriteUrl = spriteUrl ?? Sprite.BallWhite
this.kicks = kicks ?? 0
this.active = active ?? true
this.uid = uid
this.rotationAngle = rotationAngle ?? 0
this.lastImmobilePos = lastImmobilePos ?? this.pos.copy()
this.immobileTickCount = immobileTickCount ?? 0
this.objectMemory = objectMemory ?? new Map() // {objectUid => dynamicMap<key, value>}
this.generallyAbleToCollide = generallyAbleToCollide ?? true
this.outOfBoundsTickCount = 0
this.movingTickCount = 0
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
i: this.inHole,
r: this.radius,
s: this.spriteUrl,
k: this.kicks,
a: this.active,
u: this.uid,
ro: this.rotationAngle,
l: this.lastImmobilePos,
im: this.immobileTickCount,
o: Array.from(this.objectMemory.entries()).map(([k, v]) => [k, Array.from(v.entries())]),
g: this.generallyAbleToCollide
}
}
static fromObject(obj) {
return new Ball(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.i,
obj.r,
obj.s,
obj.k,
obj.a,
obj.u,
obj.ro,
obj.l,
obj.im,
(obj.o !== undefined) ? new Map(obj.o.map(([k, v]) => [k, new Map(v)])) : new Map(),
obj.g
)
}
kick(direction) {
if (this.inHole) {
return
}
this.vel.iadd(direction.scale(0.6))
this.kicks++
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Shot)
}
}
isMoving() {
return this.vel.length > 0
}
_getClosestWall(pos, board) {
let closestWall = null
let smallestDistance = Infinity
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance} = this._distanceToWall(p1, p2, pos)
if (distance < smallestDistance) {
closestWall = [p1, p2]
smallestDistance = distance
}
}
}
return closestWall
}
_getCollidingCorners(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingCorners = []
for (const wallObject of walledObjects) {
for (const corner of wallObject.corners) {
const distance = corner.distance(this.pos)
if (distance < this.radius) {
collidingCorners.push({
type: "corner",
distance, point: corner
})
}
}
}
return collidingCorners
}
_getCollidingWalls(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingWalls = []
const epsilon = 0.01
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance, closestPoint} = this._distanceToWall(p1, p2, this.pos)
if (distance <= this.radius) {
let overlapCount = 0
for (const box of board.course.phones) {
const boxDist = box.distanceToPos(closestPoint)
if (boxDist < epsilon) {
overlapCount++
if (overlapCount > 1) {
break
}
}
}
if (overlapCount < 2) {
collidingWalls.push({
points: [p1, p2], distance,
type: "wall"
})
}
}
}
}
return collidingWalls
}
_getClosestEndPos(pos, board) {
let closestPos = board.endPositions[0]
let smallestDistance = Infinity
for (let endPos of board.endPositions) {
const distance = endPos.distance(pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestPos = endPos
}
}
return closestPos.copy()
}
_distanceToWall(p1, p2, point) {
let p2toP1 = p2.sub(p1)
let p2toPoint = point.sub(p1)
let d = p2toP1.dot(p2toPoint) / (p2toP1.length ** 2)
if (d < 0) {
return {distance: p1.distance(point), closestPoint: p1.copy()}
} else if (d > 1) {
return {distance: p2.distance(point), closestPoint: p2.copy()}
} else {
let closestPoint = p1.add(p2toP1.scale(d))
return {distance: closestPoint.distance(point), closestPoint}
}
}
_isInCustomWall(pos, board) {
return board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(pos))
}
_reflectAtWall(p1, p2, dir) {
const wallDir = p2.sub(p1)
const wallNormal = new Vector2d(-wallDir.y, wallDir.x)
const angleDifference = dir.angle - wallNormal.angle
return dir.rotate(-angleDifference * 2).scale(-1)
}
_getIntersectingObjects(board, objectType=null) {
return board.objects.filter(o => {
return o.intersects(this.pos) && (
objectType == null || o.type == objectType
)
})
}
readyToCollide(board) {
return !this.inHole && board.startPos.distance(this.pos) > 2 * this.radius
}
calcBallCollisions(board) {
if (!this.readyToCollide(board) || !this.generallyAbleToCollide) {
return
}
for (let ball of board.balls) {
if (ball.uid == this.uid) {
continue
}
if (!ball.readyToCollide(board) || !ball.generallyAbleToCollide) {
continue
}
const collision = ball.pos.distance(this.pos) <= (ball.radius + this.radius)
if (collision) {
const [v1, v2, x1, x2] = [this.vel, ball.vel, this.pos, ball.pos]
const v1p = v1.sub(x1.sub(x2).scale(v1.sub(v2).dot(x1.sub(x2)) / (x1.sub(x2).length ** 2)))
const v2p = v2.sub(x2.sub(x1).scale(v2.sub(v1).dot(x2.sub(x1)) / (x2.sub(x1).length ** 2)))
this.vel = v1p
ball.vel = v2p
this.pos.iadd(this.vel)
ball.pos.iadd(ball.vel)
ball.immobileTickCount = 0
this.immobileTickCount = 0
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Bonk)
}
}
}
}
updatePhysics(board) {
const stepCount = Math.max(Math.ceil(this.vel.length / 10), 1)
let isUnderAcceleration = false
if (board.deviceGravityEnabled && this.isMoving() && !this.inHole) {
for (let i = 0; i < board.course.phones.length; i++) {
if (board.course.phones[i].containsPos(this.pos)) {
const gravity = board.course.phones[i].gravity
.rotate(board.course.phones[i].angle)
if (!gravity) break
if (gravity.length > 0) {
this.vel.iadd(gravity)
isUnderAcceleration = true
}
break
}
}
}
if (this.isMoving() && !this.inHole) {
const gravityBoxes = this._getIntersectingObjects(board, golfObjectType.GravityBox)
for (const box of gravityBoxes) {
const gravity = Vector2d.fromAngle(box.angle - Math.PI / 2).scale(0.5)
this.vel.iadd(gravity)
isUnderAcceleration = true
}
}
if (this.isMoving() && this.vel.length < 0.3 && !isUnderAcceleration) {
this.vel.iscale(0)
}
this.vel.iscale(0.97)
this.vel.iscale(1 / stepCount)
for (let i = 0; i < stepCount; i++) {
this.physicsStep(board)
}
this.vel.iscale(stepCount)
if (this.pos.distance(this.lastImmobilePos) > this.radius) {
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
} else {
this.immobileTickCount++
}
if (this.immobileTickCount > 60 * 2 && this.isMoving()) {
this.vel.iscale(0)
}
if (!board.course.containsPos(this.pos) ||
board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(this.pos))) {
this.outOfBoundsTickCount++
if (this.outOfBoundsTickCount > 10) {
this.resetPos(board.startPos)
this.outOfBoundsTickCount = 0
}
} else {
this.outOfBoundsTickCount = 0
}
if (this.isMoving()) {
this.movingTickCount++
if (this.movingTickCount > 60 * 10) {
this.vel.iscale(0)
}
} else {
this.movingTickCount = 0
}
}
resetPos(startPos) {
this.pos = startPos.copy()
this.vel.iscale(0)
this.rotationAngle = 0
this.generallyAbleToCollide = true
}
interactWithLava(board, object) {
if (!this.inHole) {
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Lava)
}
board.spawnParticleExplosion(this.pos,
{forceSpeed: this.vel.length, color: "#f9480a"})
return this.resetPos(board.startPos)
}
}
interactWithCannon(board, object) {
const objectData = this.getObjectMemory(object.uid)
let cannonProgress = 0
if (objectData.has("progress")) {
cannonProgress = objectData.get("progress")
} else {
objectData.set("progress", cannonProgress)
}
const shootDir = Vector2d.fromAngle(object.angle + Math.PI / 2)
const bellyPos = object.pos.add(shootDir.scale(-object.size.max() * 0.17))
const nozzlePos = object.pos.add(shootDir.scale(object.size.max() * 0.37))
const desiredPos = cannonProgress < 30 ? bellyPos
: cannonProgress < 100 ? bellyPos.interpolate(nozzlePos, (cannonProgress - 30) / 70)
: nozzlePos
if (cannonProgress > 30 && cannonProgress < 100) {
this.rotationAngle += 0.05
}
this.rotationAngle += 0.02244
this.pos.iinterpolate(desiredPos, Math.min(cannonProgress / 50, 1))
this.vel.iscale(0)
this.generallyAbleToCollide = false
if (cannonProgress >= 140) {
this.vel.setVector2d(shootDir.scale(object.size.max() / 2))
this.pos.iadd(shootDir.scale(object.size.max() / 2))
this.resetObjectMemory(object.uid)
for (let i = 0; i < 20; i++) {
const particle = new Particle(nozzlePos.copy())
particle.vel = shootDir.scale(10 + Math.random() * 10)
particle.vel.irotate(Math.random() * 0.4 - 0.2)
particle.color = "black"
board.particles.push(particle)
}
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Cannon)
}
this.generallyAbleToCollide = true
}
objectData.set("progress", cannonProgress + 1)
}
getObjectMemory(objectUid) {
if (!this.objectMemory.has(objectUid)) {
this.objectMemory.set(objectUid, new Map())
}
const objectData = this.objectMemory.get(objectUid)
objectData.set("expire-count", 100)
return objectData
}
resetObjectMemory(objectUid) {
if (this.objectMemory.has(objectUid)) {
this.objectMemory.delete(objectUid)
}
}
updateObjectMemories() {
for (const [objectUid, objectData] of this.objectMemory.entries()) {
if (objectData.has("expire-count")) {
const count = objectData.get("expire-count")
objectData.set("expire-count", count - 1)
if (count <= 1) {
this.objectMemory.delete(objectUid)
}
}
}
}
interactStepWithObject(board, object) {
switch(object.type) {
case golfObjectType.Lava:
return this.interactWithLava(board, object)
case golfObjectType.Cannon:
return this.interactWithCannon(board, object)
}
}
physicsStep(board) {
let madeWallCollision = false
this.pos.iadd(this.vel)
const touchingObjects = board.objects.filter(o => o.intersects(this.pos))
for (const object of touchingObjects) {
this.interactStepWithObject(board, object)
}
this.updateObjectMemories()
const collidingObjects = this._getCollidingCorners(board).concat(this._getCollidingWalls(board))
collidingObjects.sort((a, b) => a.distance - b.distance)
if (collidingObjects.length > 0) {
if (collidingObjects[0].type == "corner") {
const collidingCorner = collidingObjects[0].point
const cornerDir = this.pos.sub(collidingCorner)
const collisionStrength = -2 * this.vel.dot(cornerDir) / cornerDir.squaredLength
this.pos.isub(this.vel)
this.vel.iadd(cornerDir.scale(collisionStrength))
this.pos.iadd(this.vel.scale(0.95))
madeWallCollision = true
} else {
for (const [p1, p2] of collidingObjects.filter(o => o.type == "wall").map(o => o.points)) {
this.pos.isub(this.vel)
this.vel = this._reflectAtWall(p1, p2, this.vel)
this.pos.iadd(this.vel.scale(0.8))
}
}
madeWallCollision = true
}
if (board.ballCollisionEnabled) {
this.calcBallCollisions(board)
}
const endPos = this._getClosestEndPos(this.pos, board)
if (endPos && !this.inHole) {
const distance = endPos.distance(this.pos)
if (distance <= this.radius * 1.35 && this.vel.length < 40) {
this.inHole = true
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.WinSound)
}
}
}
if (this.inHole) {
this.radius = Math.max(0, this.radius - 0.13)
this.pos = this.pos.lerp(endPos, 0.1)
this.rotationAngle += 0.4
this.vel.iscale(0.8)
} else {
this.rotationAngle += this.vel.length / 40
}
if (madeWallCollision && window.AudioPlayer) {
window.AudioPlayer.randomNote({
volume: Math.min(this.vel.length / 10 * 0.9 + 0.1, 1.)
})
}
}
translate(point) {
this.pos.iadd(point)
}
scale(scalar) {
this.radius *= scalar
this.pos.iscale(scalar)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
}
const PARTICLE_MAX_TICKS = 30
class Particle {
constructor(pos, vel, color, radius, ticksAlive) {
this.pos = pos ?? new Vector2d(0, 0)
this.vel = vel ?? new Vector2d(0, 0)
this.color = color ?? "white"
this.radius = radius ?? 5
this.ticksAlive = 0
this.alive = true
}
die() {
this.alive = false
}
get opacity() {
return Math.max(1 - this.ticksAlive / PARTICLE_MAX_TICKS, 0)
}
updatePhysics(board) {
if (!this.alive) {
return
}
this.pos.iadd(this.vel)
if (!board.course.containsPos(this.pos)) {
this.die()
}
if (this.ticksAlive > PARTICLE_MAX_TICKS) {
this.die()
}
this.ticksAlive++
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
c: this.color,
r: this.radius,
t: this.ticksAlive
}
}
static fromObject(obj) {
return new Particle(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.c, obj.r, obj.t
)
}
}
class Board {
static physicsTimestep = 17 // approximately 60 fps
constructor(course, objects, balls, physicsTime, ballCollisionEnabled, deviceGravityEnabled, particlesEnabled, particles) {
this.course = course ?? new Course()
this.objects = objects ?? []
this.balls = balls ?? []
this.particles = particles ?? []
this.physicsTime = physicsTime ?? Date.now()
this.ballCollisionEnabled = ballCollisionEnabled ?? true
this.deviceGravityEnabled = deviceGravityEnabled ?? true
this.particlesEnabled = particlesEnabled ?? true
this.constructionLineBuffer = []
this.courseHistory = [this.course.copy()]
this.physicsStepCount = 0
this.physicsStepEvents = []
}
resetConfig() {
this.balls = []
this.objects = []
this.course.reset()
this.courseHistory = [this.course.copy()]
}
addPhysicsEvent(callback, relativeStepIndex) {
this.physicsStepEvents.push([this.physicsStepCount + relativeStepIndex, callback])
}
spawnParticleExplosion(pos, {color=undefined, forceSpeed=undefined, numParticles=50, radius=undefined}={}) {
if (!this.particlesEnabled) {
return
}
const plusminus = Math.ceil(numParticles * 0.3)
numParticles += Math.round((Math.random() - 0.5) * 2 * plusminus)
const angleStep = 1 / numParticles * Math.PI * 2
for (let i = 0; i < numParticles; i++) {
let speed = forceSpeed ?? 2
speed *= 0.7 + Math.random() * 0.6
const angle = (i + Math.random()) * angleStep
const vel = Vector2d.fromAngle(angle).scale(speed)
const particle = new Particle(pos.copy(), vel, color, radius)
this.particles.push(particle)
}
}
clearPhysicsEvents() {
this.physicsStepEvents.splice(0, this.physicsStepEvents.length)
}
get movableThings() {
return this.objects.concat(this.balls).concat([this.course])
}
translate(point) {
for (const thing of this.movableThings) {
thing.translate(point)
}
}
rotate(angle) {
for (const thing of this.movableThings) {
thing.rotate(angle)
}
}
scale(scalar) {
for (const thing of this.movableThings) {
thing.scale(scalar)
}
}
updateObject(object) {
for (let i = 0; i < gameState.board.objects.length; i++) {
if (gameState.board.objects[i].uid == object.uid) {
gameState.board.objects[i] = object
return true
}
}
return false
}
getClosestObject(pos) {
let smallestDistance = Infinity
let closestObject = null
for (let object of this.objects) {
const distance = pos.distance(object.pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestObject = object
}
}
return closestObject
}
intersectObject(pos) {
for (let i = this.objects.length - 1; i >= 0; i--) {
if (this.objects[i].intersects(pos)) {
return this.objects[i]
}
}
return null
}
get startPos() {
const startObject = this.objects.find(o => o.type == golfObjectType.Start)
if (startObject) {
return startObject.pos
} else {
return undefined
}
}
get endPositions() {
return this.objects.filter(o => (
o.type == golfObjectType.Hole
|| o.type == golfObjectType.DuellHole1
|| o.type == golfObjectType.DuellHole2
)).map(o => o.pos)
}
updateObjectPhysics() {
for (const object of this.objects.filter(o => o.type == golfObjectType.Cannon)) {
object.angle += 0.02244
}
}
physicsStep() {
for (const ball of this.balls) {
ball.updatePhysics(this)
}
for (const particle of this.particles) {
particle.updatePhysics(this)
}
this.updateObjectPhysics()
this.particles = this.particles.filter(p => p.alive)
this.physicsTime += Board.physicsTimestep
}
updatePhysics(maxTime=Date.now(), maxSteps=500) {
let stepCount = 0
while (stepCount < maxSteps && this.physicsTime < maxTime) {
this.physicsStep()
this.physicsStepCount++
stepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
if (Math.abs(this.physicsTime - maxTime) > 10 * 1000) {
this.physicsTime = maxTime
}
}
simulateStepsEfficiently(numSteps, {
disableParticles = true
}={}) {
const prevParticlesEnabled = this.particlesEnabled
if (disableParticles) {
this.particlesEnabled = false
}
for (let i = 0; i < numSteps; i++) {
this.physicsStep()
this.physicsStepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
this.particlesEnabled = prevParticlesEnabled
}
spawnBall({
spriteUrl = "random"
}={}) {
if (!this.startPos) {
throw new Error("StartPos must be set before spawning ball")
}
if (spriteUrl == "random") {
spriteUrl = AllBallSprites[Math.floor(Math.random() * AllBallSprites.length)]
}
const ball = new Ball(
this.startPos.copy(), new Vector2d(0, 0),
false, 18, spriteUrl, 0, true,
Math.random().toString().slice(2), 0
)
this.balls.push(ball)
return ball
}
addConstructionLine(line, phone, timestamp, deviceIndex) {
this.constructionLineBuffer.push({
line, phone, timestamp, deviceIndex})
this.parseConstructionLines()
}
toObject() {
return {
course: this.course.toObject(),
objects: this.objects.map(o => o.toObject()),
balls: this.balls.map(b => b.toObject()),
physicsTime: this.physicsTime,
ballCollisionEnabled: this.ballCollisionEnabled,
deviceGravityEnabled: this.deviceGravityEnabled,
particlesEnabled: this.particlesEnabled,
particles: this.particles.map(p => p.toObject())
}
}
static fromObject(obj) {
return new Board(
Course.fromObject(obj.course),
obj.objects.map(o => GolfObject.fromObject(o)),
obj.balls.map(b => Ball.fromObject(b)),
obj.physicsTime, obj.ballCollisionEnabled,
obj.deviceGravityEnabled, obj.particlesEnabled,
obj.particles?.map(p => Particle.fromObject(p))
)
}
get currPhoneIndex() {
return Math.max(1, this.course.phones.length)
}
parseConstructionLines() {
this.constructionLineBuffer = this.constructionLineBuffer
.filter(c => Date.now() - c.timestamp < 2500)
if (this.constructionLineBuffer.length < 2) {
return
}
const removeIndeces = new Set()
for (let i = 0; i + 1 < this.constructionLineBuffer.length; i++) {
let a = this.constructionLineBuffer[i]
let b = this.constructionLineBuffer[i + 1]
if (a.deviceIndex > b.deviceIndex) {
[a, b] = [b, a] // swap values, make sure {a} has smaller deviceIndex
}
if (!this.connectTwoConstructionLines(a, b)) {
removeIndeces.add(i)
}
}
this.constructionLineBuffer = this.constructionLineBuffer
.filter((_, i) => !removeIndeces.has(i))
}
connectTwoConstructionLines(a, b) {
if (a.deviceIndex > this.currPhoneIndex || a.deviceIndex == b.deviceIndex) {
return false
}
if (a.deviceIndex < this.currPhoneIndex) {
while (this.course.phones.length > parseInt(a.deviceIndex) && this.courseHistory.length > 1) {
this.courseHistory.pop()
this.course = this.courseHistory.slice(-1)[0].copy()
}
}
if (this.course.phones.length == 0) {
this.course = new Course([a.phone.copy()])
this.courseHistory.push(this.course.copy())
}
const deltaA = a.line.endPos.sub(a.line.startPos)
const deltaB = b.line.endPos.sub(b.line.startPos)
const originA = a.line.startPos.copy()
const originB = b.line.startPos.copy()
this.course.scale(deltaB.length / deltaA.length)
originA.iscale(deltaB.length / deltaA.length)
this.course.rotate(deltaB.angle - deltaA.angle)
originA.irotate(deltaB.angle - deltaA.angle)
this.course.translate(originB.sub(originA))
this.course.addPhone(b.phone.copy())
this.course.addLine(new PhoneConnectionLine(b.line.startPos, b.line.endPos))
this.courseHistory.push(this.course.copy())
return true
}
copy() {
return Board.fromObject(this.toObject())
}
}
const gamePhase = {
None: -1,
Hello: 0,
ModeChoice: 1,
PlayerSetupDuell: 2,
PlayerSetupTournament: 3,
Connecting: 4,
ConfigGame: 5,
TournamentExplanation: 6,
DuellExplanation: 7,
ConstructionChoice: 8,
ConstructionAuto: 9,
ConstructionCustom: 10,
Loading: 11,
Placing: 12,
PlayingDuell: 13,
PlayingSandbox: 14,
PlayingTournament: 15,
ShowingResultsOfTournament: 16,
ShowingResultsOfDuell: 17,
__LOWEST_PLAYING: 13,
__LOWEST_SHOWING_RESULTS: 16,
__MAX_VALUE: 18,
isPlaying(phase) {
return (
phase == gamePhase.PlayingDuell
|| phase == gamePhase.PlayingSandbox
|| phase == gamePhase.PlayingTournament
)
},
}
const gamePhaseNames = {
[gamePhase.None]: "none",
[gamePhase.Hello]: "hello",
[gamePhase.ModeChoice]: "mode-choice",
[gamePhase.PlayerSetupDuell]: "player-setup-duell",
[gamePhase.PlayerSetupTournament]: "player-setup-tournament",
[gamePhase.Connecting]: "connecting",
[gamePhase.ConfigGame]: "config-game",
[gamePhase.TournamentExplanation]: "tournament-explanation",
[gamePhase.DuellExplanation]: "duell-explanation",
[gamePhase.ConstructionChoice]: "construction-choice",
[gamePhase.ConstructionAuto]: "construction-auto",
[gamePhase.ConstructionCustom]: "construction-custom",
[gamePhase.Loading]: "loading",
[gamePhase.Placing]: "placing",
[gamePhase.PlayingDuell]: "playing-duell",
[gamePhase.PlayingTournament]: "playing-tournament",
[gamePhase.PlayingSandbox]: "playing-sandbox",
[gamePhase.ShowingResultsOfTournament]: "showing-results-of-tournament",
[gamePhase.ShowingResultsOfDuell]: "showing-results-of-duell",
}
const gameMode = {
Sandbox: "sandbox",
Tournament: "tournament",
Duell: "duell",
None: "none",
}
class Player {
constructor(name, roundScores=[]) {
this.name = name
this.roundScores = roundScores
}
get score() {
let sum = 0
for (let score of this.roundScores) {
sum += score
}
return sum
}
toObject() {
return {
name: this.name,
roundScores: this.roundScores
}
}
static fromObject(obj) {
return new Player(obj.name, obj.score, obj.roundScores)
}
addRound(score) {
this.roundScores.push(score)
}
}
class GameState {
constructor(phase, mode, board, players=[], deviceIndex=null,
placingObjectType=golfObjectType.Start,
tournamentBuilderIndex=0, tournamentBallIndex=0,
duellActivePlayerIndex=0, duellWinnerIndex=null,
tournamentMaxKicks=10) {
this.phase = phase
this.mode = mode
this.board = board
this.players = players
this.deviceIndex = deviceIndex
this.placingObjectType = placingObjectType
this.tournamentBuilderIndex = tournamentBuilderIndex
this.tournamentBallIndex = tournamentBallIndex
this.duellActivePlayerIndex = duellActivePlayerIndex
this.duellWinnerIndex = duellWinnerIndex
this.tournamentMaxKicks = tournamentMaxKicks
}
replaceText(txt) {
if (this.mode == gameMode.Duell && this.players.length >= 2) {
txt = txt.replaceAll("<duell-player-1>", this.players[0].name)
txt = txt.replaceAll("<duell-player-2>", this.players[1].name)
}
return txt
}
get duellActivePlayer() {
return this.players[this.duellActivePlayerIndex % this.players.length]
}
get duellInactivePlayer() {
return this.players[(this.duellActivePlayerIndex + 1) % this.players.length]
}
get duellWinner() {
return this.players[this.duellWinnerIndex]
}
get tournamentFinished() {
return this.tournamentBuilderIndex >= this.players.length
}
get tournamentBuilder() {
return this.players[this.tournamentBuilderIndex % this.players.length]
}
get tournamentBall() {
return this.board.balls[this.tournamentBallIndex % this.board.balls.length]
}
get tournamentActivePlayer() {
return this.players[this.tournamentBallIndex % this.players.length]
}
addPlayer(player) {
this.players.push(player)
}
get thisPhone() {
return this.board.course.phones[this.deviceIndex - 1]
}
getReferenceCanvas() {
return fullscreenCanvas
}
screenPosToBoardPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.screenPosToBoardPos(pos, screenSize)
}
boardPosToScreenPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.boardPosToScreenPos(pos, screenSize)
}
screenAngleToBoardAngle(angle) {
if (!this.thisPhone) return angle
return angle + this.thisPhone.angle
}
boardAngleToScreenAngle(angle) {
if (!this.thisPhone) return angle
return angle - this.thisPhone.angle
}
get scalingFactor() {
if (!this.thisPhone) return 1
return this.thisPhone.scalar
}
get creditCardScalingFactor() {
if (!this.thisPhone) return 1
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.creditCardScalingFactor(screenSize)
}
get combinedScalingFactor() {
return this.creditCardScalingFactor * this.scalingFactor
}
toObject(deviceIndex) {
return {
phase: this.phase,
mode: this.mode,
board: this.board.toObject(),
players: this.players.map(p => p.toObject()),
index: deviceIndex ?? this.deviceIndex,
placingObjectType: this.placingObjectType,
tournamentBuilderIndex: this.tournamentBuilderIndex,
tournamentBallIndex: this.tournamentBallIndex,
duellActivePlayerIndex: this.duellActivePlayerIndex,
duellWinnerIndex: this.duellWinnerIndex,
tournamentMaxKicks: this.tournamentMaxKicks
}
}
static fromObject(obj) {
return new GameState(
obj.phase, obj.mode,
Board.fromObject(obj.board),
obj.players.map(p => Player.fromObject(p)),
obj.index,
obj.placingObjectType,
obj.tournamentBuilderIndex,
obj.tournamentBallIndex,
obj.duellActivePlayerIndex,
obj.duellWinnerIndex,
obj.tournamentMaxKicks)
}
updatePhysics(hostTime=Date.now()) {
this.board.updatePhysics(hostTime)
}
startSandboxRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateSandbox() {
this.board.balls = this.board.balls.filter(b => b.radius > 0)
}
startTournamentRound() {
this.board.balls = []
for (let i = 0; i < this.players.length; i++) {
const spriteUrl = AllBallSprites[i % AllBallSprites.length]
this.board.spawnBall({spriteUrl})
}
this.tournamentBallIndex = 0
this.board.balls.forEach(b => b.active = false)
this.tournamentBall.active = true
generateScoreboard()
}
endTournament() {
this.phase = gamePhase.ShowingResultsOfTournament
generateScoreboard()
}
endTournamentRound() {
if (this.board.balls.length == 0) {
return
}
this.phase = gamePhase.TournamentExplanation
for (let i = 0; i < this.players.length; i++) {
const roundIndex = this.tournamentBuilderIndex
if (!this.board.balls[i].inHole) {
this.players[i].roundScores[roundIndex] += 2
}
}
this.tournamentBuilderIndex++
this.board.balls.splice(0, this.board.balls.length)
if (this.tournamentFinished) {
this.endTournament()
}
this.board.objects = []
}
onTournamentKick(ball) {
let ballIndex = 0
for (let i = 0; i < this.board.balls.length; i++) {
ballIndex = i
if (ball.uid == this.board.balls[i].uid) {
break
}
}
this.tournamentBall.active = false
this.tournamentBallIndex = ballIndex + 1
this.tournamentBall.active = true
this.advanceTournamentBall(true)
}
advanceTournamentBall(forceSpeak=false) {
if (this.tournamentBall === undefined) {
return false
}
let prevPlayerName = this.tournamentActivePlayer.name
let inHoleCount = 0
while ((this.tournamentBall.inHole && this.tournamentBall.radius == 0)
|| (this.tournamentBall.kicks >= this.tournamentMaxKicks && !this.tournamentBall.isMoving())) {
inHoleCount++
this.tournamentBall.active = false
this.tournamentBallIndex++
this.tournamentBall.active = true
if (inHoleCount >= this.players.length) {
return false
}
}
if (prevPlayerName != this.tournamentActivePlayer.name || forceSpeak) {
if (window.AudioPlayer && gamePhase.isPlaying(this.phase)) {
setTimeout(() => {
if (gamePhase.isPlaying(this.phase)) {
window.AudioPlayer.say(this.tournamentActivePlayer.name)
}
}, 1000)
}
}
return true
}
updateTournament() {
let madeChange = false
for (let i = 0; i < this.players.length; i++) {
let kicks = this.board.balls[i].kicks
const player = this.players[i]
const roundIndex = this.tournamentBuilderIndex
if (player.roundScores[roundIndex] === undefined) {
player.addRound(kicks)
madeChange = true
} else {
player.roundScores[roundIndex] = kicks
}
}
if (!this.advanceTournamentBall()) {
this.endTournamentRound()
madeChange = true
}
return madeChange
}
endDuell() {
this.phase = gamePhase.ShowingResultsOfDuell
this.board.balls = []
}
startDuellRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateDuell() {
const ball = this.board.balls[0]
if (ball.radius == 0 && ball.inHole) {
const closestObject = this.board.getClosestObject(ball.pos)
if (closestObject.type == golfObjectType.DuellHole1) {
this.duellWinnerIndex = 0
} else {
this.duellWinnerIndex = 1
}
this.endDuell()
return true
}
}
update(hostTime=Date.now()) {
this.updatePhysics(hostTime)
if (gamePhase.isPlaying(this.phase)) {
if (this.mode == gameMode.Tournament) {
return this.updateTournament()
} else if (this.mode == gameMode.Sandbox) {
return this.updateSandbox()
} else if (this.mode == gameMode.Duell) {
return this.updateDuell()
}
}
}
}
class Renderer {
static spriteImgMap = {}
static async loadImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
img.dataset.sprite = src
})
}
static async load() {
const promises = Object.values(Sprite).map(s => this.loadImg(s))
for (const img of await Promise.all(promises)) {
this.spriteImgMap[img.dataset.sprite] = img
}
}
static startSize = new Vector2d(40, 40)
static endSize = new Vector2d(50, 50)
static updateCanvasSize(context) {
context.canvas.width = context.canvas.clientWidth
context.canvas.height = context.canvas.clientHeight
}
static drawSprite(context, centerPos, size, sprite, {
angle = 0,
imageSmoothing = false
}={}) {
const img = this.spriteImgMap[sprite]
if (!img) {
throw new Error(`Unknown Sprite: ${sprite}`)
}
context.imageSmoothingEnabled = imageSmoothing // as some sprites may be very small in size
context.save()
context.translate(centerPos.x, centerPos.y)
context.rotate(angle)
context.drawImage(img, -size.x / 2, -size.y / 2, size.x, size.y)
context.restore()
}
static get screenUnit() {
return Math.min(window.innerWidth, window.innerHeight) * 0.1
}
static renderNothing(gameState, context, touchInfo) {
context.canvas.style.display = "none"
document.body.style.overflow = "visible"
const fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || document.fullscreenElement
if (fullscreenElement) {
if (document.exitFullscreen) {
document.exitFullscreen()
} else if (document.msExitFullscreen) {
document.msExitFullscreen()
} else if (document.mozCancelFullScreen) {
document.mozCancelFullScreen()
} else if (document.webkitCancelFullScreen) {
document.webkitCancelFullScreen()
}
}
}
static drawCircle(context, pos, radius) {
context.beginPath()
context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI, false)
}
static renderConnectionLines(gameState, context, touchInfo) {
for (const line of gameState.board.course.lines) {
context.beginPath()
const startPos = gameState.boardPosToScreenPos(line.start)
const endPos = gameState.boardPosToScreenPos(line.end)
context.moveTo(startPos.x, startPos.y)
context.lineTo(endPos.x, endPos.y)
context.lineWidth = 20 / gameState.combinedScalingFactor
context.strokeStyle = line.color
context.lineCap = "round"
context.stroke()
}
}
static renderConstruction(gameState, context, touchInfo) {
const canvas = context.canvas
canvas.style.display = "block"
context.fillStyle = "#79FFB6"
context.fillRect(0, 0, canvas.width, canvas.height)
context.textBaseline = "middle"
context.textAlign = "center"
context.font = `${this.screenUnit * 3}px Arial`
context.fillStyle = "black"
context.fillText(gameState.deviceIndex + ".", canvas.width / 2, canvas.height / 2)
if (touchInfo.isDown) {
if (touchInfo.lastDownPos) {
context.beginPath()
context.moveTo(touchInfo.lastDownPos.x, touchInfo.lastDownPos.y)
context.lineTo(touchInfo.currPos.x, touchInfo.currPos.y)
context.lineWidth = 30
context.lineCap = "round"
context.strokeStyle = "#bac4ff"
context.stroke()
}
context.fillStyle = "blue"
this.drawCircle(context, touchInfo.currPos, 25)
context.fill()
}
this.renderConnectionLines(gameState, context, touchInfo)
}
static drawObjectOutline(gameState, context, object) {
const screenCorners = object.relativeCorners
.map(c => c.scale(1.2))
.map(c => c.add(object.pos))
.map(c => gameState.boardPosToScreenPos(c))
context.beginPath()
context.moveTo(screenCorners[0].x, screenCorners[0].y)
for (let i = 0; i < screenCorners.length; i++) {
const index = (i + 1) % screenCorners.length
context.lineTo(screenCorners[index].x, screenCorners[index].y)
}
context.strokeStyle = "blue"
context.lineWidth = 3
context.lineCap = "round"
context.stroke()
this.drawSprite(context, gameState.boardPosToScreenPos(object.dragCorner),
new Vector2d(20, 20), Sprite.ZoomIcon, {imageSmoothing: true})
}
static drawCustomWall(gameState, context, corners) {
context.beginPath()
context.moveTo(corners[0].x, corners[0].y)
for (let i = 0; i < corners.length; i++) {
const index = (i + 1) % corners.length
context.lineTo(corners[index].x, corners[index].y)
}
context.strokeStyle = "black"
context.fillStyle = "white"
context.lineWidth = 3 / gameState.combinedScalingFactor
context.lineCap = "round"
context.fill()
context.stroke()
}
static drawGravityArrow(context, pos, direction) {
direction = direction.rotate(-Math.PI / 2)
context.save()
context.translate(pos.x, pos.y)
context.rotate(direction.angle)
context.scale(direction.length, direction.length)
context.beginPath()
context.moveTo(-0.5, 0)
context.lineTo(0.5, 0)
context.lineTo(0, 1)
context.lineTo(-0.5, 0)
context.fillStyle = "#5cfaa3"
context.fill()
context.restore()
}
static drawGravityArrows(gameState, context, touchInfo) {
let arrowDirection = gameState.board.course.phones[gameState.deviceIndex - 1].gravity
if (!arrowDirection) return
arrowDirection = arrowDirection.scale(200 / gameState.scalingFactor)
if (arrowDirection.length < 30 / gameState.scalingFactor) {
arrowDirection = arrowDirection.normalized.scale(30 / gameState.scalingFactor)
}
let pos = new Vector2d(0, 0)
let gridSize = Math.max(arrowDirection.length * 2, 100 / gameState.scalingFactor)
for (let x = gridSize / 2; x < context.canvas.width; x += gridSize) {
for (let y = gridSize / 2; y < context.canvas.height; y += gridSize) {
pos.set(x, y)
this.drawGravityArrow(context, pos, arrowDirection)
}
}
}
static renderBoard(gameState, context, touchInfo, {
drawBalls = true,
drawSelection = true,
drawGravity = false,
drawConnectionLines = false,
}={}) {
context.canvas.style.display = "block"
const backgroundSizePx = 160 / gameState.combinedScalingFactor
const backgroundSizePercent = Math.max(backgroundSizePx / context.canvas.width * 100, 1)
context.canvas.style.backgroundSize = `${backgroundSizePercent}%`
if (drawConnectionLines) {
this.renderConnectionLines(gameState, context, touchInfo)
}
if (drawGravity) {
this.drawGravityArrows(gameState, context, touchInfo)
}
for (const object of gameState.board.objects) {
if (object.type == golfObjectType.CustomWall) {
const screenCorners = object.corners.map(corner => {
return gameState.boardPosToScreenPos(corner)})
this.drawCustomWall(gameState, context, screenCorners)
} else {
const screenPos = gameState.boardPosToScreenPos(object.pos)
this.drawSprite(context, screenPos,
object.size.scale(1 / gameState.combinedScalingFactor),
object.sprite, {angle: gameState.boardAngleToScreenAngle(object.angle)})
}
if (drawSelection) {
if (touchInfo.focusedObject && object.uid == touchInfo.focusedObject.uid) {
this.drawObjectOutline(gameState, context, object)
}
}
}
if (!drawBalls) {
return
}
const renderBalls = gameState.board.balls.slice()
renderBalls.sort((a, b) => {
if (b.active) return -1
else return 0
})
for (let ball of renderBalls) {
const screenPos = gameState.boardPosToScreenPos(ball.pos)
const size = new Vector2d(ball.radius, ball.radius).scale(2 / gameState.combinedScalingFactor)
if (!ball.active && !ball.isMoving()) {
context.globalAlpha = 0.5
}
context.save()
context.translate(screenPos.x, screenPos.y)
context.rotate(gameState.boardAngleToScreenAngle(ball.rotationAngle))
this.drawSprite(context, new Vector2d(0, 0), size, ball.spriteUrl)
context.restore()
context.globalAlpha = 1.0
}
if (gameState.board.particlesEnabled) {
for (const particle of gameState.board.particles) {
context.globalAlpha = particle.opacity
const screenPos = gameState.boardPosToScreenPos(particle.pos)
context.fillStyle = particle.color
context.fillRect(screenPos.x, screenPos.y, particle.radius, particle.radius)
}
context.globalAlpha = 1.0
}
}
static renderBallInteractions(gameState, context, touchInfo) {
if (!touchInfo.isDown || !touchInfo.focusedBall || !touchInfo.currPos) {
return
}
const ballScreenPos = gameState.boardPosToScreenPos(touchInfo.focusedBall.pos)
context.beginPath()
context.moveTo(ballScreenPos.x, ballScreenPos.y)
context.lineTo(touchInfo.currPos.x, touchInfo.currPos.y)
context.strokeStyle = "rgba(0, 0, 0, 0.5)"
context.lineWidth = touchInfo.focusedBall.radius / gameState.scalingFactor
context.lineCap = "round"
context.stroke()
}
static renderPlacingTools(gameState, context, touchInfo) {
if (gameState.placingObjectType == golfObjectType.Eraser
&& touchInfo.isDown && touchInfo.currPos
) {
this.drawSprite(context, touchInfo.currPos, new Vector2d(60, 60), Sprite.Eraser,
{angle: gameState.boardAngleToScreenAngle(0)})
}
}
static renderChallengeBalls(gameState, context, touchInfo, challengeBalls) {
const fontSize = context.canvas.height * 0.06
const padding = 10
context.font = `bold ${fontSize}px Arial`
context.fillStyle = "white"
context.textAlign = "left"
context.textBaseline = "top"
context.strokeStyle = "black"
context.lineWidth = 5
context.strokeText(challengeBalls, padding + fontSize * 1.1, 10)
context.fillText(challengeBalls, padding + fontSize * 1.1, 10)
const ballSprite = gameState.board.balls[0]?.spriteUrl ?? Sprite.BallWhite
this.drawSprite(context, new Vector2d(1, 1).scale(padding + fontSize * 0.5 - 3),
new Vector2d(1, 1).scale(fontSize * 0.8), ballSprite)
}
static render(gameState, context, touchInfo, {
preventScrolling = true,
challengeBalls = undefined
}={}) {
this.updateCanvasSize(context)
if (preventScrolling) {
document.body.style.overflow = "hidden"
}
if ([
gamePhase.ConstructionChoice,
gamePhase.ConstructionAuto,
gamePhase.ConstructionCustom
].includes(gameState.phase)) {
return this.renderConstruction(gameState, context, touchInfo)
}
if (gameState.phase == gamePhase.Placing) {
this.renderBoard(gameState, context, touchInfo,
{drawBalls: false, drawGravity: false, drawConnectionLines: true})
return this.renderPlacingTools(gameState, context, touchInfo)
}
if (gamePhase.isPlaying(gameState.phase)) {
this.renderBoard(gameState, context, touchInfo, {drawSelection: false, drawGravity: false})
if (challengeBalls !== undefined) {
this.renderChallengeBalls(gameState, context, touchInfo, challengeBalls)
}
return this.renderBallInteractions(gameState, context, touchInfo)
}
return this.renderNothing(gameState, context, touchInfo)
}
}
const dataMessageType = {
PING: "ping",
GAMESTATE: "gamestate",
CONSTRUCTION_LINE: "construction_line",
PLACE_OBJECT: "place_object",
CHANGE_OBJECT: "change_object",
REMOVE_OBJECT: "remove_object",
REQUEST_DIMENSIONS: "request_dimensions",
SEND_DIMENSIONS: "send_dimensions",
KICK_BALL: "kick_ball",
DEVICE_ORIENTATION: "device_orientation"
}
class DataMessage {
constructor(type, data, createTime, receivedTime, hostTime) {
this.type = type
this.data = data ?? {}
this.createTime = createTime ?? Date.now()
this.hostTime = hostTime ?? null
this.receivedTime = receivedTime ?? null
}
toString() {
return JSON.stringify({
type: this.type,
data: this.data,
createTime: this.createTime,
receivedTime: this.receivedTime,
hostTime: this.hostTime
})
}
static fromObject(obj) {
return new DataMessage(obj.type, obj.data, obj.createTime, obj.receivedTime, obj.hostTime)
}
static fromString(jsonString) {
return DataMessage.fromObject(JSON.parse(jsonString))
}
static Ping(data={}) {
return new DataMessage(dataMessageType.PING, data)
}
}
const rtcDataType = {
openPool: "open_pool",
joinPool: "join_pool",
Offer: "offer",
Answer: "answer",
HostCandidate: "host-candidate",
AnswerCandidate: "answer-candidate",
}
function getNotSoSecretMeteredApiKey() {
let str = "fa94c40a3450effec69e410ae8d2b6e"
const isPrime = n=>{
if (n < 2) return false
if (n === 2) return true
if (n % 2 === 0) return false
for (let i = 3; i <= Math.sqrt(n); i += 2) {
if (n % i === 0) return false
}
return true
}
let count = 0
for (let i = 0; true; i++) {
if (isPrime(i)) {
count++
if (count == 5425) {
str += i.toString()
break
}
}
}
return str.split("").reverse().join("")
}
const notSoSecretMeteredApiKey = getNotSoSecretMeteredApiKey()
class RtcBase {
static pingPeriod = 3000
closePoolApi = "https://www.noel-friedrich.de/multigolf2/api/close_pool.php"
getSignalsApi = "https://www.noel-friedrich.de/multigolf2/api/get_signals.php"
sendSignalApi = "https://www.noel-friedrich.de/multigolf2/api/send_signal.php"
getIceServersApi = "https://multigolf2.metered.live/api/v1/turn/credentials?apiKey=" + notSoSecretMeteredApiKey
static checkForSignalsInterval = 1000
static clientTimeoutPeriod = 20 * 1000
static hostTimeoutPeriod = 10 * 1000
initDatachannelListeners() {
this.dataChannel.onopen = (e) => {
if (!this.alive) return
this.logFunction(Text.ConnectionEstablished)
this.dataChannelOpen = true
}
this.dataChannel.onmessage = (e) => {
if (!this.alive) return
const message = DataMessage.fromString(e.data)
if (message.receivedTime === null) {
message.receivedTime = Date.now()
}
this.lastDataMessage = message
this.lastDataMessageTime = Date.now()
this.onDataMessage(message)
}
this.dataChannel.onclose = (e) => {
if (!this.alive) return
this.logFunction(Text.ConnectionDied)
this.dataChannelOpen = false
this.die()
this.onDataClose()
}
}
async init() {
if (this.hasInitted) {
return
}
if (new URLSearchParams(location.search).has("debug")) {
this.logFunction(Text.InitializingPeerToPeer)
}
this.hasInitted = true
const response = await fetch(this.getIceServersApi)
const iceServers = await response.json()
if (new URLSearchParams(location.search).has("debug")) {
console.log("[DEBUG] received ice servers from api", iceServers)
}
iceServers.push({urls: "stun:stun.l.google.com:19302"})
iceServers.push(...[{urls: 'stun:freeturn.net:5349'}, {urls: 'turns:freeturn.tel:5349', username: 'free', credential: 'free'}])
this.peerConnection = new RTCPeerConnection({iceServers: iceServers})
this.dataChannel = this.peerConnection.createDataChannel("chat", {
negotiated: true, id: 0})
this.initDatachannelListeners()
}
constructor({
logFunction = () => {},
onDataMessage = () => {},
onDataClose = () => {},
index = -1,
poolUid = null,
}={}) {
this.logFunction = logFunction
this.onDataMessage = onDataMessage
this.onDataClose = onDataClose
this.processedSignalIds = new Set()
this.dataChannelOpen = false
this.signalingUid = null
this.hasInitted = false
this.lastDataMessage = null
this.lastDataMessageTime = null
this.alive = true
this.index = index
this.poolUid = poolUid
if (!poolUid) {
throw new Error("PoolUid must be given to WebRTC Handler")
}
}
die() {
this.alive = false
}
sendMessage(message) {
if (!this.alive) return
if (message instanceof DataMessage) {
if (this.delayMs !== undefined) {
message.hostTime = Date.now() + this.delayMs
}
message = message.toString()
}
if (this.dataChannelOpen) {
this.dataChannel.send(message)
return true
} else {
return false
}
}
async uploadToServer(type, data, objectName, logSuccess=true) {
try {
let apiUrl = this.sendSignalApi
apiUrl += `?type=${encodeURIComponent(type)}`
apiUrl += `&pool_uid=${encodeURIComponent(this.poolUid)}`
apiUrl += `&uid=${encodeURIComponent(this.signalingUid)}`
apiUrl += `&data=${encodeURIComponent(JSON.stringify(data))}`
const response = await fetch(apiUrl)
const textResponse = await response.text()
if (textResponse == "worked like a charm") {
if (logSuccess) {
this.logFunction(Text.SuccessfullySentObject(objectName))
}
return true
} else {
throw new Error(`Unknown Server Response: ${textResponse}`)
}
} catch (err) {
this.logFunction(Text.FailedSendingObject(objectName, err.message))
throw err
}
}
async getFromServer(type, uid) {
try {
let apiUrl = this.getSignalsApi
apiUrl += `?pool_uid=${encodeURIComponent(this.poolUid)}`
const response = await fetch(apiUrl)
let rows = await response.json()
rows = rows.filter(r => !this.processedSignalIds.has(r.id))
if (type !== undefined) {
rows = rows.filter(r => r.type == type)
}
if (uid !== undefined) {
rows = rows.filter(r => r.uid == uid)
}
for (let row of rows) {
row.data = JSON.parse(row.data)
this.processedSignalIds.add(row.id)
}
return rows
} catch (err) {
this.logFunction(Text.CouldntFetchServer(err.message))
throw err
}
}
async waitUntil(func, name, {
timeout = 60000,
checkIntervalMs = 100,
}={}) {
const startWaitTime = Date.now()
while (true) {
const timeElapsed = Date.now() - startWaitTime
if (timeElapsed > timeout) {
this.die()
throw new Error(`Timeout while waiting for ${name}`)
}
if (!this.alive) {
throw new Error(`Connection died while waiting for ${name}`)
}
if (func()) {
return
}
await new Promise(resolve => setTimeout(resolve, checkIntervalMs))
}
}
async checkForUpdates(untilFunc, handleUpdate, objectName, {
checkInterval = RtcBase.checkForSignalsInterval,
timeoutPeriod = RtcBase.hostTimeoutPeriod,
}) {
const startTime = Date.now()
while (!untilFunc()) {
const updates = await this.getFromServer(undefined, this.signalingUid)
if (!this.alive) {
throw new Error(`Connection died while waiting for ${objectName}`)
}
for (let update of updates) {
handleUpdate(update)
}
const timeElapsed = Date.now() - startTime
if (timeElapsed > timeoutPeriod) {
this.die()
throw new Error(`Timeout while waiting for ${objectName}`)
}
await new Promise(resolve => setTimeout(resolve, checkInterval))
}
}
generateSignalingUid() {
return Math.random().toString().slice(2)
}
}
class RtcHost extends RtcBase {
getStatus() {
let color = "green"
let message = Text.GoodConnection
if (!this.lastDataMessageTime) {
color = "blue"
message = Text.ConnectionBeingInitialized
} else if (Date.now() - this.lastDataMessageTime > RtcBase.pingPeriod * 2) {
color = "red"
message = Text.ConnectionTimedOut
}
if (this.lastDataMessage && color == "green") {
if (this.delayMs > 500) {
color = "orange"
message = Text.ConnectionIsSlow(Math.round(this.delayMs * 2))
}
}
return {color, message}
}
receivePing(pingMessage) {
this.receivedPing = pingMessage
if (pingMessage.data.displaySize) {
const before = this.clientDisplaySize ? this.clientDisplaySize.copy() : null
this.clientDisplaySize = Vector2d.fromObject(pingMessage.data.displaySize)
if (!before || before.x != this.clientDisplaySize.x || before.y != this.clientDisplaySize.y) {
return true
}
}
return false
}
async startPinging() {
while (true) {
const pingStartTime = Date.now()
this.sendMessage(DataMessage.Ping({index: this.index}))
this.receivedPing = null
await this.waitUntil(() => this.receivedPing, "Pinging")
const timeElapsed = this.receivedPing.receivedTime - pingStartTime
this.delayMs = (timeElapsed / 2) * 0.1 + this.delayMs * 0.9
await new Promise(resolve => setTimeout(resolve, RtcBase.pingPeriod))
}
}
async start(signalingUid) {
this.delayMs = 0
this.signalingUid = signalingUid
this.clientDisplaySize = null
await this.init()
this.peerConnection.addEventListener("icecandidateerror", event => {
if (!this.alive) return
if (new URLSearchParams(location.search).has("debug")) {
console.log(`[DEBUG] ICE candidate error: ${event.errorText}`)
}
})
this.peerConnection.addEventListener("icecandidate", event => {
if (!this.alive) return
if (event.candidate == null) return
this.uploadToServer(rtcDataType.HostCandidate, {
candidate: event.candidate
}, "Ice Candidate", false)
})
const offer = await this.peerConnection.createOffer()
await this.peerConnection.setLocalDescription(offer)
if (!this.alive) return
this.uploadToServer(rtcDataType.Offer, {
sdp: this.peerConnection.localDescription
}, "Connection Offer", new URLSearchParams(location.search).has("debug"))
await this.checkForUpdates(
() => this.dataChannelOpen,
async (signal, abort) => {
if (signal.type == rtcDataType.AnswerCandidate) {
const candidate = new RTCIceCandidate(signal.data.candidate)
this.peerConnection.addIceCandidate(candidate)
}
if (signal.type == rtcDataType.Answer) {
if (this.peerConnection.signalingState != "have-local-offer") {
return
}
const description = new RTCSessionDescription(signal.data.sdp)
await this.peerConnection.setRemoteDescription(description)
if (signal.data.sdp.type == "offer") {
const answer = await this.peerConnection.createAnswer()
await this.peerConnection.setLocalDescription(answer)
this.uploadToServer(rtcDataType.Offer, {
sdp: this.peerConnection.localDescription
}, Text.ConnectionAnswer)
}
}
},
Text.RTCAnswer,
{timeoutPeriod: RtcBase.hostTimeoutPeriod}
)
}
}
class RtcClient extends RtcBase {
getStatus() {
let color = "green"
let message = Text.GoodConnection
if (!this.lastDataMessageTime) {
color = "blue"
message = Text.ConnectionBeingInitialized
} else if (Date.now() - this.lastDataMessageTime > RtcBase.pingPeriod * 2) {
color = "red"
message = Text.ConnectionTimedOut
}
return {color, message}
}
async joinPool(deviceIndex) {
await this.uploadToServer(rtcDataType.joinPool, {
signalingUid: this.signalingUid, deviceIndex
}, Text.ConnectionInvitation)
}
async start(deviceIndex=null) {
await this.init()
this.answerSdp = null
this.offerSdp = null
this.signalingUid = this.generateSignalingUid()
await this.joinPool(deviceIndex)
if (!this.alive) return
this.peerConnection.addEventListener("icecandidateerror", event => {
if (!this.alive) return
if (new URLSearchParams(location.search).has("debug")) {
console.log(`[DEBUG] ICE candidate error: ${event.errorText}`)
}
})
this.peerConnection.addEventListener("icecandidate", event => {
if (!this.alive) return
if (event.candidate == null) return
this.uploadToServer(rtcDataType.AnswerCandidate, {
candidate: event.candidate
}, "Ice Candidate", false)
})
await this.checkForUpdates(
() => this.dataChannelOpen,
async (signal) => {
if (signal.type == rtcDataType.HostCandidate) {
const candidate = new RTCIceCandidate(signal.data.candidate)
this.peerConnection.addIceCandidate(candidate)
}
if (signal.type == rtcDataType.Offer) {
const description = new RTCSessionDescription(signal.data.sdp)
await this.peerConnection.setRemoteDescription(description)
if (signal.data.sdp.type == "offer") {
const answer = await this.peerConnection.createAnswer()
await this.peerConnection.setLocalDescription(answer)
this.uploadToServer(rtcDataType.Answer, {
sdp: this.peerConnection.localDescription
}, Text.ConnectionAnswer)
}
}
},
"RTC Offer",
{timeoutPeriod: RtcBase.clientTimeoutPeriod}
)
}
}
class RtcHostManager {
static checkForJoinsPeriod = 5000
static clientUrl = "https://multi.golf/client/"
static openPoolApi = "https://www.noel-friedrich.de/multigolf2/api/open_pool.php"
constructor({
logFunction = () => {},
onDataMessage = () => {},
onClientUrlAvailable = () => {},
allowConnectionOverride = () => true
}={}) {
this.gameState = gameState
this.logFunction = logFunction
this.onDataMessage = onDataMessage
this.onClientUrlAvailable = onClientUrlAvailable
this.allowConnectionOverride = allowConnectionOverride
this.poolUid = null
this.connections = []
this.polling = false
}
makeConnection(deviceIndex) {
const connection = new RtcHost({
logFunction: (message) => {
if (!connection.alive) {
return
}
this.logFunction(`[${connection.index}] ${message}`)
},
onDataMessage: (message) => {
this.onDataMessage(message, connection)
},
poolUid: this.poolUid
})
if (deviceIndex != null && deviceIndex <= this.connections.length) {
this.connections[deviceIndex - 1].die()
this.connections[deviceIndex - 1] = connection
} else {
this.connections.push(connection)
}
this.sortConnections()
return connection
}
sortConnections() {
this.connections.sort((a, b) => {
return a.randomOffset - b.randomOffset
})
for (let i = 0; i < this.connections.length; i++) {
this.connections[i].index = i + 1
}
}
async openPool() {
const urlParams = new URLSearchParams(location.search)
if (urlParams.has("debug") && urlParams.has("p")) {
return urlParams.get("p")
}
const response = await fetch(RtcHostManager.openPoolApi)
const jsonData = await response.json()
return jsonData["pool_uid"]
}
makeClientUrl() {
return RtcHostManager.clientUrl + `?p=${encodeURIComponent(this.poolUid)}`
}
async start() {
this.poolUid = await this.openPool()
this.onClientUrlAvailable(this.makeClientUrl())
this.logFunction(Text.CreatedPool(this.poolUid))
this.baseConnection = new RtcBase({poolUid: this.poolUid})
this.startPolling()
}
async startPolling() {
this.polling = true
while (this.polling) {
const updates = await this.baseConnection.getFromServer(rtcDataType.joinPool)
for (let update of updates) {
let deviceIndex = update.data.deviceIndex
const signalingUid = update.data.signalingUid
if (deviceIndex != null
&& this.connections[deviceIndex - 1]
&& this.connections[deviceIndex - 1].getStatus().color !== "red"
&& this.allowConnectionOverride()
) {
deviceIndex = null
}
const connection = this.makeConnection(deviceIndex)
connection.start(signalingUid).then(() => {
connection.startPinging()
})
}
await new Promise(resolve => setTimeout(resolve, RtcHostManager.checkForJoinsPeriod))
}
}
removeLostConnections() {
for (const connection of this.connections) {
if (connection.getStatus().color == "red" && connection.alive) {
connection.die()
}
}
this.connections = this.connections.filter(c => c.alive)
rtc.sortConnections()
}
}
const golfObjectType = {
Start: "Start",
Hole: "Hole",
Lava: "Lava",
Cannon: "Cannon",
Eraser: "Eraser",
DuellHole1: "Hole 1",
DuellHole2: "Hole 2",
CustomWall: "Extra Wall",
GravityBox: "Gravity Box"
}
let golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Cannon]: Sprite.Cannon,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
class GolfObject {
constructor(type, pos, size, angle, uid, resizable) {
this.type = type
this.pos = pos ?? new Vector2d(0, 0)
this.size = size ?? new Vector2d(40, 40)
this.angle = angle ?? 0
this.uid = uid ?? Math.random().toString().slice(2)
this.resizable = resizable ?? false
this.visibility = () => true
}
setPos(pos) {
this.pos = pos
return this
}
translate(point) {
this.pos.iadd(point)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
scale(scalar) {
this.pos.iscale(scalar)
this.size.iscale(scalar)
}
get topLeftPos() {
return this.pos.sub(this.size.scale(0.5).rotate(this.angle))
}
get relativeCorners() {
const halfSize = this.size.scale(0.5)
return [
halfSize.scale(-1),
halfSize.scaleY(-1),
halfSize,
halfSize.scaleX(-1)
].map(v => v.rotate(this.angle))
}
get corners() {
return this.relativeCorners.map(c => c.add(this.pos))
}
get walls() {
const corners = this.corners
return [
[corners[0], corners[1]],
[corners[1], corners[2]],
[corners[2], corners[3]],
[corners[3], corners[0]],
]
}
get dragCorner() {
return this.pos.sub(this.size.scale(0.6).rotate(this.angle))
}
intersects(point) {
const topLeft = this.topLeftPos.rotate(-this.angle)
const rotatedPoint = point.rotate(-this.angle)
return (
topLeft.x <= rotatedPoint.x && rotatedPoint.x <= (topLeft.x + this.size.x) &&
topLeft.y <= rotatedPoint.y && rotatedPoint.y <= (topLeft.y + this.size.y)
)
}
get radius() {
return this.topLeftPos.distance(this.pos)
}
set radius(newRadius) {
this.size = this.size.normalized.scale(newRadius * 2)
}
toObject() {
return {
type: this.type,
pos: this.pos.toObject(),
size: this.size.toObject(),
angle: this.angle,
uid: this.uid,
resizable: this.resizable
}
}
static fromObject(obj) {
return new GolfObject(
obj.type, Vector2d.fromObject(obj.pos),
Vector2d.fromObject(obj.size), obj.angle, obj.uid,
obj.resizable
)
}
get sprite() {
return golfObjectTypeSpriteMap[this.type]
}
copy() {
return GolfObject.fromObject(this.toObject())
}
setResizable(val) {
this.resizable = val
return this
}
setSize(size) {
this.size = size
return this
}
setAngle(angle) {
this.angle = angle
return this
}
setVisibility(func) {
this.visibility = func
return this
}
get name() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStart
case golfObjectType.Hole:
return Text.ObjectHole
case golfObjectType.Lava:
return Text.ObjectLava
case golfObjectType.Cannon:
return Text.ObjectCannon
case golfObjectType.Eraser:
return Text.ObjectEraser
case golfObjectType.DuellHole1:
return Text.ObjectDuellHole("1")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHole("2")
case golfObjectType.CustomWall:
return Text.ObjectCustomWall
case golfObjectType.GravityBox:
return Text.ObjectGravityBox
}
return ""
}
get description() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStartDescription
case golfObjectType.Hole:
return Text.ObjectHoleDescription
case golfObjectType.Lava:
return Text.ObjectLavaDescription
case golfObjectType.Cannon:
return Text.ObjectCannonDescription
case golfObjectType.Eraser:
return Text.ObjectEraserDescriptiom
case golfObjectType.DuellHole1:
return Text.ObjectDuellHoleDescription("<duell-player-1>")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHoleDescription("<duell-player-2>")
case golfObjectType.CustomWall:
return Text.ObjectCustomWallDescription
case golfObjectType.GravityBox:
return Text.ObjectGravityBoxDescription
}
return ""
}
static makeDefault(type) {
const obj = defaultObjects[type].copy()
obj.uid = Math.random().toString().slice(2)
return obj
}
}
const placableObjects = [
new GolfObject(golfObjectType.Start),
new GolfObject(golfObjectType.Hole).setVisibility(gs => gs.mode != gameMode.Duell),
new GolfObject(golfObjectType.Lava).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.Cannon).setSize(new Vector2d(80, 80)),
new GolfObject(golfObjectType.CustomWall).setSize(new Vector2d(120, 40)).setResizable(true),
new GolfObject(golfObjectType.GravityBox).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.DuellHole1).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.DuellHole2).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.Eraser),
]
const defaultObjects = {
[golfObjectType.Start]: placableObjects[0],
[golfObjectType.Hole]: placableObjects[1],
[golfObjectType.Lava]: placableObjects[2],
[golfObjectType.Cannon]: placableObjects[3],
[golfObjectType.CustomWall]: placableObjects[4],
[golfObjectType.GravityBox]: placableObjects[5],
[golfObjectType.DuellHole1]: placableObjects[6],
[golfObjectType.DuellHole2]: placableObjects[7],
}
async function loadCreditCardSizing() {
async function loadImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
img.dataset.sprite = src
})
}
const creditCardImg = await loadImg("../assets/objects/credit-card.svg")
const creditCardCanvas = document.getElementById("credit-card-canvas")
const context = creditCardCanvas.getContext("2d")
const biggerButton = document.getElementById("cc-bigger-button")
const smallerButton = document.getElementById("cc-smaller-button")
const minCreditCardHeight = 100
const maxCreditCardHeight = 1000
let creditCardPixelHeight = 500
const creditCardPixelWidth = () => creditCardPixelHeight * 2.125 / 3.375
if (localStorage.getItem("credit-card-px-height") != null) {
const height = parseInt(localStorage.getItem("credit-card-px-height"))
if (Number.isInteger(height) && height >= minCreditCardHeight && height <= maxCreditCardHeight) {
creditCardPixelHeight = height
}
}
window.creditCardPixelHeight = creditCardPixelHeight
function drawCreditCard() {
creditCardCanvas.height = creditCardPixelHeight
creditCardCanvas.width = creditCardCanvas.clientWidth
creditCardCanvas.style.height = creditCardCanvas.height + "px"
context.drawImage(creditCardImg, 0, 0, creditCardPixelWidth(), creditCardPixelHeight)
}
function updateCreditCardSize(increment) {
const height = creditCardPixelHeight + increment
creditCardPixelHeight = Math.max(minCreditCardHeight, Math.min(maxCreditCardHeight, height))
localStorage.setItem("credit-card-px-height", creditCardPixelHeight)
window.creditCardPixelHeight = creditCardPixelHeight
}
biggerButton.addEventListener("click", () => {
updateCreditCardSize(10)
drawCreditCard()
})
smallerButton.addEventListener("click", () => {
updateCreditCardSize(-10)
drawCreditCard()
})
window.addEventListener("resize", drawCreditCard)
drawCreditCard()
}
loadCreditCardSizing()
window.addEventListener("beforeunload", function (e) {
e.preventDefault()
return "You're in an active game of multigolf. Leaving this website will break the game!"
})
const logOutput = document.querySelector("#log-output")
const fullscreenCanvas = document.querySelector("#fullscreen-canvas")
const context = fullscreenCanvas.getContext("2d")
const statusTitle = document.querySelector("#status-title")
const fullscreenCheckbox = document.querySelector("#fullscreen-checkbox")
let requestFullscreenOnCanvasClick = true
if (new URLSearchParams(location.search).has("nofullscreen")) {
requestFullscreenOnCanvasClick = false
}
const deviceTilt = {
get steady() {
return Date.now() - deviceTilt.lastSignificantMoveTime > 1000
},
get stableTilt() {
return deviceTilt.previousSteadyTilt
},
lastSignificantMoveTime: Date.now(),
tilt: new Vector2d(0, 0),
previousSteadyTilt: new Vector2d(0, 0),
hasChangedFlag: false
}
addEventListener("deviceorientation", event => {
if (event.gamma == null || event.beta == null) {
return
}
deviceTilt.tilt.x = event.beta
if (deviceTilt.tilt.x > 90) {
deviceTilt.tilt.x = deviceTilt.tilt.x - 180
} else if (deviceTilt.tilt.x < -90) {
deviceTilt.tilt.x = 180 + deviceTilt.tilt.x
}
deviceTilt.tilt.y = event.gamma
const temp = deviceTilt.tilt.x
deviceTilt.tilt.x = deviceTilt.tilt.y
deviceTilt.tilt.y = temp
deviceTilt.tilt.x = Math.round(deviceTilt.tilt.x / 0.9) / 100
deviceTilt.tilt.y = Math.round(deviceTilt.tilt.y / 0.9) / 100
const epsilon = 0.05
if (!deviceTilt.tilt.distance(deviceTilt.previousSteadyTilt) < epsilon) {
deviceTilt.lastSignificantMoveTime = Date.now()
deviceTilt.previousSteadyTilt = deviceTilt.tilt.copy()
deviceTilt.hasChangedFlag = true
}
}, true)
fullscreenCheckbox.checked = requestFullscreenOnCanvasClick
fullscreenCheckbox.addEventListener("click", () => {
requestFullscreenOnCanvasClick = !requestFullscreenOnCanvasClick
fullscreenCheckbox.checked = requestFullscreenOnCanvasClick
})
function logToUser(message) {
if (logOutput.textContent.length > 0) {
logOutput.textContent += "\n"
}
logOutput.textContent += message
}
addEventListener("error", (err) => {
logToUser(`⚠️ ${err.message}`)
})
function fillPlaceholders(attr, value) {
for (let element of document.querySelectorAll("[data-fill]")) {
if (element.dataset.fill == attr) {
element.textContent = value
}
}
}
let deviceIndex = null
function updateDeviceIndex(newIndex) {
deviceIndex = newIndex
fillPlaceholders("device-index", deviceIndex != null ? deviceIndex : "?")
localStorage.setItem("multigolf-deviceIndex", deviceIndex)
}
const urlParams = new URLSearchParams(location.search)
if (!urlParams.has("p")) {
location.href = "../index.html"
}
let rtc = null
const noSleep = new NoSleep()
let hostTimeOffset = 0
function getHostTime() {
return Date.now() + hostTimeOffset
}
async function main() {
logOutput.textContent = ""
rtc?.die()
rtc = new RtcClient({
logFunction: logToUser,
onDataMessage: (dataMessage) => {
onDataMessage(dataMessage)
},
onDataClose: () => {
statusTitle.textContent = Text.ConnectionFailed
logToUser(Text.TryingAgainInSeconds(5))
setTimeout(main, 1 * 2 * 3 * 4 * 5 * 6 * 7) // 7! ~ 5000
},
poolUid: urlParams.get("p"),
})
statusTitle.textContent = Text.ConnectingToHost
if (localStorage.getItem("multigolf-poolUid") == rtc.poolUid) {
if (localStorage.getItem("multigolf-deviceIndex") != null) {
updateDeviceIndex(localStorage.getItem("multigolf-deviceIndex"))
}
} else {
localStorage.setItem("multigolf-poolUid", rtc.poolUid)
}
await Renderer.load()
document.querySelector("#loading-indicator").style.display = "none"
try {
await rtc.start(deviceIndex)
statusTitle.textContent = Text.ConnectedToHost
startGame()
} catch (err) {
logToUser(Text.CouldNotConnect)
logToUser(`Error-Message: ${err.message}`)
logToUser(Text.TryingAgainInSeconds(10))
statusTitle.textContent = Text.ConnectionFailed
return setTimeout(main, 10 * 1000)
}
}
document.addEventListener("click", function enableNoSleep() {
document.removeEventListener("click", enableNoSleep, false)
noSleep.enable()
}, false)
fullscreenCanvas.addEventListener("click", () => {
const fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || document.fullscreenElement
if (requestFullscreenOnCanvasClick
&& fullscreenElement != fullscreenCanvas
) {
if (fullscreenCanvas.requestFullscreen) {
fullscreenCanvas.requestFullscreen()
} else if (fullscreenCanvas.msRequestFullscreen) {
fullscreenCanvas.msRequestFullscreen()
} else if (fullscreenCanvas.mozRequestFullScreen) {
fullscreenCanvas.mozRequestFullScreen()
} else if (fullscreenCanvas.webkitRequestFullscreen) {
fullscreenCanvas.webkitRequestFullscreen()
}
}
})
main()
let gameState = null
const touchInfo = {
isDown: false,
lastDownPos: null,
lastUpPos: null,
currPos: null,
lastDownTime: null,
lastUpTime: null,
focusedBall: null,
focusedObject: null,
draggingObject: false
}
function clampToEdges(pos) {
return pos.clampX([0, fullscreenCanvas.width], 100)
.clampY([0, fullscreenCanvas.height], 100)
}
fullscreenCanvas.addEventListener("touchstart", event => {
touchInfo.isDown = true
touchInfo.currPos = Vector2d.fromTouchEvent(event, fullscreenCanvas)
touchInfo.lastDownPos = touchInfo.currPos.copy()
touchInfo.lastDownTime = Date.now()
if (gameState.phase == gamePhase.ConstructionCustom) {
touchInfo.currPos = clampToEdges(touchInfo.currPos)
touchInfo.lastDownPos = touchInfo.currPos.copy()
} else if (gamePhase.isPlaying(gameState.phase)) {
onBallDown(touchInfo)
} else if (gameState.phase == gamePhase.Placing) {
onObjectDown(touchInfo)
}
})
fullscreenCanvas.addEventListener("touchmove", event => {
touchInfo.currPos = Vector2d.fromTouchEvent(event, fullscreenCanvas)
if (gameState.phase == gamePhase.ConstructionCustom) {
touchInfo.currPos = clampToEdges(touchInfo.currPos)
} else if (gameState.phase == gamePhase.Placing) {
onPlaceTouchMove(touchInfo)
}
})
fullscreenCanvas.addEventListener("touchend", event => {
touchInfo.isDown = false
touchInfo.currPos = null
touchInfo.lastUpPos = Vector2d.fromTouchEvent(event, fullscreenCanvas)
touchInfo.lastUpTime = Date.now()
if (gameState.phase == gamePhase.ConstructionCustom) {
touchInfo.lastUpPos = clampToEdges(touchInfo.lastUpPos)
onConstructionTouchEvent(touchInfo)
} else if (gameState.phase == gamePhase.Placing) {
onPlaceTouchEvent(touchInfo)
} else if (gamePhase.isPlaying(gameState.phase)) {
onKickBallTouchEvent(touchInfo)
}
touchInfo.focusedBall = null
touchInfo.draggingObject = false
})
function renderLoop() {
if (rtc) {
try {
gameState.updatePhysics(getHostTime())
} catch (physicsError) {
logToUser(`[p] ${physicsError}`)
}
try {
if (rtc && rtc.getStatus().color == "green") {
fullscreenCanvas.style.display = "block"
Renderer.render(gameState, context, touchInfo)
} else {
fullscreenCanvas.style.display = "none"
}
} catch (renderError) {
logToUser(`[r] ${renderError}`)
}
}
window.requestAnimationFrame(renderLoop)
}
let startedOrientationInterval = false
async function startGame() {
gameState = new GameState(gamePhase.Connecting, gameMode.None, new Board())
renderLoop()
if (!startedOrientationInterval) {
startedOrientationInterval = true
setInterval(() => {
if (deviceTilt.steady && deviceTilt.hasChangedFlag && rtc) {
rtc.sendMessage(new DataMessage(dataMessageType.DEVICE_ORIENTATION,
{x: deviceTilt.stableTilt.x, y: deviceTilt.stableTilt.y, deviceIndex: gameState.deviceIndex}
))
deviceTilt.hasChangedFlag = false
}
}, 3000)
}
}
async function onKickBallTouchEvent(touchInfo) {
if (!touchInfo.focusedBall || !touchInfo.lastDownPos || !touchInfo.lastUpPos) {
return
}
if (touchInfo.lastDownPos.distance(touchInfo.lastUpPos) < 10) {
return
}
const ballPos = gameState.boardPosToScreenPos(touchInfo.focusedBall.pos)
const strength = Math.min(ballPos.distance(touchInfo.lastUpPos) * 0.3 / gameState.combinedScalingFactor, 70)
const touchUpBoardPos = gameState.screenPosToBoardPos(touchInfo.lastUpPos)
const direction = touchInfo.focusedBall.pos.sub(touchUpBoardPos).normalized.scale(-strength)
rtc.sendMessage(new DataMessage(dataMessageType.KICK_BALL,
{direction: direction.toObject(), ballUid: touchInfo.focusedBall.uid}))
if (gameState.mode == gameMode.Tournament) {
gameState.onTournamentKick(touchInfo.focusedBall)
}
touchInfo.focusedBall.kick(direction)
}
async function onObjectDown(touchInfo) {
if (touchInfo.focusedObject &&
gameState.boardPosToScreenPos(touchInfo.focusedObject.dragCorner).distance(touchInfo.currPos) < 20) {
touchInfo.draggingObject = true
} else {
const boardPos = gameState.screenPosToBoardPos(touchInfo.currPos)
const closestObject = gameState.board.getClosestObject(boardPos)
if (closestObject) {
if (closestObject.intersects(boardPos)) {
touchInfo.focusedObject = closestObject
} else {
touchInfo.focusedObject = null
}
} else {
touchInfo.focusedObject = null
}
}
if (gameState.placingObjectType == golfObjectType.Eraser) {
onPlaceTouchMove(touchInfo)
}
}
async function onBallDown(touchInfo) {
const boardPos = gameState.screenPosToBoardPos(touchInfo.currPos)
let smallestDistance = Infinity
let closestBall = null
for (const ball of gameState.board.balls) {
if (ball.isMoving() || !ball.active) {
continue
}
const distance = ball.pos.distance(boardPos)
if (distance < smallestDistance) {
smallestDistance = distance
closestBall = ball
}
}
if (smallestDistance < 100) {
touchInfo.focusedBall = closestBall
}
}
const snapAngle = angle => {
const mod = (n, m) => ((n % m) + m) % m
angle = mod(angle, Math.PI * 2)
const values = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2, Math.PI * 2,
Math.PI / 4, Math.PI / 4 * 3, Math.PI / 4 * 5, Math.PI / 4 * 7]
for (let val of values) {
if (Math.abs(val - angle) < 0.1) {
return val
}
}
return angle
}
async function onPlaceTouchMove(touchInfo) {
if (gameState.placingObjectType == golfObjectType.Eraser) {
const eraserPos = gameState.screenPosToBoardPos(touchInfo.currPos)
let hitObject = null
for (const object of gameState.board.objects) {
if (object.intersects(eraserPos)) {
hitObject = object
break
}
}
if (!hitObject) {
return
}
gameState.board.objects = gameState.board.objects.filter(o => o.uid != hitObject.uid)
rtc.sendMessage(new DataMessage(dataMessageType.REMOVE_OBJECT, {uid: hitObject.uid}))
return
}
if (!touchInfo.focusedObject) {
return
}
if (touchInfo.draggingObject) {
const objectPos = gameState.boardPosToScreenPos(touchInfo.focusedObject.pos)
const angle = objectPos.angleTo(touchInfo.currPos)
const angleOffset = Math.PI / 2 + Math.atan(touchInfo.focusedObject.size.x / touchInfo.focusedObject.size.y)
const boardAngle = gameState.screenAngleToBoardAngle(angle + angleOffset)
touchInfo.focusedObject.angle = snapAngle(boardAngle)
if (touchInfo.focusedObject.resizable) {
touchInfo.focusedObject.radius = objectPos.distance(touchInfo.currPos) / 1.2 * gameState.combinedScalingFactor
}
} else {
const boardPos = gameState.screenPosToBoardPos(touchInfo.currPos)
touchInfo.focusedObject.pos = boardPos
}
}
async function onPlaceTouchEvent(touchInfo) {
if (gameState.placingObjectType == golfObjectType.Eraser) {
return
}
if (touchInfo.focusedObject) {
console.log("Change Object", touchInfo.focusedObject)
rtc.sendMessage(new DataMessage(dataMessageType.CHANGE_OBJECT,
{object: touchInfo.focusedObject.toObject()}))
} else {
if (!touchInfo.lastUpPos || !touchInfo.lastDownPos
|| touchInfo.lastDownPos.distance(touchInfo.lastUpPos) > 10) {
return
}
const placedObject = placableObjects.find(o => o.type == gameState.placingObjectType).copy()
if (!placedObject) {
return
}
placedObject.uid = Math.random().toString().slice(2)
placedObject.pos = gameState.screenPosToBoardPos(touchInfo.lastDownPos)
console.log("Place Object", placedObject)
rtc.sendMessage(new DataMessage(dataMessageType.PLACE_OBJECT,
{object: placedObject.toObject()}))
}
}
async function onConstructionTouchEvent(touchInfo) {
const lieOnSameEdge = (p1, p2) => {
return (
(p1.x == 0 && p1.x == p2.x)
|| (p1.y == 0 && p1.y == p2.y)
|| (p1.x == fullscreenCanvas.width && p1.x == p2.x)
|| (p1.y == fullscreenCanvas.height && p1.y == p2.y)
)
}
if (!touchInfo.lastUpPos || !touchInfo.lastDownPos
|| touchInfo.lastDownPos.distance(touchInfo.lastUpPos) < 100
|| !lieOnSameEdge(touchInfo.lastDownPos, touchInfo.lastUpPos)) {
return
}
const constructionLine = new ConstructionLine(
touchInfo.lastDownPos, touchInfo.lastUpPos)
const phoneCoords = PhoneCoordinates.fromWidthHeight(
fullscreenCanvas.width, fullscreenCanvas.height)
rtc.sendMessage(new DataMessage(dataMessageType.CONSTRUCTION_LINE,
{line: constructionLine.toObject(), phone: phoneCoords.toObject()}))
}
async function onDataMessage(dataMessage) {
if (dataMessage.type == dataMessageType.PING) {
updateDeviceIndex(dataMessage.data.index)
const displaySize = new Vector2d(window.innerWidth, window.innerHeight)
if (window.creditCardPixelHeight) {
displaySize.iscale(400 / window.creditCardPixelHeight)
}
rtc.sendMessage(DataMessage.Ping({displaySize: displaySize.toObject()}))
} else if (dataMessage.type == dataMessageType.GAMESTATE) {
gameState = GameState.fromObject(dataMessage.data)
if (dataMessage.hostTime) {
hostTimeOffset = dataMessage.hostTime - Date.now()
}
if (touchInfo.focusedObject && touchInfo.isDown) {
gameState.board.updateObject(touchInfo.focusedObject)
}
} else if (dataMessage.type == dataMessageType.REQUEST_DIMENSIONS) {
const course = new Course([PhoneCoordinates.fromWidthHeight(window.innerWidth, window.innerHeight)])
rtc.sendMessage(new DataMessage(dataMessageType.SEND_DIMENSIONS, {course: course.toObject()}))
}
}
