const Lang = {
DE: "Deutsch",
EN: "English",
get() {
return document.documentElement.lang == "en"
? Lang.EN : Lang.DE
}
}
const Text = {
ConnectionFailed: {
[Lang.EN]: "Connection failed.",
[Lang.DE]: "Verbindung fehlgeschlagen.",
},
TryingAgainInSeconds: seconds => ({
[Lang.EN]: `⌛ Trying again in ${seconds} seconds.`,
[Lang.DE]: `⌛ Versuche nochmal in ${seconds} sekunden`
}),
TryingAgainIn10: {
[Lang.EN]: "⌛ Trying again in 10 seconds.",
[Lang.DE]: "⌛ Versuche nochmal in 10 sekunden"
},
ConnectingToHost: {
[Lang.EN]: "Connecting to Host...",
[Lang.DE]: "Verbinde zu Server..."
},
ConnectedToHost: {
[Lang.EN]: "Connected to Host.",
[Lang.DE]: "Verbindung erfolgreich."
},
ConnectionEstablished: {
[Lang.EN]: "✅ Connection established.",
[Lang.DE]: "✅ Verbindung erfolgreich.",
},
ConnectionDied: {
[Lang.EN]: "❌ Connection died",
[Lang.DE]: "❌ Verbindung abgebrochen.",
},
CouldNotConnect: {
[Lang.EN]: "❌ Could not connect to Host.",
[Lang.DE]: "❌ Verbindung fehlgeschlagen.",
},
CreatedPool: poolUid => ({
[Lang.EN]: `✅ Created Game (${poolUid})`,
[Lang.DE]: `✅ Spiel erstellt (${poolUid})`
}),
InitializingPeerToPeer: {
[Lang.EN]: "🫂 Initializing Peer-To-Peer...",
[Lang.DE]: "🫂 Verbindung wird aufgebaut...",
},
SuccessfullySentObject: objName => ({
[Lang.EN]: `✅ ${objName} successfully sent.`,
[Lang.DE]: `✅ ${objName} gesendet.`,
}),
FailedSendingObject: (name, err) => ({
[Lang.EN]: `⚠️ Couldn't upload ${name}: ${err}`,
[Lang.EN]: `⚠️ Upload von ${name} fehlgeschlagen: ${err}`,
}),
CouldntFetchServer: err => ({
[Lang.EN]: `❌ Couldn't fetch Server: ${err}`,
[Lang.DE]: `❌ Server blöd: ${err}`,
}),
GoodConnection: {
[Lang.EN]: "Good Connection",
[Lang.DE]: "Gute Verbindung"
},
ConnectionBeingInitialized: {
[Lang.EN]: "Connection is being initialized",
[Lang.DE]: "Verbindung wird hergestellt"
},
ConnectionTimedOut: {
[Lang.EN]: "Connecton timed out",
[Lang.DE]: "Verbindung abgebrochen"
},
ConnectionIsSlow: pingMs => ({
[Lang.EN]: `Connection is slow (${pingMs}ms Ping)`,
[Lang.DE]: `Verbindung ist langsam (${pingMs}ms Ping)`
}),
ConnectionInvitation: {
[Lang.EN]: "Connection Invitation",
[Lang.DE]: "Verbindungs-Einladung"
},
RTCAnswer: {
[Lang.EN]: "RTC Answer",
[Lang.DE]: "RTC Antwort"
},
ConnectionAnswer: {
[Lang.EN]: "Connection Answer",
[Lang.DE]: "Verbindungs-Antwort"
},
PleaseEnterCode: {
[Lang.EN]: "Please enter an ID.",
[Lang.DE]: "Bitte gib eine ID ein.",
},
CodeMustBeCharsLong: numChars => ({
[Lang.EN]: `ID must be ${numChars} characters long.`,
[Lang.DE]: `ID muss ${numChars} Buchstaben lang sein.`
}),
IsServerDown: {
[Lang.EN]: "Couldn't request site: Server down?",
[Lang.DE]: "Server hat nicht geantwortet: Server down?"
},
UnknownID: {
[Lang.EN]: "Unknown ID",
[Lang.DE]: "Unbekannte ID"
},
MultigolfScoreboard: {
[Lang.EN]: "Multigolf Scoreboard",
[Lang.DE]: "Multigolf Ergebnisse"
},
ShareText: {
[Lang.EN]: "Look! Scores! We played Multigolf! You should too!",
[Lang.DE]: "Guck mal! Wir haben Multigolf gespielt!"
},
LeavingWarning: {
[Lang.EN]: "You're in an active game of multigolf. Leaving this website will break the game!",
[Lang.DE]: "Du bist in einem aktiven Multigolf-Spiel. Das Verlassen der Website beendet das Spiel!"
},
NameTooLong: name => ({
[Lang.EN]: `Name "${name}..." is too long.`,
[Lang.DE]: `Der Name "${name}..." ist zu lang.`,
}),
PleaseFillOutFields: {
[Lang.EN]: "Please fill out all fields.",
[Lang.DE]: "Bitte fülle alle Felder aus."
},
FilloutOneName: {
[Lang.EN]: "Fill out at least one name to continue.",
[Lang.DE]: "Bitte fülle mindestens einen Namen aus."
},
TwoPlayersSameName: {
[Lang.EN]: "Two players cannot have the same name.",
[Lang.DE]: "Es kann sich kein Name doppeln."
},
DeviceGravity: {
[Lang.EN]: "Device Gravity",
[Lang.DE]: "Gerät-Gravitation"
},
DeviceGravityDescription: {
[Lang.EN]: "If enabled, phones that are tilted in real life will apply a gravity effect on balls.",
[Lang.DE]: "Wenn aktiviert wird die Orientierung von Handys als Gravitation einberechnet."
},
DeviceGravityWarning: {
[Lang.EN]: "Only works for phones with accelorometers.",
[Lang.DE]: "Funktioniert nur für Handys mit Zugriff auf Beschleunigungssensor"
},
BallCollisions: {
[Lang.EN]: "Ball Collisisions",
[Lang.DE]: "Ball-Kollisionen"
},
BallCollisionsDescription: {
[Lang.EN]: "If enabled, balls can kick each other. If disabled, balls will fly over each other.",
[Lang.DE]: "Wenn aktiviert können Bälle sich gegenseitig schubsen."
},
Soundeffects: {
[Lang.EN]: "Soundeffects",
[Lang.DE]: "Soundeffekte"
},
SoundeffectsDescription: {
[Lang.EN]: "If enabled, the host device will play sound effects when balls collide with something.",
[Lang.DE]: "Wenn aktiviert spielen Soundeffekte auf dem Server-Gerät wenn Bälle mit etwas kollidieren."
},
ReadNames: {
[Lang.EN]: "Read Names",
[Lang.DE]: "Namen Vorlesen"
},
ReadNamesDescription: {
[Lang.EN]: "If enabled, the host device will read the name of the player whose turn it is out loud.",
[Lang.DE]: "Wenn aktiviert wird das Server-Gerät den Namen des aktiven Spielers vorlesen."
},
MaximumKicksPerRound: {
[Lang.EN]: "Maximum Kicks per Round",
[Lang.DE]: "Maximale Schläge pro Runde"
},
MaximumKicksPerRoundDescription: {
[Lang.EN]: "Decide how many kicks each player can have per round before failing and getting a 2 point penalty.",
[Lang.DE]: "Entscheide wieviele Schläge jede Spielerin bekommt, bevor sie 2 Strafpunkte bekommt."
},
OnceYouConnectPlayers: {
[Lang.EN]: "Once you connect players, they will show up here.",
[Lang.DE]: "Sobald du Geräte verbindest, tauchen sie hier auf."
},
DeviceNum: num => ({
[Lang.EN]: `Device #${num}`,
[Lang.DE]: `Gerät #${num}`,
}),
NoDevicesError: {
[Lang.EN]: "You haven't connected any devices yet. Connect one and try again!",
[Lang.DE]: "Du hast noch keine Geräte verbunden. Verbinde mindestens eines und versuche nochmal!"
},
CourseHasOverlap: {
[Lang.EN]: "Your course has overlapping parts. Try reconnecting the phones in a different way and draw lines in the same directions on connecting phones. Do you still want to proceed?",
[Lang.DE]: "Der Kurs hat überlappende Teile. Versuche, die Geräte neu miteinander zu verbinden. Willst du trotzdem weiter (nicht empfohlen)?"
},
NoStartYet: {
[Lang.EN]: "You haven't placed a start yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Start. Platzier einen und probier nochmal."
},
NoHoleYet: {
[Lang.EN]: "You haven't placed a hole yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Loch. Platzier eins und probier nochmal."
},
HaventPlacedHoleFor: name => ({
[Lang.EN]: `You haven't placed a hole for ${name} yet.`,
[Lang.DE]: `Du hast noch kein Loch für ${name} platziert.`
}),
ObjectStart: {
[Lang.EN]: "Start",
[Lang.DE]: "Start"
},
ObjectHole: {
[Lang.EN]: "Hole",
[Lang.DE]: "Loch"
},
ObjectLava: {
[Lang.EN]: "Lava",
[Lang.DE]: "Lava"
},
ObjectCannon: {
[Lang.EN]: "Cannon",
[Lang.DE]: "Kanone"
},
ObjectEraser: {
[Lang.EN]: "Eraser",
[Lang.DE]: "Radierer"
},
ObjectDuellHole: num => ({
[Lang.EN]: `Hole ${num}`,
[Lang.DE]: `Loch ${num}`,
}),
ObjectCustomWall: {
[Lang.EN]: "Extra Wall",
[Lang.DE]: "Extra Wand"
},
ObjectGravityBox: {
[Lang.EN]: "Gravity Box",
[Lang.DE]: "Gravitations-Box"
},
ObjectStartDescription: {
[Lang.EN]: "Place where all balls start",
[Lang.DE]: "Platz wo alle Bälle starten"
},
ObjectHoleDescription: {
[Lang.EN]: "Goal that all balls must reach",
[Lang.DE]: "Ziel, welches alle Bälle erreichen müssen"
},
ObjectLavaDescription: {
[Lang.EN]: "Balls falling into Lava are reset to the start",
[Lang.DE]: "In Lava fallen = Zum Start zurück"
},
ObjectCannonDescription: {
[Lang.EN]: "Rotates and shoots balls",
[Lang.DE]: "Dreht sich und schießt Bälle weg"
},
ObjectEraserDescriptiom: {
[Lang.EN]: "Erase placed objects",
[Lang.DE]: "Radiere platzierte Objekte"
},
ObjectDuellHoleDescription: playername => ({
[Lang.EN]: `Goal that ${playername} has to reach`,
[Lang.DE]: `Ziel das ${playername} erreichen muss`
}),
ObjectCustomWallDescription: {
[Lang.EN]: "A wall that balls will bounce off",
[Lang.DE]: "Eine Wand an der Bälle abprallen"
},
ObjectGravityBoxDescription: {
[Lang.EN]: "Balls inside will experience gravity",
[Lang.DE]: "Bälle werden in die Richtung geschubst"
},
NotConstructedYet: {
[Lang.EN]: "You haven't constructed a course layout yet.",
[Lang.DE]: "Du hast noch kein Layout erstellt."
},
ThanksForFeedback: {
[Lang.EN]: "Thanks for the feedback! You're the best!",
[Lang.DE]: "Feedback erfolgreich abgeschickt! Vielen Dank!"
},
FeedbackTooLong: {
[Lang.EN]: "That's too long feedback for this box. Maybe send me an email instead?",
[Lang.DE]: "Das ist zu viel Feedback für diese Box. Vielleicht ist eine Email besser?"
},
StartChallenge: {
[Lang.EN]: "Start Challenge",
[Lang.DE]: "Challenge Starten"
},
WantToTryAgain: {
[Lang.EN]: "You lost the Challenge. Do you want to try again?",
[Lang.DE]: "Du hast die Challenge verloren. Willst du es nochmal probieren?"
},
YouLost: {
[Lang.EN]: "You Lost!",
[Lang.DE]: "Verloren!"
},
YouWonLong: kicksLeft => ({
[Lang.EN]: `Hoooorayyy! You won the Challenge! Congratulations! You even have ${kicksLeft} kicks left!`,
[Lang.DE]: `Huuurraaaa! Du hast die Challenge bezwungen! Herzlichen Glückwunsch! Du hast sogar ${kicksLeft} Schläge übrig!`
}),
YouWon: {
[Lang.EN]: "You Won!",
[Lang.DE]: "Gewonnen!"
},
YourPackHighscore: (packName, score) => ({
[Lang.EN]: `At your best attempt at ${packName}, you had ${score} kicks left.`,
[Lang.DE]: `Beim besten Versuch bei diesem Pack hattest du ${score} Schläge übrig.`
})
}
function getLangText(textObject) {
return textObject[Lang.get()]
}
for (const [key, val] of Object.entries(Text)) {
if (typeof val === "function") {
Text[key] = function () {
return getLangText(val(...arguments))
}
} else {
Object.defineProperty(Text, key, {
get: () => getLangText(val)
})
}
}
Object.freeze(Text)
/**
* @fileoverview
* - Using the 'QRCode for Javascript library'
* - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
* - this library has no dependencies.
*
* @author davidshimjs
* @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
* @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
*/
var QRCode;
(function () {
function QR8bitByte(data) {
this.mode = QRMode.MODE_8BIT_BYTE;
this.data = data;
this.parsedData = [];
for (var i = 0, l = this.data.length; i < l; i++) {
var byteArray = [];
var code = this.data.charCodeAt(i);
if (code > 0x10000) {
byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
byteArray[3] = 0x80 | (code & 0x3F);
} else if (code > 0x800) {
byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
byteArray[2] = 0x80 | (code & 0x3F);
} else if (code > 0x80) {
byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
byteArray[1] = 0x80 | (code & 0x3F);
} else {
byteArray[0] = code;
}
this.parsedData.push(byteArray);
}
this.parsedData = Array.prototype.concat.apply([], this.parsedData);
if (this.parsedData.length != this.data.length) {
this.parsedData.unshift(191);
this.parsedData.unshift(187);
this.parsedData.unshift(239);
}
}
QR8bitByte.prototype = {
getLength: function (buffer) {
return this.parsedData.length;
},
write: function (buffer) {
for (var i = 0, l = this.parsedData.length; i < l; i++) {
buffer.put(this.parsedData[i], 8);
}
}
};
function QRCodeModel(typeNumber, errorCorrectLevel) {
this.typeNumber = typeNumber;
this.errorCorrectLevel = errorCorrectLevel;
this.modules = null;
this.moduleCount = 0;
this.dataCache = null;
this.dataList = [];
}
QRCodeModel.prototype={addData:function(data){var newData=new QR8bitByte(data);this.dataList.push(newData);this.dataCache=null;},isDark:function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col){throw new Error(row+","+col);}
return this.modules[row][col];},getModuleCount:function(){return this.moduleCount;},make:function(){this.makeImpl(false,this.getBestMaskPattern());},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null;}}
this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupPositionAdjustPattern();this.setupTimingPattern();this.setupTypeInfo(test,maskPattern);if(this.typeNumber>=7){this.setupTypeNumber(test);}
if(this.dataCache==null){this.dataCache=QRCodeModel.createData(this.typeNumber,this.errorCorrectLevel,this.dataList);}
this.mapData(this.dataCache,maskPattern);},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;if((0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}},getBestMaskPattern:function(){var minLostPoint=0;var pattern=0;for(var i=0;i<8;i++){this.makeImpl(true,i);var lostPoint=QRUtil.getLostPoint(this);if(i==0||minLostPoint>lostPoint){minLostPoint=lostPoint;pattern=i;}}
return pattern;},createMovieClip:function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth);var cs=1;this.make();for(var row=0;row<this.modules.length;row++){var y=row*cs;for(var col=0;col<this.modules[row].length;col++){var x=col*cs;var dark=this.modules[row][col];if(dark){qr_mc.beginFill(0,100);qr_mc.moveTo(x,y);qr_mc.lineTo(x+cs,y);qr_mc.lineTo(x+cs,y+cs);qr_mc.lineTo(x,y+cs);qr_mc.endFill();}}}
return qr_mc;},setupTimingPattern:function(){for(var r=8;r<this.moduleCount-8;r++){if(this.modules[r][6]!=null){continue;}
this.modules[r][6]=(r%2==0);}
for(var c=8;c<this.moduleCount-8;c++){if(this.modules[6][c]!=null){continue;}
this.modules[6][c]=(c%2==0);}},setupPositionAdjustPattern:function(){var pos=QRUtil.getPatternPosition(this.typeNumber);for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i];var col=pos[j];if(this.modules[row][col]!=null){continue;}
for(var r=-2;r<=2;r++){for(var c=-2;c<=2;c++){if(r==-2||r==2||c==-2||c==2||(r==0&&c==0)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}}}},setupTypeNumber:function(test){var bits=QRUtil.getBCHTypeNumber(this.typeNumber);for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod;}
for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod;}},setupTypeInfo:function(test,maskPattern){var data=(this.errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<6){this.modules[i][8]=mod;}else if(i<8){this.modules[i+1][8]=mod;}else{this.modules[this.moduleCount-15+i][8]=mod;}}
for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<8){this.modules[8][this.moduleCount-i-1]=mod;}else if(i<9){this.modules[8][15-i-1+1]=mod;}else{this.modules[8][15-i-1]=mod;}}
this.modules[this.moduleCount-8][8]=(!test);},mapData:function(data,maskPattern){var inc=-1;var row=this.moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=(((data[byteIndex]>>>bitIndex)&1)==1);}
var mask=QRUtil.getMask(maskPattern,row,col-c);if(mask){dark=!dark;}
this.modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break;}}}}};QRCodeModel.PAD0=0xEC;QRCodeModel.PAD1=0x11;QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){var rsBlocks=QRRSBlock.getRSBlocks(typeNumber,errorCorrectLevel);var buffer=new QRBitBuffer();for(var i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4);buffer.put(data.getLength(),QRUtil.getLengthInBits(data.mode,typeNumber));data.write(buffer);}
var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++){totalDataCount+=rsBlocks[i].dataCount;}
if(buffer.getLengthInBits()>totalDataCount*8){throw new Error("code length overflow. ("
+buffer.getLengthInBits()
+">"
+totalDataCount*8
+")");}
if(buffer.getLengthInBits()+4<=totalDataCount*8){buffer.put(0,4);}
while(buffer.getLengthInBits()%8!=0){buffer.putBit(false);}
while(true){if(buffer.getLengthInBits()>=totalDataCount*8){break;}
buffer.put(QRCodeModel.PAD0,8);if(buffer.getLengthInBits()>=totalDataCount*8){break;}
buffer.put(QRCodeModel.PAD1,8);}
return QRCodeModel.createBytes(buffer,rsBlocks);};QRCodeModel.createBytes=function(buffer,rsBlocks){var offset=0;var maxDcCount=0;var maxEcCount=0;var dcdata=new Array(rsBlocks.length);var ecdata=new Array(rsBlocks.length);for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount);maxEcCount=Math.max(maxEcCount,ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=0xff&buffer.buffer[i+offset];}
offset+=dcCount;var rsPoly=QRUtil.getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],rsPoly.getLength()-1);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(var i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0;}}
var totalCodeCount=0;for(var i=0;i<rsBlocks.length;i++){totalCodeCount+=rsBlocks[i].totalCount;}
var data=new Array(totalCodeCount);var index=0;for(var i=0;i<maxDcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<dcdata[r].length){data[index++]=dcdata[r][i];}}}
for(var i=0;i<maxEcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<ecdata[r].length){data[index++]=ecdata[r][i];}}}
return data;};var QRMode={MODE_NUMBER:1<<0,MODE_ALPHA_NUM:1<<1,MODE_8BIT_BYTE:1<<2,MODE_KANJI:1<<3};var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};var QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),G18:(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),G15_MASK:(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}
return((data<<10)|d)^QRUtil.G15_MASK;},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));}
return(data<<12)|d;},getBCHDigit:function(data){var digit=0;while(data!=0){digit++;data>>>=1;}
return digit;},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return(i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return(i+j)%3==0;case QRMaskPattern.PATTERN100:return(Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return(i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return((i*j)%2+(i*j)%3)%2==0;case QRMaskPattern.PATTERN111:return((i*j)%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern);}},getErrorCorrectPolynomial:function(errorCorrectLength){var a=new QRPolynomial([1],0);for(var i=0;i<errorCorrectLength;i++){a=a.multiply(new QRPolynomial([1,QRMath.gexp(i)],0));}
return a;},getLengthInBits:function(mode,type){if(1<=type&&type<10){switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode);}}else if(type<27){switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode);}}else if(type<41){switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode);}}else{throw new Error("type:"+type);}},getLostPoint:function(qrCode){var moduleCount=qrCode.getModuleCount();var lostPoint=0;for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount;col++){var sameCount=0;var dark=qrCode.isDark(row,col);for(var r=-1;r<=1;r++){if(row+r<0||moduleCount<=row+r){continue;}
for(var c=-1;c<=1;c++){if(col+c<0||moduleCount<=col+c){continue;}
if(r==0&&c==0){continue;}
if(dark==qrCode.isDark(row+r,col+c)){sameCount++;}}}
if(sameCount>5){lostPoint+=(3+sameCount-5);}}}
for(var row=0;row<moduleCount-1;row++){for(var col=0;col<moduleCount-1;col++){var count=0;if(qrCode.isDark(row,col))count++;if(qrCode.isDark(row+1,col))count++;if(qrCode.isDark(row,col+1))count++;if(qrCode.isDark(row+1,col+1))count++;if(count==0||count==4){lostPoint+=3;}}}
for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount-6;col++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)){lostPoint+=40;}}}
for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount-6;row++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)){lostPoint+=40;}}}
var darkCount=0;for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount;row++){if(qrCode.isDark(row,col)){darkCount++;}}}
var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;lostPoint+=ratio*10;return lostPoint;}};var QRMath={glog:function(n){if(n<1){throw new Error("glog("+n+")");}
return QRMath.LOG_TABLE[n];},gexp:function(n){while(n<0){n+=255;}
while(n>=256){n-=255;}
return QRMath.EXP_TABLE[n];},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var i=0;i<8;i++){QRMath.EXP_TABLE[i]=1<<i;}
for(var i=8;i<256;i++){QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];}
for(var i=0;i<255;i++){QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;}
function QRPolynomial(num,shift){if(num.length==undefined){throw new Error(num.length+"/"+shift);}
var offset=0;while(offset<num.length&&num[offset]==0){offset++;}
this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++){this.num[i]=num[i+offset];}}
QRPolynomial.prototype={get:function(index){return this.num[index];},getLength:function(){return this.num.length;},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
return new QRPolynomial(num,0);},mod:function(e){if(this.getLength()-e.getLength()<0){return this;}
var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}
for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
return new QRPolynomial(num,0).mod(e);}};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(rsBlock==undefined){throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);}
var length=rsBlock.length/3;var list=[];for(var i=0;i<length;i++){var count=rsBlock[i*3+0];var totalCount=rsBlock[i*3+1];var dataCount=rsBlock[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(totalCount,dataCount));}}
return list;};QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+3];default:return undefined;}};function QRBitBuffer(){this.buffer=[];this.length=0;}
QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return((this.buffer[bufIndex]>>>(7-index%8))&1)==1;},put:function(num,length){for(var i=0;i<length;i++){this.putBit(((num>>>(length-i-1))&1)==1);}},getLengthInBits:function(){return this.length;},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex){this.buffer.push(0);}
if(bit){this.buffer[bufIndex]|=(0x80>>>(this.length%8));}
this.length++;}};var QRCodeLimitLength=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]];
function _isSupportCanvas() {
return typeof CanvasRenderingContext2D != "undefined";
}
function _getAndroid() {
var android = false;
var sAgent = navigator.userAgent;
if (/android/i.test(sAgent)) { // android
android = true;
var aMat = sAgent.toString().match(/android ([0-9]\.[0-9])/i);
if (aMat && aMat[1]) {
android = parseFloat(aMat[1]);
}
}
return android;
}
var svgDrawer = (function() {
var Drawing = function (el, htOption) {
this._el = el;
this._htOption = htOption;
};
Drawing.prototype.draw = function (oQRCode) {
var _htOption = this._htOption;
var _el = this._el;
var nCount = oQRCode.getModuleCount();
var nWidth = Math.floor(_htOption.width / nCount);
var nHeight = Math.floor(_htOption.height / nCount);
this.clear();
function makeSVG(tag, attrs) {
var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
for (var k in attrs)
if (attrs.hasOwnProperty(k)) el.setAttribute(k, attrs[k]);
return el;
}
var svg = makeSVG("svg" , {'viewBox': '0 0 ' + String(nCount) + " " + String(nCount), 'width': '100%', 'height': '100%', 'fill': _htOption.colorLight});
svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
_el.appendChild(svg);
svg.appendChild(makeSVG("rect", {"fill": _htOption.colorLight, "width": "100%", "height": "100%"}));
svg.appendChild(makeSVG("rect", {"fill": _htOption.colorDark, "width": "1", "height": "1", "id": "template"}));
for (var row = 0; row < nCount; row++) {
for (var col = 0; col < nCount; col++) {
if (oQRCode.isDark(row, col)) {
var child = makeSVG("use", {"x": String(col), "y": String(row)});
child.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template")
svg.appendChild(child);
}
}
}
};
Drawing.prototype.clear = function () {
while (this._el.hasChildNodes())
this._el.removeChild(this._el.lastChild);
};
return Drawing;
})();
var useSVG = document.documentElement.tagName.toLowerCase() === "svg";
var Drawing = useSVG ? svgDrawer : !_isSupportCanvas() ? (function () {
var Drawing = function (el, htOption) {
this._el = el;
this._htOption = htOption;
};
/**
* Draw the QRCode
*
* @param {QRCode} oQRCode
*/
Drawing.prototype.draw = function (oQRCode) {
var _htOption = this._htOption;
var _el = this._el;
var nCount = oQRCode.getModuleCount();
var nWidth = Math.floor(_htOption.width / nCount);
var nHeight = Math.floor(_htOption.height / nCount);
var aHTML = ['<table style="border:0;border-collapse:collapse;">'];
for (var row = 0; row < nCount; row++) {
aHTML.push('<tr>');
for (var col = 0; col < nCount; col++) {
aHTML.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + nWidth + 'px;height:' + nHeight + 'px;background-color:' + (oQRCode.isDark(row, col) ? _htOption.colorDark : _htOption.colorLight) + ';"></td>');
}
aHTML.push('</tr>');
}
aHTML.push('</table>');
_el.innerHTML = aHTML.join('');
var elTable = _el.childNodes[0];
var nLeftMarginTable = (_htOption.width - elTable.offsetWidth) / 2;
var nTopMarginTable = (_htOption.height - elTable.offsetHeight) / 2;
if (nLeftMarginTable > 0 && nTopMarginTable > 0) {
elTable.style.margin = nTopMarginTable + "px " + nLeftMarginTable + "px";
}
};
/**
* Clear the QRCode
*/
Drawing.prototype.clear = function () {
this._el.innerHTML = '';
};
return Drawing;
})() : (function () { // Drawing in Canvas
function _onMakeImage() {
this._elImage.src = this._elCanvas.toDataURL("image/png");
this._elImage.style.display = "block";
this._elCanvas.style.display = "none";
}
if (this._android && this._android <= 2.1) {
var factor = 1 / window.devicePixelRatio;
var drawImage = CanvasRenderingContext2D.prototype.drawImage;
CanvasRenderingContext2D.prototype.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
if (("nodeName" in image) && /img/i.test(image.nodeName)) {
for (var i = arguments.length - 1; i >= 1; i--) {
arguments[i] = arguments[i] * factor;
}
} else if (typeof dw == "undefined") {
arguments[1] *= factor;
arguments[2] *= factor;
arguments[3] *= factor;
arguments[4] *= factor;
}
drawImage.apply(this, arguments);
};
}
/**
* Check whether the user's browser supports Data URI or not
*
* @private
* @param {Function} fSuccess Occurs if it supports Data URI
* @param {Function} fFail Occurs if it doesn't support Data URI
*/
function _safeSetDataURI(fSuccess, fFail) {
var self = this;
self._fFail = fFail;
self._fSuccess = fSuccess;
if (self._bSupportDataURI === null) {
var el = document.createElement("img");
var fOnError = function() {
self._bSupportDataURI = false;
if (self._fFail) {
self._fFail.call(self);
}
};
var fOnSuccess = function() {
self._bSupportDataURI = true;
if (self._fSuccess) {
self._fSuccess.call(self);
}
};
el.onabort = fOnError;
el.onerror = fOnError;
el.onload = fOnSuccess;
el.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="; // the Image contains 1px data.
return;
} else if (self._bSupportDataURI === true && self._fSuccess) {
self._fSuccess.call(self);
} else if (self._bSupportDataURI === false && self._fFail) {
self._fFail.call(self);
}
};
/**
* Drawing QRCode by using canvas
*
* @constructor
* @param {HTMLElement} el
* @param {Object} htOption QRCode Options
*/
var Drawing = function (el, htOption) {
this._bIsPainted = false;
this._android = _getAndroid();
this._htOption = htOption;
this._elCanvas = document.createElement("canvas");
this._elCanvas.width = htOption.width;
this._elCanvas.height = htOption.height;
el.appendChild(this._elCanvas);
this._el = el;
this._oContext = this._elCanvas.getContext("2d");
this._bIsPainted = false;
this._elImage = document.createElement("img");
this._elImage.alt = "Scan me!";
this._elImage.style.display = "none";
this._el.appendChild(this._elImage);
this._bSupportDataURI = null;
};
/**
* Draw the QRCode
*
* @param {QRCode} oQRCode
*/
Drawing.prototype.draw = function (oQRCode) {
var _elImage = this._elImage;
var _oContext = this._oContext;
var _htOption = this._htOption;
var nCount = oQRCode.getModuleCount();
var nWidth = _htOption.width / nCount;
var nHeight = _htOption.height / nCount;
var nRoundedWidth = Math.round(nWidth);
var nRoundedHeight = Math.round(nHeight);
_elImage.style.display = "none";
this.clear();
for (var row = 0; row < nCount; row++) {
for (var col = 0; col < nCount; col++) {
var bIsDark = oQRCode.isDark(row, col);
var nLeft = col * nWidth;
var nTop = row * nHeight;
_oContext.strokeStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;
_oContext.lineWidth = 1;
_oContext.fillStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;
_oContext.fillRect(nLeft, nTop, nWidth, nHeight);
_oContext.strokeRect(
Math.floor(nLeft) + 0.5,
Math.floor(nTop) + 0.5,
nRoundedWidth,
nRoundedHeight
);
_oContext.strokeRect(
Math.ceil(nLeft) - 0.5,
Math.ceil(nTop) - 0.5,
nRoundedWidth,
nRoundedHeight
);
}
}
this._bIsPainted = true;
};
/**
* Make the image from Canvas if the browser supports Data URI.
*/
Drawing.prototype.makeImage = function () {
if (this._bIsPainted) {
_safeSetDataURI.call(this, _onMakeImage);
}
};
/**
* Return whether the QRCode is painted or not
*
* @return {Boolean}
*/
Drawing.prototype.isPainted = function () {
return this._bIsPainted;
};
/**
* Clear the QRCode
*/
Drawing.prototype.clear = function () {
this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height);
this._bIsPainted = false;
};
/**
* @private
* @param {Number} nNumber
*/
Drawing.prototype.round = function (nNumber) {
if (!nNumber) {
return nNumber;
}
return Math.floor(nNumber * 1000) / 1000;
};
return Drawing;
})();
/**
* Get the type by string length
*
* @private
* @param {String} sText
* @param {Number} nCorrectLevel
* @return {Number} type
*/
function _getTypeNumber(sText, nCorrectLevel) {
var nType = 1;
var length = _getUTF8Length(sText);
for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
var nLimit = 0;
switch (nCorrectLevel) {
case QRErrorCorrectLevel.L :
nLimit = QRCodeLimitLength[i][0];
break;
case QRErrorCorrectLevel.M :
nLimit = QRCodeLimitLength[i][1];
break;
case QRErrorCorrectLevel.Q :
nLimit = QRCodeLimitLength[i][2];
break;
case QRErrorCorrectLevel.H :
nLimit = QRCodeLimitLength[i][3];
break;
}
if (length <= nLimit) {
break;
} else {
nType++;
}
}
if (nType > QRCodeLimitLength.length) {
throw new Error("Too long data");
}
return nType;
}
function _getUTF8Length(sText) {
var replacedText = encodeURI(sText).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
return replacedText.length + (replacedText.length != sText ? 3 : 0);
}
/**
* @class QRCode
* @constructor
* @example
* new QRCode(document.getElementById("test"), "http://jindo.dev.naver.com/collie");
*
* @example
* var oQRCode = new QRCode("test", {
*    text : "http://naver.com",
*    width : 128,
*    height : 128
* });
*
* oQRCode.clear(); // Clear the QRCode.
* oQRCode.makeCode("http://map.naver.com"); // Re-create the QRCode.
*
* @param {HTMLElement|String} el target element or 'id' attribute of element.
* @param {Object|String} vOption
* @param {String} vOption.text QRCode link data
* @param {Number} [vOption.width=256]
* @param {Number} [vOption.height=256]
* @param {String} [vOption.colorDark="#000000"]
* @param {String} [vOption.colorLight="#ffffff"]
* @param {QRCode.CorrectLevel} [vOption.correctLevel=QRCode.CorrectLevel.H] [L|M|Q|H]
*/
QRCode = function (el, vOption) {
this._htOption = {
width : 256,
height : 256,
typeNumber : 4,
colorDark : "#000000",
colorLight : "#ffffff",
correctLevel : QRErrorCorrectLevel.H
};
if (typeof vOption === 'string') {
vOption	= {
text : vOption
};
}
if (vOption) {
for (var i in vOption) {
this._htOption[i] = vOption[i];
}
}
if (typeof el == "string") {
el = document.getElementById(el);
}
if (this._htOption.useSVG) {
Drawing = svgDrawer;
}
this._android = _getAndroid();
this._el = el;
this._oQRCode = null;
this._oDrawing = new Drawing(this._el, this._htOption);
if (this._htOption.text) {
this.makeCode(this._htOption.text);
}
};
/**
* Make the QRCode
*
* @param {String} sText link data
*/
QRCode.prototype.makeCode = function (sText) {
this._oQRCode = new QRCodeModel(_getTypeNumber(sText, this._htOption.correctLevel), this._htOption.correctLevel);
this._oQRCode.addData(sText);
this._oQRCode.make();
this._el.title = sText;
this._oDrawing.draw(this._oQRCode);
this.makeImage();
};
/**
* Make the Image from Canvas element
* - It occurs automatically
* - Android below 3 doesn't support Data-URI spec.
*
* @private
*/
QRCode.prototype.makeImage = function () {
if (typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3)) {
this._oDrawing.makeImage();
}
};
/**
* Clear the QRCode
*/
QRCode.prototype.clear = function () {
this._oDrawing.clear();
};
/**
* @name QRCode.CorrectLevel
*/
QRCode.CorrectLevel = QRErrorCorrectLevel;
})();
const Sprite = {
BallBlue:      "../assets/compressed/objects/balls/blue.png",
BallCyan:      "../assets/compressed/objects/balls/cyan.png",
BallLightblue: "../assets/compressed/objects/balls/light_blue.png",
BallOrange:    "../assets/compressed/objects/balls/orange.png",
BallPink:      "../assets/compressed/objects/balls/pink.png",
BallRed:       "../assets/compressed/objects/balls/red.png",
BallViolet:    "../assets/compressed/objects/balls/violet.png",
BallWhite:     "../assets/compressed/objects/balls/white.png",
BallYellow:    "../assets/compressed/objects/balls/yellow.png",
Grid:          "../assets/compressed/objects/grid.png",
Hole:          "../assets/compressed/objects/hole.png",
Start:         "../assets/compressed/objects/start.png",
DuellHole1:    "../assets/compressed/objects/duellHole1.png",
DuellHole2:    "../assets/compressed/objects/duellHole2.png",
Lava:          "../assets/compressed/objects/lava.png",
Cannon:        "../assets/compressed/objects/cannon.png",
GravityBox:    "../assets/compressed/objects/gravity-box.png",
Eraser:        "../assets/objects/eraser.svg",
ZoomIcon:      "../assets/zoom-icon.svg",
CustomWall:    "../assets/objects/wall.svg",
}
const AudioSprite = {
Plop: "../assets/audio/plop.mp3",
WinSound: "../assets/audio/win_sound.mp3",
Lava: "../assets/audio/lava.mp3",
Bonk: "../assets/audio/bonk.mp3",
Shot: "../assets/audio/shot.mp3",
Cannon: "../assets/audio/cannon.mp3",
Note1: "../assets/audio/notes/1.mp3",
Note2: "../assets/audio/notes/2.mp3",
Note3: "../assets/audio/notes/3.mp3",
Note4: "../assets/audio/notes/4.mp3",
Note5: "../assets/audio/notes/5.mp3",
Note6: "../assets/audio/notes/6.mp3",
Note7: "../assets/audio/notes/7.mp3",
Note8: "../assets/audio/notes/8.mp3",
Note9: "../assets/audio/notes/9.mp3",
}
const allNoteSprites = [
AudioSprite.Note1,
AudioSprite.Note2,
AudioSprite.Note3,
AudioSprite.Note4,
AudioSprite.Note5,
AudioSprite.Note6,
AudioSprite.Note7,
AudioSprite.Note8,
AudioSprite.Note9
]
const AllBallSprites = [
Sprite.BallBlue,
Sprite.BallRed,
Sprite.BallYellow,
Sprite.BallPink,
Sprite.BallOrange,
Sprite.BallCyan,
Sprite.BallViolet,
Sprite.BallLightblue,
Sprite.BallWhite,
]
function setSpritePath(prePath) {
const spriteObjects = [Sprite, AudioSprite]
const spriteLists = [allNoteSprites, AllBallSprites]
for (const obj of spriteObjects) {
for (const [key, value] of Object.entries(obj)) {
obj[key] = prePath + value
}
}
for (const lst of spriteLists) {
for (let i = 0; i < lst.length; i++) {
lst[i] = prePath + lst[i]
}
}
try {
golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
} catch (e) {
console.log("Couldn't update golfObjectTypeSpriteMap")
if (!(e instanceof ReferenceError)) {
throw e
}
}
}
/*
The MIT License (MIT)
Copyright (c) Rich Tibbett
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const noSleep_webm = "data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK"
const noSleep_mp4 = "data:video/mp4;base64,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"
const oldIOS = () =>
typeof navigator !== "undefined" &&
parseFloat(
(
"" +
(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(
navigator.userAgent
) || [0, ""])[1]
)
.replace("undefined", "3_2")
.replace("_", ".")
.replace("_", "")
) < 10 &&
!window.MSStream;
const nativeWakeLock = () => "wakeLock" in navigator;
class NoSleep {
constructor() {
this.enabled = false;
if (nativeWakeLock()) {
this._wakeLock = null;
const handleVisibilityChange = () => {
if (this._wakeLock !== null && document.visibilityState === "visible") {
this.enable();
}
};
document.addEventListener("visibilitychange", handleVisibilityChange);
document.addEventListener("fullscreenchange", handleVisibilityChange);
} else if (oldIOS()) {
this.noSleepTimer = null;
} else {
this.noSleepVideo = document.createElement("video");
this.noSleepVideo.setAttribute("title", "No Sleep");
this.noSleepVideo.setAttribute("playsinline", "");
this._addSourceToVideo(this.noSleepVideo, "webm", noSleep_webm);
this._addSourceToVideo(this.noSleepVideo, "mp4", noSleep_mp4);
this.noSleepVideo.addEventListener("loadedmetadata", () => {
if (this.noSleepVideo.duration <= 1) {
this.noSleepVideo.setAttribute("loop", "");
} else {
this.noSleepVideo.addEventListener("timeupdate", () => {
if (this.noSleepVideo.currentTime > 0.5) {
this.noSleepVideo.currentTime = Math.random();
}
});
}
});
}
}
_addSourceToVideo(element, type, dataURI) {
var source = document.createElement("source");
source.src = dataURI;
source.type = `video/${type}`;
element.appendChild(source);
}
get isEnabled() {
return this.enabled;
}
enable() {
if (nativeWakeLock()) {
return navigator.wakeLock
.request("screen")
.then((wakeLock) => {
this._wakeLock = wakeLock;
this.enabled = true;
console.log("Wake Lock active.");
this._wakeLock.addEventListener("release", () => {
console.log("Wake Lock released.");
});
})
.catch((err) => {
this.enabled = false;
console.error(`${err.name}, ${err.message}`);
throw err;
});
} else if (oldIOS()) {
this.disable();
console.warn(`
NoSleep enabled for older iOS devices. This can interrupt
active or long-running network requests from completing successfully.
See https://github.com/richtr/NoSleep.js/issues/15 for more details.
`);
this.noSleepTimer = window.setInterval(() => {
if (!document.hidden) {
window.location.href = window.location.href.split("#")[0];
window.setTimeout(window.stop, 0);
}
}, 15000);
this.enabled = true;
return Promise.resolve();
} else {
let playPromise = this.noSleepVideo.play();
return playPromise
.then((res) => {
this.enabled = true;
return res;
})
.catch((err) => {
this.enabled = false;
throw err;
});
}
}
disable() {
if (nativeWakeLock()) {
if (this._wakeLock) {
this._wakeLock.release();
}
this._wakeLock = null;
} else if (oldIOS()) {
if (this.noSleepTimer) {
console.warn(`
NoSleep now disabled for older iOS devices.
`);
window.clearInterval(this.noSleepTimer);
this.noSleepTimer = null;
}
} else {
this.noSleepVideo.pause();
}
this.enabled = false;
}
}
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
static fromObject(obj) {
if (obj == null) return null
if (obj.x == undefined || obj.y == undefined) {
throw new Error(`Vector object must have x and y properties`)
}
return new Vector2d(obj.x, obj.y)
}
toObject() {
return {
x: this.x,
y: this.y
}
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get squaredLength() {
return this.x * this.x + this.y * this.y
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
scaleX(x) {
return new Vector2d(this.x * x, this.y)
}
scaleY(y) {
return new Vector2d(this.x, this.y * y)
}
iscaleX(x) {
this.x *= x
}
iscaleY(y) {
this.y *= y
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
distanceSquared(v) {
return this.sub(v).squaredLength
}
cross(v) {
return this.x * v.y - this.y * v.x
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
this.x = x
this.y = y
}
setVector2d(v) {
this.x = v.x
this.y = v.y
}
interpolate(v, t) {
return this.add(v.sub(this).scale(t))
}
iinterpolate(v, t) {
this.iadd(v.sub(this).scale(t))
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
toArray() {
return [this.x, this.y]
}
normalizeToCanvas(canvas) {
return new Vector2d(
this.x / canvas.width,
this.y / canvas.height
)
}
static fromTouchEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX && event.clientY) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
static fromEvent(event, element) {
return Vector2d.fromTouchEvent(event, element)
}
clampX(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.x - clampValue) <= maxDelta) {
newVector.x = clampValue
}
}
return newVector
}
clampY(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.y - clampValue) <= maxDelta) {
newVector.y = clampValue
}
}
return newVector
}
min() {
return Math.min(this.x, this.y)
}
max() {
return Math.max(this.x, this.y)
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
iround() {
this.x = Math.round(this.x)
this.y = Math.round(this.y)
}
toString() {
return `${this.x}, ${this.y}`
}
static fromString(str) {
const parts = str.split(",")
if (parts.length != 2) {
throw new Error("String must be made up of two numbers seperated by comma")
}
const x = parseFloat(parts[0])
const y = parseFloat(parts[1])
if (isNaN(x) || isNaN(y)) {
throw new Error("String contains invalid number(s)")
}
return new Vector2d(x, y)
}
}
function calcLineIntersection(s1, e1, s2, e2) {
const denominator = (e2.y - s2.y)*(e1.x - s1.x) - (e2.x - s2.x)*(e1.y - s1.y)
if (denominator == 0) {
return null
}
const ua = ((e2.x - s2.x) * (s1.y - s2.y) - (e2.y - s2.y) * (s1.x - s2.x)) / denominator
const ub = ((e1.x - s1.x) * (s1.y - s2.y) - (e1.y - s1.y) * (s1.x - s2.x)) / denominator
if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null
return new Vector2d(
s1.x + ua * (e1.x - s1.x),
s1.y + ua * (e1.y - s1.y),
)
}
function calcAveragePos(vecs) {
return vecs.reduce((p,c) => p.add(c), new Vector2d(0,0)).scale(1 / vecs.length)
}
class ConstructionLine {
constructor(startPos, endPos) {
this.startPos = startPos
this.endPos = endPos
}
get start() {
return this.startPos
}
get end() {
return this.endPos
}
static fromObject(obj) {
return new ConstructionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end)
)
}
toObject() {
return {
start: this.startPos.toObject(),
end: this.endPos.toObject()
}
}
}
class PhoneCoordinates {
constructor(topLeft, topRight, bottomLeft, bottomRight, angle, scalar, gravity) {
this.topLeft = topLeft
this.topRight = topRight
this.bottomLeft = bottomLeft
this.bottomRight = bottomRight
this.angle = angle ?? 0
this.scalar = scalar ?? 1
this.gravity = gravity ?? new Vector2d(0, 0)
}
static fromWidthHeight(width, height) {
return new PhoneCoordinates(
new Vector2d(0, 0),
new Vector2d(width, 0),
new Vector2d(0, height),
new Vector2d(width, height),
0, 1,
new Vector2d(0, 0)
)
}
toObject() {
return {
coords: [
this.topLeft.toObject(),
this.topRight.toObject(),
this.bottomLeft.toObject(),
this.bottomRight.toObject(),
],
angle: this.angle,
scalar: this.scalar,
gravity: this.gravity.toObject()
}
}
static fromObject(obj) {
return new PhoneCoordinates(
...obj.coords.map(coord => Vector2d.fromObject(coord)),
obj.angle,
obj.scalar,
Vector2d.fromObject(obj.gravity)
)
}
get points() {
return [this.topLeft, this.topRight, this.bottomRight, this.bottomLeft]
}
get midPos() {
return this.topLeft.add(this.bottomRight).scale(0.5)
}
randomPosInside() {
const x = Math.random()
const y = Math.random()
return this.topLeft.add(this.topRight.sub(this.topLeft).scale(x))
.add(this.bottomLeft.sub(this.topLeft).scale(y))
}
scale(scalar) {
this.scalar *= scalar
for (let vec of this.points) {
vec.iscale(scalar)
}
}
rotate(angle) {
this.angle += angle
for (let vec of this.points) {
vec.irotate(angle)
}
}
translate(point) {
for (let vec of this.points) {
vec.iadd(point)
}
}
copy() {
return PhoneCoordinates.fromObject(this.toObject())
}
get width() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.topRight.rotate(-this.angle)
return rotated2.x - rotated1.x
}
get height() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.bottomLeft.rotate(-this.angle)
return rotated2.y - rotated1.y
}
get area() {
return this.size.x * this.size.y
}
creditCardScalingFactor(screenSize) {
return this.height / screenSize.y
}
screenPosToBoardPos(screenPos, screenSize) {
const scaledScreenPos = screenPos.copy()
scaledScreenPos.iscaleX(this.width / screenSize.x)
scaledScreenPos.iscaleY(this.height / screenSize.y)
const pos = scaledScreenPos.rotate(this.angle)
return this.topLeft.add(pos.scale(this.scalar))
}
boardPosToScreenPos(boardPos, screenSize) {
const relativePos = boardPos.sub(this.topLeft).scale(1 / this.scalar)
const rawScreenPos = relativePos.rotate(-this.angle)
rawScreenPos.iscaleX(screenSize.x / this.width)
rawScreenPos.iscaleY(screenSize.y / this.height)
return rawScreenPos
}
containsPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY
}
distanceToPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
const dx = Math.max(minX - pos.x, 0, pos.x - maxX)
const dy = Math.max(minY - pos.y, 0, pos.y - maxY)
return Math.sqrt(dx * dx + dy * dy)
}
get walls() {
return [
[this.points[0], this.points[1]],
[this.points[1], this.points[2]],
[this.points[2], this.points[3]],
[this.points[3], this.points[0]],
]
}
get corners() {
return this.points
}
get minXY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get maxXY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get minXmaxY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get maxXminY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get size() {
return this.maxXY.sub(this.minXY)
}
hasOverlap(other) {
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (intersection) return true
}
}
return false
}
getOverlap(other) {
const wallIntersections = []
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (!intersection) continue
wallIntersections.push(intersection)
}
}
const uniqueIntersections = []
const epsilon = 0.1
const insidePoints = this.points.filter(p => other.distanceToPos(p) < epsilon)
.concat(other.points.filter(p => this.distanceToPos(p) < epsilon))
for (const point of wallIntersections.concat(insidePoints)) {
let foundSimilar = false
for (const other of uniqueIntersections) {
if (point.distance(other) < epsilon) {
foundSimilar = true
break
}
}
if (!foundSimilar) {
uniqueIntersections.push(point)
}
}
if (uniqueIntersections.length == 4) {
const minXY = new Vector2d(
Math.min(...uniqueIntersections.map(p => p.x)),
Math.min(...uniqueIntersections.map(p => p.y)),
)
const maxXY = new Vector2d(
Math.max(...uniqueIntersections.map(p => p.x)),
Math.max(...uniqueIntersections.map(p => p.y)),
)
const size = maxXY.sub(minXY)
return new PhoneCoordinates(
minXY, minXY.addX(size.x),
minXY.addY(size.y), maxXY
)
} else {
return null
}
}
}
class PhoneConnectionLine {
getRandomColor() {
const hue = Math.round(Math.random() * 360)
if (hue > 65 && hue < 185) {
return this.getRandomColor()
}
return `hsl(${hue}deg 100% 50%)`
}
constructor(start, end, color="random") {
this.start = start ?? new Vector2d(0, 0)
this.end = end ?? new Vector2d(1, 0)
if (color == "random") {
this.color = this.getRandomColor()
} else {
this.color = color
}
}
get length() {
return this.start.distance(this.end)
}
get points() {
return [this.start, this.end]
}
translate(vec) {
this.start.iadd(vec)
this.end.iadd(vec)
return this
}
rotate(angle) {
for (let vec of this.points) {
vec.irotate(angle)
}
}
scale(scalar) {
for (let vec of this.points) {
vec.iscale(scalar)
}
}
static fromObject(obj) {
return new PhoneConnectionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end),
obj.color
)
}
toObject() {
return {
start: this.start.toObject(),
end: this.end.toObject(),
color: this.color
}
}
}
class Course {
constructor(phones, lines) {
this.phones = phones ?? []
this.lines = lines ?? []
}
reset() {
this.phones = []
this.lines = []
}
toObject() {
return {
phones: this.phones.map(p => p.toObject()),
lines: this.lines.map(l => l.toObject()),
}
}
static fromObject(obj) {
return new Course(
obj.phones.map(p => PhoneCoordinates.fromObject(p)),
obj.lines?.map(l => PhoneConnectionLine.fromObject(l))
)
}
copy() {
return Course.fromObject(this.toObject())
}
scale(scalar) {
this.phones.forEach(p => p.scale(scalar))
this.lines.forEach(l => l.scale(scalar))
}
rotate(angle) {
this.phones.forEach(p => p.rotate(angle))
this.lines.forEach(l => l.rotate(angle))
}
translate(point) {
this.phones.forEach(p => p.translate(point))
this.lines.forEach(l => l.translate(point))
}
addPhone(phone) {
this.phones.push(phone)
}
addLine(line) {
this.lines.push(line)
}
containsPos(pos) {
return this.phones.some(p => p.containsPos(pos))
}
getOverlaps() {
const overlaps = []
for (let i = 0; i < this.phones.length; i++) {
for (let j = 0; j < this.phones.length; j++) {
if (i >= j) continue
const overlap = this.phones[i].getOverlap(this.phones[j])
if (overlap) {
overlaps.push(overlap)
}
}
}
return overlaps
}
}
class Ball {
constructor(pos, vel, inHole, radius, spriteUrl, kicks, active, uid, rotationAngle, lastImmobilePos, immobileTickCount, objectMemory, generallyAbleToCollide) {
this.pos = pos
this.vel = vel ?? new Vector2d(0, 0)
this.inHole = inHole ?? false
this.radius = radius ?? 18
this.spriteUrl = spriteUrl ?? Sprite.BallWhite
this.kicks = kicks ?? 0
this.active = active ?? true
this.uid = uid
this.rotationAngle = rotationAngle ?? 0
this.lastImmobilePos = lastImmobilePos ?? this.pos.copy()
this.immobileTickCount = immobileTickCount ?? 0
this.objectMemory = objectMemory ?? new Map() // {objectUid => dynamicMap<key, value>}
this.generallyAbleToCollide = generallyAbleToCollide ?? true
this.outOfBoundsTickCount = 0
this.movingTickCount = 0
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
i: this.inHole,
r: this.radius,
s: this.spriteUrl,
k: this.kicks,
a: this.active,
u: this.uid,
ro: this.rotationAngle,
l: this.lastImmobilePos,
im: this.immobileTickCount,
o: Array.from(this.objectMemory.entries()).map(([k, v]) => [k, Array.from(v.entries())]),
g: this.generallyAbleToCollide
}
}
static fromObject(obj) {
return new Ball(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.i,
obj.r,
obj.s,
obj.k,
obj.a,
obj.u,
obj.ro,
obj.l,
obj.im,
(obj.o !== undefined) ? new Map(obj.o.map(([k, v]) => [k, new Map(v)])) : new Map(),
obj.g
)
}
kick(direction) {
if (this.inHole) {
return
}
this.vel.iadd(direction.scale(0.6))
this.kicks++
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Shot)
}
}
isMoving() {
return this.vel.length > 0
}
_getClosestWall(pos, board) {
let closestWall = null
let smallestDistance = Infinity
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance} = this._distanceToWall(p1, p2, pos)
if (distance < smallestDistance) {
closestWall = [p1, p2]
smallestDistance = distance
}
}
}
return closestWall
}
_getCollidingCorners(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingCorners = []
for (const wallObject of walledObjects) {
for (const corner of wallObject.corners) {
const distance = corner.distance(this.pos)
if (distance < this.radius) {
collidingCorners.push({
type: "corner",
distance, point: corner
})
}
}
}
return collidingCorners
}
_getCollidingWalls(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingWalls = []
const epsilon = 0.01
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance, closestPoint} = this._distanceToWall(p1, p2, this.pos)
if (distance <= this.radius) {
let overlapCount = 0
for (const box of board.course.phones) {
const boxDist = box.distanceToPos(closestPoint)
if (boxDist < epsilon) {
overlapCount++
if (overlapCount > 1) {
break
}
}
}
if (overlapCount < 2) {
collidingWalls.push({
points: [p1, p2], distance,
type: "wall"
})
}
}
}
}
return collidingWalls
}
_getClosestEndPos(pos, board) {
let closestPos = board.endPositions[0]
let smallestDistance = Infinity
for (let endPos of board.endPositions) {
const distance = endPos.distance(pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestPos = endPos
}
}
return closestPos.copy()
}
_distanceToWall(p1, p2, point) {
let p2toP1 = p2.sub(p1)
let p2toPoint = point.sub(p1)
let d = p2toP1.dot(p2toPoint) / (p2toP1.length ** 2)
if (d < 0) {
return {distance: p1.distance(point), closestPoint: p1.copy()}
} else if (d > 1) {
return {distance: p2.distance(point), closestPoint: p2.copy()}
} else {
let closestPoint = p1.add(p2toP1.scale(d))
return {distance: closestPoint.distance(point), closestPoint}
}
}
_isInCustomWall(pos, board) {
return board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(pos))
}
_reflectAtWall(p1, p2, dir) {
const wallDir = p2.sub(p1)
const wallNormal = new Vector2d(-wallDir.y, wallDir.x)
const angleDifference = dir.angle - wallNormal.angle
return dir.rotate(-angleDifference * 2).scale(-1)
}
_getIntersectingObjects(board, objectType=null) {
return board.objects.filter(o => {
return o.intersects(this.pos) && (
objectType == null || o.type == objectType
)
})
}
readyToCollide(board) {
return !this.inHole && board.startPos.distance(this.pos) > 2 * this.radius
}
calcBallCollisions(board) {
if (!this.readyToCollide(board) || !this.generallyAbleToCollide) {
return
}
for (let ball of board.balls) {
if (ball.uid == this.uid) {
continue
}
if (!ball.readyToCollide(board) || !ball.generallyAbleToCollide) {
continue
}
const collision = ball.pos.distance(this.pos) <= (ball.radius + this.radius)
if (collision) {
const [v1, v2, x1, x2] = [this.vel, ball.vel, this.pos, ball.pos]
const v1p = v1.sub(x1.sub(x2).scale(v1.sub(v2).dot(x1.sub(x2)) / (x1.sub(x2).length ** 2)))
const v2p = v2.sub(x2.sub(x1).scale(v2.sub(v1).dot(x2.sub(x1)) / (x2.sub(x1).length ** 2)))
this.vel = v1p
ball.vel = v2p
this.pos.iadd(this.vel)
ball.pos.iadd(ball.vel)
ball.immobileTickCount = 0
this.immobileTickCount = 0
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Bonk)
}
}
}
}
updatePhysics(board) {
const stepCount = Math.max(Math.ceil(this.vel.length / 10), 1)
let isUnderAcceleration = false
if (board.deviceGravityEnabled && this.isMoving() && !this.inHole) {
for (let i = 0; i < board.course.phones.length; i++) {
if (board.course.phones[i].containsPos(this.pos)) {
const gravity = board.course.phones[i].gravity
.rotate(board.course.phones[i].angle)
if (!gravity) break
if (gravity.length > 0) {
this.vel.iadd(gravity)
isUnderAcceleration = true
}
break
}
}
}
if (this.isMoving() && !this.inHole) {
const gravityBoxes = this._getIntersectingObjects(board, golfObjectType.GravityBox)
for (const box of gravityBoxes) {
const gravity = Vector2d.fromAngle(box.angle - Math.PI / 2).scale(0.5)
this.vel.iadd(gravity)
isUnderAcceleration = true
}
}
if (this.isMoving() && this.vel.length < 0.3 && !isUnderAcceleration) {
this.vel.iscale(0)
}
let isActivelyMoving = false
this.vel.iscale(0.97)
this.vel.iscale(1 / stepCount)
for (let i = 0; i < stepCount; i++) {
if (this.physicsStep(board)) {
isActivelyMoving = true
}
}
this.vel.iscale(stepCount)
if (this.pos.distance(this.lastImmobilePos) > this.radius) {
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
} else {
this.immobileTickCount++
}
if (this.immobileTickCount > 60 * 2 && this.isMoving()) {
this.vel.iscale(0)
}
if (!board.course.containsPos(this.pos) ||
board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(this.pos))) {
this.outOfBoundsTickCount++
if (this.outOfBoundsTickCount > 10) {
this.resetPos(board.startPos)
this.outOfBoundsTickCount = 0
}
} else {
this.outOfBoundsTickCount = 0
}
if (this.isMoving() || isActivelyMoving) {
this.movingTickCount++
if (this.movingTickCount > 60 * 10) {
this.vel.iscale(0)
}
} else {
this.movingTickCount = 0
}
}
isInMovement() {
return this.movingTickCount > 0
}
resetPos(startPos) {
this.pos = startPos.copy()
this.vel.iscale(0)
this.rotationAngle = 0
this.generallyAbleToCollide = true
}
interactWithLava(board, object) {
if (!this.inHole) {
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Lava)
}
board.spawnParticleExplosion(this.pos,
{forceSpeed: this.vel.length, color: "#f9480a"})
return this.resetPos(board.startPos)
}
}
interactWithCannon(board, object) {
const objectData = this.getObjectMemory(object.uid)
let cannonProgress = 0
if (objectData.has("progress")) {
cannonProgress = objectData.get("progress")
} else {
objectData.set("progress", cannonProgress)
}
const shootDir = Vector2d.fromAngle(object.angle + Math.PI / 2)
const bellyPos = object.pos.add(shootDir.scale(-object.size.max() * 0.17))
const nozzlePos = object.pos.add(shootDir.scale(object.size.max() * 0.37))
const desiredPos = cannonProgress < 30 ? bellyPos
: cannonProgress < 100 ? bellyPos.interpolate(nozzlePos, (cannonProgress - 30) / 70)
: nozzlePos
if (cannonProgress > 30 && cannonProgress < 100) {
this.rotationAngle += 0.05
}
this.rotationAngle += 0.02244
this.pos.iinterpolate(desiredPos, Math.min(cannonProgress / 50, 1))
this.vel.iscale(0)
this.generallyAbleToCollide = false
if (cannonProgress >= 140) {
this.vel.setVector2d(shootDir.scale(object.size.max() / 2))
this.pos.iadd(shootDir.scale(object.size.max() / 2))
this.resetObjectMemory(object.uid)
for (let i = 0; i < 20; i++) {
const particle = new Particle(nozzlePos.copy())
particle.vel = shootDir.scale(10 + Math.random() * 10)
particle.vel.irotate(Math.random() * 0.4 - 0.2)
particle.color = "black"
board.particles.push(particle)
}
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Cannon)
}
this.generallyAbleToCollide = true
}
objectData.set("progress", cannonProgress + 1)
return true
}
getObjectMemory(objectUid) {
if (!this.objectMemory.has(objectUid)) {
this.objectMemory.set(objectUid, new Map())
}
const objectData = this.objectMemory.get(objectUid)
objectData.set("expire-count", 100)
return objectData
}
resetObjectMemory(objectUid) {
if (this.objectMemory.has(objectUid)) {
this.objectMemory.delete(objectUid)
}
}
updateObjectMemories() {
for (const [objectUid, objectData] of this.objectMemory.entries()) {
if (objectData.has("expire-count")) {
const count = objectData.get("expire-count")
objectData.set("expire-count", count - 1)
if (count <= 1) {
this.objectMemory.delete(objectUid)
}
}
}
}
interactStepWithObject(board, object) {
switch(object.type) {
case golfObjectType.Lava:
return this.interactWithLava(board, object)
case golfObjectType.Cannon:
return this.interactWithCannon(board, object)
}
}
physicsStep(board) {
let madeWallCollision = false
let isActivelyMoving = false
this.pos.iadd(this.vel)
const touchingObjects = board.objects.filter(o => o.intersects(this.pos))
for (const object of touchingObjects) {
if (this.interactStepWithObject(board, object)) {
isActivelyMoving = true
}
}
this.updateObjectMemories()
const collidingObjects = this._getCollidingCorners(board).concat(this._getCollidingWalls(board))
collidingObjects.sort((a, b) => a.distance - b.distance)
if (collidingObjects.length > 0 && this.generallyAbleToCollide) {
if (collidingObjects[0].type == "corner") {
const collidingCorner = collidingObjects[0].point
const cornerDir = this.pos.sub(collidingCorner)
const collisionStrength = -2 * this.vel.dot(cornerDir) / cornerDir.squaredLength
this.pos.isub(this.vel)
this.vel.iadd(cornerDir.scale(collisionStrength))
this.pos.iadd(this.vel.scale(0.95))
madeWallCollision = true
} else {
for (const [p1, p2] of collidingObjects.filter(o => o.type == "wall").map(o => o.points)) {
this.pos.isub(this.vel)
this.vel = this._reflectAtWall(p1, p2, this.vel)
this.pos.iadd(this.vel.scale(0.8))
}
}
madeWallCollision = true
}
if (board.ballCollisionEnabled) {
this.calcBallCollisions(board)
}
const endPos = this._getClosestEndPos(this.pos, board)
if (endPos && !this.inHole) {
const distance = endPos.distance(this.pos)
if (distance <= this.radius * 1.35 && this.vel.length < 40) {
this.inHole = true
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.WinSound)
}
}
}
if (this.inHole) {
this.radius = Math.max(0, this.radius - 0.13)
this.pos = this.pos.lerp(endPos, 0.1)
this.rotationAngle += 0.4
this.vel.iscale(0.8)
} else {
this.rotationAngle += this.vel.length / 40
}
if (madeWallCollision && window.AudioPlayer) {
window.AudioPlayer.randomNote({
volume: Math.min(this.vel.length / 10 * 0.9 + 0.1, 1.)
})
}
return isActivelyMoving
}
translate(point) {
this.pos.iadd(point)
}
scale(scalar) {
this.radius *= scalar
this.pos.iscale(scalar)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
}
const PARTICLE_MAX_TICKS = 30
class Particle {
constructor(pos, vel, color, radius, ticksAlive) {
this.pos = pos ?? new Vector2d(0, 0)
this.vel = vel ?? new Vector2d(0, 0)
this.color = color ?? "white"
this.radius = radius ?? 5
this.ticksAlive = 0
this.alive = true
}
die() {
this.alive = false
}
get opacity() {
return Math.max(1 - this.ticksAlive / PARTICLE_MAX_TICKS, 0)
}
updatePhysics(board) {
if (!this.alive) {
return
}
this.pos.iadd(this.vel)
if (!board.course.containsPos(this.pos)) {
this.die()
}
if (this.ticksAlive > PARTICLE_MAX_TICKS) {
this.die()
}
this.ticksAlive++
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
c: this.color,
r: this.radius,
t: this.ticksAlive
}
}
static fromObject(obj) {
return new Particle(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.c, obj.r, obj.t
)
}
}
class Board {
static physicsTimestep = 17 // approximately 60 fps
constructor(course, objects, balls, physicsTime, ballCollisionEnabled, deviceGravityEnabled, particlesEnabled, particles) {
this.course = course ?? new Course()
this.objects = objects ?? []
this.balls = balls ?? []
this.particles = particles ?? []
this.physicsTime = physicsTime ?? Date.now()
this.ballCollisionEnabled = ballCollisionEnabled ?? true
this.deviceGravityEnabled = deviceGravityEnabled ?? true
this.particlesEnabled = particlesEnabled ?? true
this.constructionLineBuffer = []
this.courseHistory = [this.course.copy()]
this.physicsStepCount = 0
this.physicsStepEvents = []
}
resetConfig() {
this.balls = []
this.objects = []
this.course.reset()
this.courseHistory = [this.course.copy()]
}
addPhysicsEvent(callback, relativeStepIndex) {
this.physicsStepEvents.push([this.physicsStepCount + relativeStepIndex, callback])
}
spawnParticleExplosion(pos, {color=undefined, forceSpeed=undefined, numParticles=50, radius=undefined}={}) {
if (!this.particlesEnabled) {
return
}
const plusminus = Math.ceil(numParticles * 0.3)
numParticles += Math.round((Math.random() - 0.5) * 2 * plusminus)
const angleStep = 1 / numParticles * Math.PI * 2
for (let i = 0; i < numParticles; i++) {
let speed = forceSpeed ?? 2
speed *= 0.7 + Math.random() * 0.6
const angle = (i + Math.random()) * angleStep
const vel = Vector2d.fromAngle(angle).scale(speed)
const particle = new Particle(pos.copy(), vel, color, radius)
this.particles.push(particle)
}
}
clearPhysicsEvents() {
this.physicsStepEvents.splice(0, this.physicsStepEvents.length)
}
get movableThings() {
return this.objects.concat(this.balls).concat([this.course])
}
translate(point) {
for (const thing of this.movableThings) {
thing.translate(point)
}
}
rotate(angle) {
for (const thing of this.movableThings) {
thing.rotate(angle)
}
}
scale(scalar) {
for (const thing of this.movableThings) {
thing.scale(scalar)
}
}
updateObject(object) {
for (let i = 0; i < gameState.board.objects.length; i++) {
if (gameState.board.objects[i].uid == object.uid) {
gameState.board.objects[i] = object
return true
}
}
return false
}
getClosestObject(pos) {
let smallestDistance = Infinity
let closestObject = null
for (let object of this.objects) {
const distance = pos.distance(object.pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestObject = object
}
}
return closestObject
}
intersectObject(pos) {
for (let i = this.objects.length - 1; i >= 0; i--) {
if (this.objects[i].intersects(pos)) {
return this.objects[i]
}
}
return null
}
get startPos() {
const startObject = this.objects.find(o => o.type == golfObjectType.Start)
if (startObject) {
return startObject.pos
} else {
return undefined
}
}
get endPositions() {
return this.objects.filter(o => (
o.type == golfObjectType.Hole
|| o.type == golfObjectType.DuellHole1
|| o.type == golfObjectType.DuellHole2
)).map(o => o.pos)
}
updateObjectPhysics() {
for (const object of this.objects.filter(o => o.type == golfObjectType.Cannon)) {
object.angle += 0.02244
}
}
physicsStep() {
for (const ball of this.balls) {
ball.updatePhysics(this)
}
for (const particle of this.particles) {
particle.updatePhysics(this)
}
this.updateObjectPhysics()
this.particles = this.particles.filter(p => p.alive)
this.physicsTime += Board.physicsTimestep
}
updatePhysics(maxTime=Date.now(), maxSteps=500) {
let stepCount = 0
while (stepCount < maxSteps && this.physicsTime < maxTime) {
this.physicsStep()
this.physicsStepCount++
stepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
if (Math.abs(this.physicsTime - maxTime) > 10 * 1000) {
this.physicsTime = maxTime
}
}
simulateStepsEfficiently(numSteps, {
disableParticles = true
}={}) {
const prevParticlesEnabled = this.particlesEnabled
if (disableParticles) {
this.particlesEnabled = false
}
for (let i = 0; i < numSteps; i++) {
this.physicsStep()
this.physicsStepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
this.particlesEnabled = prevParticlesEnabled
}
spawnBall({
spriteUrl = "random"
}={}) {
if (!this.startPos) {
throw new Error("StartPos must be set before spawning ball")
}
if (spriteUrl == "random") {
spriteUrl = AllBallSprites[Math.floor(Math.random() * AllBallSprites.length)]
}
const ball = new Ball(
this.startPos.copy(), new Vector2d(0, 0),
false, 18, spriteUrl, 0, true,
Math.random().toString().slice(2), 0
)
this.balls.push(ball)
return ball
}
addConstructionLine(line, phone, timestamp, deviceIndex) {
this.constructionLineBuffer.push({
line, phone, timestamp, deviceIndex})
this.parseConstructionLines()
}
toObject() {
return {
course: this.course.toObject(),
objects: this.objects.map(o => o.toObject()),
balls: this.balls.map(b => b.toObject()),
physicsTime: this.physicsTime,
ballCollisionEnabled: this.ballCollisionEnabled,
deviceGravityEnabled: this.deviceGravityEnabled,
particlesEnabled: this.particlesEnabled,
particles: this.particles.map(p => p.toObject())
}
}
static fromObject(obj) {
return new Board(
Course.fromObject(obj.course),
obj.objects.map(o => GolfObject.fromObject(o)),
obj.balls.map(b => Ball.fromObject(b)),
obj.physicsTime, obj.ballCollisionEnabled,
obj.deviceGravityEnabled, obj.particlesEnabled,
obj.particles?.map(p => Particle.fromObject(p))
)
}
get currPhoneIndex() {
return Math.max(1, this.course.phones.length)
}
parseConstructionLines() {
this.constructionLineBuffer = this.constructionLineBuffer
.filter(c => Date.now() - c.timestamp < 2500)
if (this.constructionLineBuffer.length < 2) {
return
}
const removeIndeces = new Set()
for (let i = 0; i + 1 < this.constructionLineBuffer.length; i++) {
let a = this.constructionLineBuffer[i]
let b = this.constructionLineBuffer[i + 1]
if (a.deviceIndex > b.deviceIndex) {
[a, b] = [b, a] // swap values, make sure {a} has smaller deviceIndex
}
if (!this.connectTwoConstructionLines(a, b)) {
removeIndeces.add(i)
}
}
this.constructionLineBuffer = this.constructionLineBuffer
.filter((_, i) => !removeIndeces.has(i))
}
connectTwoConstructionLines(a, b) {
if (a.deviceIndex > this.currPhoneIndex || a.deviceIndex == b.deviceIndex) {
return false
}
if (a.deviceIndex < this.currPhoneIndex) {
while (this.course.phones.length > parseInt(a.deviceIndex) && this.courseHistory.length > 1) {
this.courseHistory.pop()
this.course = this.courseHistory.slice(-1)[0].copy()
}
}
if (this.course.phones.length == 0) {
this.course = new Course([a.phone.copy()])
this.courseHistory.push(this.course.copy())
}
const deltaA = a.line.endPos.sub(a.line.startPos)
const deltaB = b.line.endPos.sub(b.line.startPos)
const originA = a.line.startPos.copy()
const originB = b.line.startPos.copy()
this.course.scale(deltaB.length / deltaA.length)
originA.iscale(deltaB.length / deltaA.length)
this.course.rotate(deltaB.angle - deltaA.angle)
originA.irotate(deltaB.angle - deltaA.angle)
this.course.translate(originB.sub(originA))
this.course.addPhone(b.phone.copy())
this.course.addLine(new PhoneConnectionLine(b.line.startPos, b.line.endPos))
this.courseHistory.push(this.course.copy())
return true
}
copy() {
return Board.fromObject(this.toObject())
}
}
const gamePhase = {
None: -1,
Hello: 0,
ModeChoice: 1,
PlayerSetupDuell: 2,
PlayerSetupTournament: 3,
Connecting: 4,
ConfigGame: 5,
TournamentExplanation: 6,
DuellExplanation: 7,
ConstructionChoice: 8,
ConstructionAuto: 9,
ConstructionCustom: 10,
Loading: 11,
Placing: 12,
PlayingDuell: 13,
PlayingSandbox: 14,
PlayingTournament: 15,
ShowingResultsOfTournament: 16,
ShowingResultsOfDuell: 17,
__LOWEST_PLAYING: 13,
__LOWEST_SHOWING_RESULTS: 16,
__MAX_VALUE: 18,
isPlaying(phase) {
return (
phase == gamePhase.PlayingDuell
|| phase == gamePhase.PlayingSandbox
|| phase == gamePhase.PlayingTournament
)
},
}
const gamePhaseNames = {
[gamePhase.None]: "none",
[gamePhase.Hello]: "hello",
[gamePhase.ModeChoice]: "mode-choice",
[gamePhase.PlayerSetupDuell]: "player-setup-duell",
[gamePhase.PlayerSetupTournament]: "player-setup-tournament",
[gamePhase.Connecting]: "connecting",
[gamePhase.ConfigGame]: "config-game",
[gamePhase.TournamentExplanation]: "tournament-explanation",
[gamePhase.DuellExplanation]: "duell-explanation",
[gamePhase.ConstructionChoice]: "construction-choice",
[gamePhase.ConstructionAuto]: "construction-auto",
[gamePhase.ConstructionCustom]: "construction-custom",
[gamePhase.Loading]: "loading",
[gamePhase.Placing]: "placing",
[gamePhase.PlayingDuell]: "playing-duell",
[gamePhase.PlayingTournament]: "playing-tournament",
[gamePhase.PlayingSandbox]: "playing-sandbox",
[gamePhase.ShowingResultsOfTournament]: "showing-results-of-tournament",
[gamePhase.ShowingResultsOfDuell]: "showing-results-of-duell",
}
const gameMode = {
Sandbox: "sandbox",
Tournament: "tournament",
Duell: "duell",
None: "none",
}
class Player {
constructor(name, roundScores=[]) {
this.name = name
this.roundScores = roundScores
}
get score() {
let sum = 0
for (let score of this.roundScores) {
sum += score
}
return sum
}
toObject() {
return {
name: this.name,
roundScores: this.roundScores
}
}
static fromObject(obj) {
return new Player(obj.name, obj.score, obj.roundScores)
}
addRound(score) {
this.roundScores.push(score)
}
}
class GameState {
constructor(phase, mode, board, players=[], deviceIndex=null,
placingObjectType=golfObjectType.Start,
tournamentBuilderIndex=0, tournamentBallIndex=0,
duellActivePlayerIndex=0, duellWinnerIndex=null,
tournamentMaxKicks=10) {
this.phase = phase
this.mode = mode
this.board = board
this.players = players
this.deviceIndex = deviceIndex
this.placingObjectType = placingObjectType
this.tournamentBuilderIndex = tournamentBuilderIndex
this.tournamentBallIndex = tournamentBallIndex
this.duellActivePlayerIndex = duellActivePlayerIndex
this.duellWinnerIndex = duellWinnerIndex
this.tournamentMaxKicks = tournamentMaxKicks
}
replaceText(txt) {
if (this.mode == gameMode.Duell && this.players.length >= 2) {
txt = txt.replaceAll("<duell-player-1>", this.players[0].name)
txt = txt.replaceAll("<duell-player-2>", this.players[1].name)
}
return txt
}
get duellActivePlayer() {
return this.players[this.duellActivePlayerIndex % this.players.length]
}
get duellInactivePlayer() {
return this.players[(this.duellActivePlayerIndex + 1) % this.players.length]
}
get duellWinner() {
return this.players[this.duellWinnerIndex]
}
get tournamentFinished() {
return this.tournamentBuilderIndex >= this.players.length
}
get tournamentBuilder() {
return this.players[this.tournamentBuilderIndex % this.players.length]
}
get tournamentBall() {
return this.board.balls[this.tournamentBallIndex % this.board.balls.length]
}
get tournamentActivePlayer() {
return this.players[this.tournamentBallIndex % this.players.length]
}
addPlayer(player) {
this.players.push(player)
}
get thisPhone() {
return this.board.course.phones[this.deviceIndex - 1]
}
getReferenceCanvas() {
return fullscreenCanvas
}
screenPosToBoardPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.screenPosToBoardPos(pos, screenSize)
}
boardPosToScreenPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.boardPosToScreenPos(pos, screenSize)
}
screenAngleToBoardAngle(angle) {
if (!this.thisPhone) return angle
return angle + this.thisPhone.angle
}
boardAngleToScreenAngle(angle) {
if (!this.thisPhone) return angle
return angle - this.thisPhone.angle
}
get scalingFactor() {
if (!this.thisPhone) return 1
return this.thisPhone.scalar
}
get creditCardScalingFactor() {
if (!this.thisPhone) return 1
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.creditCardScalingFactor(screenSize)
}
get combinedScalingFactor() {
return this.creditCardScalingFactor * this.scalingFactor
}
toObject(deviceIndex) {
return {
phase: this.phase,
mode: this.mode,
board: this.board.toObject(),
players: this.players.map(p => p.toObject()),
index: deviceIndex ?? this.deviceIndex,
placingObjectType: this.placingObjectType,
tournamentBuilderIndex: this.tournamentBuilderIndex,
tournamentBallIndex: this.tournamentBallIndex,
duellActivePlayerIndex: this.duellActivePlayerIndex,
duellWinnerIndex: this.duellWinnerIndex,
tournamentMaxKicks: this.tournamentMaxKicks
}
}
static fromObject(obj) {
return new GameState(
obj.phase, obj.mode,
Board.fromObject(obj.board),
obj.players.map(p => Player.fromObject(p)),
obj.index,
obj.placingObjectType,
obj.tournamentBuilderIndex,
obj.tournamentBallIndex,
obj.duellActivePlayerIndex,
obj.duellWinnerIndex,
obj.tournamentMaxKicks)
}
updatePhysics(hostTime=Date.now()) {
this.board.updatePhysics(hostTime)
}
startSandboxRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateSandbox() {
this.board.balls = this.board.balls.filter(b => b.radius > 0)
}
startTournamentRound() {
this.board.balls = []
for (let i = 0; i < this.players.length; i++) {
const spriteUrl = AllBallSprites[i % AllBallSprites.length]
this.board.spawnBall({spriteUrl})
}
this.tournamentBallIndex = 0
this.board.balls.forEach(b => b.active = false)
this.tournamentBall.active = true
generateScoreboard()
}
endTournament() {
this.phase = gamePhase.ShowingResultsOfTournament
generateScoreboard()
}
endTournamentRound() {
if (this.board.balls.length == 0) {
return
}
this.phase = gamePhase.TournamentExplanation
for (let i = 0; i < this.players.length; i++) {
const roundIndex = this.tournamentBuilderIndex
if (!this.board.balls[i].inHole) {
this.players[i].roundScores[roundIndex] += 2
}
}
this.tournamentBuilderIndex++
this.board.balls.splice(0, this.board.balls.length)
if (this.tournamentFinished) {
this.endTournament()
}
this.board.objects = []
}
onTournamentKick(ball) {
let ballIndex = 0
for (let i = 0; i < this.board.balls.length; i++) {
ballIndex = i
if (ball.uid == this.board.balls[i].uid) {
break
}
}
this.tournamentBall.active = false
this.tournamentBallIndex = ballIndex + 1
this.tournamentBall.active = true
this.advanceTournamentBall(true)
}
advanceTournamentBall(forceSpeak=false) {
if (this.tournamentBall === undefined) {
return false
}
let prevPlayerName = this.tournamentActivePlayer.name
let inHoleCount = 0
while ((this.tournamentBall.inHole && this.tournamentBall.radius == 0)
|| (this.tournamentBall.kicks >= this.tournamentMaxKicks && !this.tournamentBall.isInMovement())) {
inHoleCount++
this.tournamentBall.active = false
this.tournamentBallIndex++
this.tournamentBall.active = true
if (inHoleCount >= this.players.length) {
return false
}
}
if (prevPlayerName != this.tournamentActivePlayer.name || forceSpeak) {
if (window.AudioPlayer && gamePhase.isPlaying(this.phase)) {
setTimeout(() => {
if (gamePhase.isPlaying(this.phase)) {
window.AudioPlayer.say(this.tournamentActivePlayer.name)
}
}, 1000)
}
}
return true
}
updateTournament() {
let madeChange = false
for (let i = 0; i < this.players.length; i++) {
let kicks = this.board.balls[i].kicks
const player = this.players[i]
const roundIndex = this.tournamentBuilderIndex
if (player.roundScores[roundIndex] === undefined) {
player.addRound(kicks)
madeChange = true
} else {
player.roundScores[roundIndex] = kicks
}
}
if (!this.advanceTournamentBall()) {
this.endTournamentRound()
madeChange = true
}
return madeChange
}
endDuell() {
this.phase = gamePhase.ShowingResultsOfDuell
this.board.balls = []
}
startDuellRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateDuell() {
const ball = this.board.balls[0]
if (ball.radius == 0 && ball.inHole) {
const closestObject = this.board.getClosestObject(ball.pos)
if (closestObject.type == golfObjectType.DuellHole1) {
this.duellWinnerIndex = 0
} else {
this.duellWinnerIndex = 1
}
this.endDuell()
return true
}
}
update(hostTime=Date.now()) {
this.updatePhysics(hostTime)
if (gamePhase.isPlaying(this.phase)) {
if (this.mode == gameMode.Tournament) {
return this.updateTournament()
} else if (this.mode == gameMode.Sandbox) {
return this.updateSandbox()
} else if (this.mode == gameMode.Duell) {
return this.updateDuell()
}
}
}
}
class BoardRenderer {
static spriteImgMap = {}
static async loadImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
img.dataset.sprite = src
})
}
static async load() {
const promises = Object.values(Sprite).map(s => this.loadImg(s))
for (const img of await Promise.all(promises)) {
this.spriteImgMap[img.dataset.sprite] = img
}
}
static drawSprite(context, centerPos, size, sprite, {
angle = 0,
imageSmoothing = false
}={}) {
const img = this.spriteImgMap[sprite]
if (!img) {
throw new Error(`Unknown Sprite: ${sprite}`)
}
context.imageSmoothingEnabled = imageSmoothing // as some sprites may be very small in size
context.save()
context.translate(centerPos.x, centerPos.y)
context.rotate(angle)
context.drawImage(img, -size.x / 2, -size.y / 2, size.x, size.y)
context.restore()
}
static drawCustomWall(context, corners) {
context.beginPath()
context.moveTo(corners[0].x, corners[0].y)
for (let i = 0; i < corners.length; i++) {
const index = (i + 1) % corners.length
context.lineTo(corners[index].x, corners[index].y)
}
context.strokeStyle = "black"
context.fillStyle = "white"
context.lineWidth = 1
context.lineCap = "round"
context.fill()
context.stroke()
}
static render(board, context, {drawConnectionLines = false, drawBalls = true}={}) {
const canvas = context.canvas
canvas.style.display = "block"
canvas.width = canvas.clientWidth
canvas.height = canvas.clientHeight
const screenBoard = board.copy()
let minX = Math.min(...screenBoard.course.phones.map(p => p.points.map(c => c.x)).flat())
let minY = Math.min(...screenBoard.course.phones.map(p => p.points.map(c => c.y)).flat())
let maxX = Math.max(...screenBoard.course.phones.map(p => p.points.map(c => c.x)).flat())
let maxY = Math.max(...screenBoard.course.phones.map(p => p.points.map(c => c.y)).flat())
if ((maxX - minX) < (maxY - minY)) {
screenBoard.rotate(Math.PI / -2)
}
minX = Math.min(...screenBoard.course.phones.map(p => p.points.map(c => c.x)).flat())
minY = Math.min(...screenBoard.course.phones.map(p => p.points.map(c => c.y)).flat())
screenBoard.translate(new Vector2d(-minX, -minY))
maxX = undefined
while (maxX == undefined || maxX > canvas.width || maxY > canvas.height) {
screenBoard.scale(0.95 ** 2)
maxX = Math.max(...screenBoard.course.phones.map(p => p.points.map(c => c.x)).flat())
maxY = Math.max(...screenBoard.course.phones.map(p => p.points.map(c => c.y)).flat())
screenBoard.scale(0.95 ** -1)
}
screenBoard.scale(0.95)
const averagePos = calcAveragePos([new Vector2d(0, 0), new Vector2d(maxX, maxY)])
screenBoard.translate(new Vector2d(canvas.width / 2, canvas.height / 2).sub(averagePos))
let minOverlapIndex = screenBoard.course.phones.length
const overlaps = screenBoard.course.getOverlaps()
screenBoard.course.phones.push(...overlaps)
for (let i = 0; i < screenBoard.course.phones.length; i++) {
context.beginPath()
const phone = screenBoard.course.phones[i]
context.moveTo(phone.points[0].x, phone.points[0].y)
for (let point of phone.points.slice(1)) {
context.lineTo(point.x, point.y)
}
context.lineTo(phone.points[0].x, phone.points[0].y)
context.strokeStyle = "black"
context.lineWidth = 2
context.lineCap = "round"
if (i >= minOverlapIndex) {
context.fillStyle = "rgba(255, 0, 0, 1)"
} else {
context.fillStyle = "#79ffb6"
}
context.fill()
context.stroke()
}
for (let i = 0; i < minOverlapIndex; i++) {
const phone = screenBoard.course.phones[i]
const averagePos = calcAveragePos(phone.points)
context.font = `${Math.min(phone.size.x, phone.size.y) * 0.4}px Arial`
context.textBaseline = "middle"
context.textAlign = "center"
context.fillStyle = "black"
context.save()
context.translate(averagePos.x, averagePos.y)
context.rotate(phone.angle)
context.fillText((i + 1).toString() + ".", 0, 0)
context.restore()
}
if (drawConnectionLines)
for (const line of screenBoard.course.lines) {
context.beginPath()
context.moveTo(line.start.x, line.start.y)
context.lineTo(line.end.x, line.end.y)
context.lineWidth = 5
context.strokeStyle = line.color
context.stroke()
}
for (const obj of screenBoard.objects) {
if (obj.type == golfObjectType.CustomWall) {
this.drawCustomWall(context, obj.corners)
} else {
this.drawSprite(context, obj.pos, obj.size, obj.sprite, {angle: obj.angle})
}
}
if (drawBalls) {
for (const ball of screenBoard.balls) {
this.drawSprite(context, ball.pos,
new Vector2d(ball.radius, ball.radius).scale(2),
ball.spriteUrl, {angle: ball.angle})
}
}
}
}
const dataMessageType = {
PING: "ping",
GAMESTATE: "gamestate",
CONSTRUCTION_LINE: "construction_line",
PLACE_OBJECT: "place_object",
CHANGE_OBJECT: "change_object",
REMOVE_OBJECT: "remove_object",
REQUEST_DIMENSIONS: "request_dimensions",
SEND_DIMENSIONS: "send_dimensions",
KICK_BALL: "kick_ball",
DEVICE_ORIENTATION: "device_orientation"
}
class DataMessage {
constructor(type, data, createTime, receivedTime, hostTime) {
this.type = type
this.data = data ?? {}
this.createTime = createTime ?? Date.now()
this.hostTime = hostTime ?? null
this.receivedTime = receivedTime ?? null
}
toString() {
return JSON.stringify({
type: this.type,
data: this.data,
createTime: this.createTime,
receivedTime: this.receivedTime,
hostTime: this.hostTime
})
}
static fromObject(obj) {
return new DataMessage(obj.type, obj.data, obj.createTime, obj.receivedTime, obj.hostTime)
}
static fromString(jsonString) {
return DataMessage.fromObject(JSON.parse(jsonString))
}
static Ping(data={}) {
return new DataMessage(dataMessageType.PING, data)
}
}
const rtcDataType = {
openPool: "open_pool",
joinPool: "join_pool",
Offer: "offer",
Answer: "answer",
HostCandidate: "host-candidate",
AnswerCandidate: "answer-candidate",
}
function getNotSoSecretMeteredApiKey() {
let str = "fa94c40a3450effec69e410ae8d2b6e"
const isPrime = n=>{
if (n < 2) return false
if (n === 2) return true
if (n % 2 === 0) return false
for (let i = 3; i <= Math.sqrt(n); i += 2) {
if (n % i === 0) return false
}
return true
}
let count = 0
for (let i = 0; true; i++) {
if (isPrime(i)) {
count++
if (count == 5425) {
str += i.toString()
break
}
}
}
return str.split("").reverse().join("")
}
const notSoSecretMeteredApiKey = getNotSoSecretMeteredApiKey()
class RtcBase {
static pingPeriod = 3000
closePoolApi = "https://www.noel-friedrich.de/multigolf2/api/close_pool.php"
getSignalsApi = "https://www.noel-friedrich.de/multigolf2/api/get_signals.php"
sendSignalApi = "https://www.noel-friedrich.de/multigolf2/api/send_signal.php"
getIceServersApi = "https://multigolf2.metered.live/api/v1/turn/credentials?apiKey=" + notSoSecretMeteredApiKey
static checkForSignalsInterval = 1000
static clientTimeoutPeriod = 20 * 1000
static hostTimeoutPeriod = 10 * 1000
initDatachannelListeners() {
this.dataChannel.onopen = (e) => {
if (!this.alive) return
this.logFunction(Text.ConnectionEstablished)
this.dataChannelOpen = true
}
this.dataChannel.onmessage = (e) => {
if (!this.alive) return
const message = DataMessage.fromString(e.data)
if (message.receivedTime === null) {
message.receivedTime = Date.now()
}
this.lastDataMessage = message
this.lastDataMessageTime = Date.now()
this.onDataMessage(message)
}
this.dataChannel.onclose = (e) => {
if (!this.alive) return
this.logFunction(Text.ConnectionDied)
this.dataChannelOpen = false
this.die()
this.onDataClose()
}
}
async init() {
if (this.hasInitted) {
return
}
if (new URLSearchParams(location.search).has("debug")) {
this.logFunction(Text.InitializingPeerToPeer)
}
this.hasInitted = true
const response = await fetch(this.getIceServersApi)
const iceServers = await response.json()
if (new URLSearchParams(location.search).has("debug")) {
console.log("[DEBUG] received ice servers from api", iceServers)
}
iceServers.push({urls: "stun:stun.l.google.com:19302"})
iceServers.push(...[{urls: 'stun:freeturn.net:5349'}, {urls: 'turns:freeturn.tel:5349', username: 'free', credential: 'free'}])
this.peerConnection = new RTCPeerConnection({iceServers: iceServers})
this.dataChannel = this.peerConnection.createDataChannel("chat", {
negotiated: true, id: 0})
this.initDatachannelListeners()
}
constructor({
logFunction = () => {},
onDataMessage = () => {},
onDataClose = () => {},
index = -1,
poolUid = null,
}={}) {
this.logFunction = logFunction
this.onDataMessage = onDataMessage
this.onDataClose = onDataClose
this.processedSignalIds = new Set()
this.dataChannelOpen = false
this.signalingUid = null
this.hasInitted = false
this.lastDataMessage = null
this.lastDataMessageTime = null
this.alive = true
this.index = index
this.poolUid = poolUid
if (!poolUid) {
throw new Error("PoolUid must be given to WebRTC Handler")
}
}
die() {
this.alive = false
}
sendMessage(message) {
if (!this.alive) return
if (message instanceof DataMessage) {
if (this.delayMs !== undefined) {
message.hostTime = Date.now() + this.delayMs
}
message = message.toString()
}
if (this.dataChannelOpen) {
this.dataChannel.send(message)
return true
} else {
return false
}
}
async uploadToServer(type, data, objectName, logSuccess=true) {
try {
let apiUrl = this.sendSignalApi
apiUrl += `?type=${encodeURIComponent(type)}`
apiUrl += `&pool_uid=${encodeURIComponent(this.poolUid)}`
apiUrl += `&uid=${encodeURIComponent(this.signalingUid)}`
apiUrl += `&data=${encodeURIComponent(JSON.stringify(data))}`
const response = await fetch(apiUrl)
const textResponse = await response.text()
if (textResponse == "worked like a charm") {
if (logSuccess) {
this.logFunction(Text.SuccessfullySentObject(objectName))
}
return true
} else {
throw new Error(`Unknown Server Response: ${textResponse}`)
}
} catch (err) {
this.logFunction(Text.FailedSendingObject(objectName, err.message))
throw err
}
}
async getFromServer(type, uid) {
try {
let apiUrl = this.getSignalsApi
apiUrl += `?pool_uid=${encodeURIComponent(this.poolUid)}`
const response = await fetch(apiUrl)
let rows = await response.json()
rows = rows.filter(r => !this.processedSignalIds.has(r.id))
if (type !== undefined) {
rows = rows.filter(r => r.type == type)
}
if (uid !== undefined) {
rows = rows.filter(r => r.uid == uid)
}
for (let row of rows) {
row.data = JSON.parse(row.data)
this.processedSignalIds.add(row.id)
}
return rows
} catch (err) {
this.logFunction(Text.CouldntFetchServer(err.message))
throw err
}
}
async waitUntil(func, name, {
timeout = 60000,
checkIntervalMs = 100,
}={}) {
const startWaitTime = Date.now()
while (true) {
const timeElapsed = Date.now() - startWaitTime
if (timeElapsed > timeout) {
this.die()
throw new Error(`Timeout while waiting for ${name}`)
}
if (!this.alive) {
throw new Error(`Connection died while waiting for ${name}`)
}
if (func()) {
return
}
await new Promise(resolve => setTimeout(resolve, checkIntervalMs))
}
}
async checkForUpdates(untilFunc, handleUpdate, objectName, {
checkInterval = RtcBase.checkForSignalsInterval,
timeoutPeriod = RtcBase.hostTimeoutPeriod,
}) {
const startTime = Date.now()
while (!untilFunc()) {
const updates = await this.getFromServer(undefined, this.signalingUid)
if (!this.alive) {
throw new Error(`Connection died while waiting for ${objectName}`)
}
for (let update of updates) {
handleUpdate(update)
}
const timeElapsed = Date.now() - startTime
if (timeElapsed > timeoutPeriod) {
this.die()
throw new Error(`Timeout while waiting for ${objectName}`)
}
await new Promise(resolve => setTimeout(resolve, checkInterval))
}
}
generateSignalingUid() {
return Math.random().toString().slice(2)
}
}
class RtcHost extends RtcBase {
getStatus() {
let color = "green"
let message = Text.GoodConnection
if (!this.lastDataMessageTime) {
color = "blue"
message = Text.ConnectionBeingInitialized
} else if (Date.now() - this.lastDataMessageTime > RtcBase.pingPeriod * 2) {
color = "red"
message = Text.ConnectionTimedOut
}
if (this.lastDataMessage && color == "green") {
if (this.delayMs > 500) {
color = "orange"
message = Text.ConnectionIsSlow(Math.round(this.delayMs * 2))
}
}
return {color, message}
}
receivePing(pingMessage) {
this.receivedPing = pingMessage
if (pingMessage.data.displaySize) {
const before = this.clientDisplaySize ? this.clientDisplaySize.copy() : null
this.clientDisplaySize = Vector2d.fromObject(pingMessage.data.displaySize)
if (!before || before.x != this.clientDisplaySize.x || before.y != this.clientDisplaySize.y) {
return true
}
}
return false
}
async startPinging() {
while (true) {
const pingStartTime = Date.now()
this.sendMessage(DataMessage.Ping({index: this.index}))
this.receivedPing = null
await this.waitUntil(() => this.receivedPing, "Pinging")
const timeElapsed = this.receivedPing.receivedTime - pingStartTime
this.delayMs = (timeElapsed / 2) * 0.1 + this.delayMs * 0.9
await new Promise(resolve => setTimeout(resolve, RtcBase.pingPeriod))
}
}
async start(signalingUid) {
this.delayMs = 0
this.signalingUid = signalingUid
this.clientDisplaySize = null
await this.init()
this.peerConnection.addEventListener("icecandidateerror", event => {
if (!this.alive) return
if (new URLSearchParams(location.search).has("debug")) {
console.log(`[DEBUG] ICE candidate error: ${event.errorText}`)
}
})
this.peerConnection.addEventListener("icecandidate", event => {
if (!this.alive) return
if (event.candidate == null) return
this.uploadToServer(rtcDataType.HostCandidate, {
candidate: event.candidate
}, "Ice Candidate", false)
})
const offer = await this.peerConnection.createOffer()
await this.peerConnection.setLocalDescription(offer)
if (!this.alive) return
this.uploadToServer(rtcDataType.Offer, {
sdp: this.peerConnection.localDescription
}, "Connection Offer", new URLSearchParams(location.search).has("debug"))
await this.checkForUpdates(
() => this.dataChannelOpen,
async (signal, abort) => {
if (signal.type == rtcDataType.AnswerCandidate) {
const candidate = new RTCIceCandidate(signal.data.candidate)
this.peerConnection.addIceCandidate(candidate)
}
if (signal.type == rtcDataType.Answer) {
if (this.peerConnection.signalingState != "have-local-offer") {
return
}
const description = new RTCSessionDescription(signal.data.sdp)
await this.peerConnection.setRemoteDescription(description)
if (signal.data.sdp.type == "offer") {
const answer = await this.peerConnection.createAnswer()
await this.peerConnection.setLocalDescription(answer)
this.uploadToServer(rtcDataType.Offer, {
sdp: this.peerConnection.localDescription
}, Text.ConnectionAnswer)
}
}
},
Text.RTCAnswer,
{timeoutPeriod: RtcBase.hostTimeoutPeriod}
)
}
}
class RtcClient extends RtcBase {
getStatus() {
let color = "green"
let message = Text.GoodConnection
if (!this.lastDataMessageTime) {
color = "blue"
message = Text.ConnectionBeingInitialized
} else if (Date.now() - this.lastDataMessageTime > RtcBase.pingPeriod * 2) {
color = "red"
message = Text.ConnectionTimedOut
}
return {color, message}
}
async joinPool(deviceIndex) {
await this.uploadToServer(rtcDataType.joinPool, {
signalingUid: this.signalingUid, deviceIndex
}, Text.ConnectionInvitation)
}
async start(deviceIndex=null) {
await this.init()
this.answerSdp = null
this.offerSdp = null
this.signalingUid = this.generateSignalingUid()
await this.joinPool(deviceIndex)
if (!this.alive) return
this.peerConnection.addEventListener("icecandidateerror", event => {
if (!this.alive) return
if (new URLSearchParams(location.search).has("debug")) {
console.log(`[DEBUG] ICE candidate error: ${event.errorText}`)
}
})
this.peerConnection.addEventListener("icecandidate", event => {
if (!this.alive) return
if (event.candidate == null) return
this.uploadToServer(rtcDataType.AnswerCandidate, {
candidate: event.candidate
}, "Ice Candidate", false)
})
await this.checkForUpdates(
() => this.dataChannelOpen,
async (signal) => {
if (signal.type == rtcDataType.HostCandidate) {
const candidate = new RTCIceCandidate(signal.data.candidate)
this.peerConnection.addIceCandidate(candidate)
}
if (signal.type == rtcDataType.Offer) {
const description = new RTCSessionDescription(signal.data.sdp)
await this.peerConnection.setRemoteDescription(description)
if (signal.data.sdp.type == "offer") {
const answer = await this.peerConnection.createAnswer()
await this.peerConnection.setLocalDescription(answer)
this.uploadToServer(rtcDataType.Answer, {
sdp: this.peerConnection.localDescription
}, Text.ConnectionAnswer)
}
}
},
"RTC Offer",
{timeoutPeriod: RtcBase.clientTimeoutPeriod}
)
}
}
class RtcHostManager {
static checkForJoinsPeriod = 5000
static clientUrl = "https://multi.golf/client/"
static openPoolApi = "https://www.noel-friedrich.de/multigolf2/api/open_pool.php"
constructor({
logFunction = () => {},
onDataMessage = () => {},
onClientUrlAvailable = () => {},
allowConnectionOverride = () => true
}={}) {
this.gameState = gameState
this.logFunction = logFunction
this.onDataMessage = onDataMessage
this.onClientUrlAvailable = onClientUrlAvailable
this.allowConnectionOverride = allowConnectionOverride
this.poolUid = null
this.connections = []
this.polling = false
}
makeConnection(deviceIndex) {
const connection = new RtcHost({
logFunction: (message) => {
if (!connection.alive) {
return
}
this.logFunction(`[${connection.index}] ${message}`)
},
onDataMessage: (message) => {
this.onDataMessage(message, connection)
},
poolUid: this.poolUid
})
if (deviceIndex != null && deviceIndex <= this.connections.length) {
this.connections[deviceIndex - 1].die()
this.connections[deviceIndex - 1] = connection
} else {
this.connections.push(connection)
}
this.sortConnections()
return connection
}
sortConnections() {
this.connections.sort((a, b) => {
return a.randomOffset - b.randomOffset
})
for (let i = 0; i < this.connections.length; i++) {
this.connections[i].index = i + 1
}
}
async openPool() {
const urlParams = new URLSearchParams(location.search)
if (urlParams.has("debug") && urlParams.has("p")) {
return urlParams.get("p")
}
const response = await fetch(RtcHostManager.openPoolApi)
const jsonData = await response.json()
return jsonData["pool_uid"]
}
makeClientUrl() {
return RtcHostManager.clientUrl + `?p=${encodeURIComponent(this.poolUid)}`
}
async start() {
this.poolUid = await this.openPool()
this.onClientUrlAvailable(this.makeClientUrl())
this.logFunction(Text.CreatedPool(this.poolUid))
this.baseConnection = new RtcBase({poolUid: this.poolUid})
this.startPolling()
}
async startPolling() {
this.polling = true
while (this.polling) {
const updates = await this.baseConnection.getFromServer(rtcDataType.joinPool)
for (let update of updates) {
let deviceIndex = update.data.deviceIndex
const signalingUid = update.data.signalingUid
if (deviceIndex != null
&& this.connections[deviceIndex - 1]
&& this.connections[deviceIndex - 1].getStatus().color !== "red"
&& this.allowConnectionOverride()
) {
deviceIndex = null
}
const connection = this.makeConnection(deviceIndex)
connection.start(signalingUid).then(() => {
connection.startPinging()
})
}
await new Promise(resolve => setTimeout(resolve, RtcHostManager.checkForJoinsPeriod))
}
}
removeLostConnections() {
for (const connection of this.connections) {
if (connection.getStatus().color == "red" && connection.alive) {
connection.die()
}
}
this.connections = this.connections.filter(c => c.alive)
rtc.sortConnections()
}
}
const golfObjectType = {
Start: "Start",
Hole: "Hole",
Lava: "Lava",
Cannon: "Cannon",
Eraser: "Eraser",
DuellHole1: "Hole 1",
DuellHole2: "Hole 2",
CustomWall: "Extra Wall",
GravityBox: "Gravity Box"
}
let golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Cannon]: Sprite.Cannon,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
class GolfObject {
static makeRandomUid() {
return Math.random().toString().slice(2)
}
constructor(type, pos, size, angle, uid, resizable) {
this.type = type
this.pos = pos ?? new Vector2d(0, 0)
this.size = size ?? new Vector2d(40, 40)
this.angle = angle ?? 0
this.uid = uid ?? GolfObject.makeRandomUid()
this.resizable = resizable ?? false
this.visibility = () => true
}
setPos(pos) {
this.pos = pos
return this
}
translate(point) {
this.pos.iadd(point)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
scale(scalar) {
this.pos.iscale(scalar)
this.size.iscale(scalar)
}
get topLeftPos() {
return this.pos.sub(this.size.scale(0.5).rotate(this.angle))
}
get relativeCorners() {
const halfSize = this.size.scale(0.5)
return [
halfSize.scale(-1),
halfSize.scaleY(-1),
halfSize,
halfSize.scaleX(-1)
].map(v => v.rotate(this.angle))
}
get corners() {
return this.relativeCorners.map(c => c.add(this.pos))
}
get walls() {
const corners = this.corners
return [
[corners[0], corners[1]],
[corners[1], corners[2]],
[corners[2], corners[3]],
[corners[3], corners[0]],
]
}
get dragCorner() {
return this.pos.sub(this.size.scale(0.6).rotate(this.angle))
}
intersects(point) {
const topLeft = this.topLeftPos.rotate(-this.angle)
const rotatedPoint = point.rotate(-this.angle)
return (
topLeft.x <= rotatedPoint.x && rotatedPoint.x <= (topLeft.x + this.size.x) &&
topLeft.y <= rotatedPoint.y && rotatedPoint.y <= (topLeft.y + this.size.y)
)
}
get radius() {
return this.topLeftPos.distance(this.pos)
}
set radius(newRadius) {
this.size = this.size.normalized.scale(newRadius * 2)
}
toObject() {
return {
t: this.type,
p: this.pos.toObject(),
s: this.size.toObject(),
a: this.angle,
u: this.uid,
r: this.resizable
}
}
static fromObject(obj) {
return new GolfObject(
obj.t ?? obj.type,
Vector2d.fromObject(obj.p ?? obj.pos),
Vector2d.fromObject(obj.s ?? obj.size),
obj.a ?? obj.angle,
obj.u ?? obj.uid,
obj.r ?? obj.resizable
)
}
get sprite() {
return golfObjectTypeSpriteMap[this.type]
}
copy() {
return GolfObject.fromObject(this.toObject())
}
setResizable(val) {
this.resizable = val
return this
}
setSize(size) {
this.size = size
return this
}
setAngle(angle) {
this.angle = angle
return this
}
setVisibility(func) {
this.visibility = func
return this
}
get name() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStart
case golfObjectType.Hole:
return Text.ObjectHole
case golfObjectType.Lava:
return Text.ObjectLava
case golfObjectType.Cannon:
return Text.ObjectCannon
case golfObjectType.Eraser:
return Text.ObjectEraser
case golfObjectType.DuellHole1:
return Text.ObjectDuellHole("1")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHole("2")
case golfObjectType.CustomWall:
return Text.ObjectCustomWall
case golfObjectType.GravityBox:
return Text.ObjectGravityBox
}
return ""
}
get description() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStartDescription
case golfObjectType.Hole:
return Text.ObjectHoleDescription
case golfObjectType.Lava:
return Text.ObjectLavaDescription
case golfObjectType.Cannon:
return Text.ObjectCannonDescription
case golfObjectType.Eraser:
return Text.ObjectEraserDescriptiom
case golfObjectType.DuellHole1:
return Text.ObjectDuellHoleDescription("<duell-player-1>")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHoleDescription("<duell-player-2>")
case golfObjectType.CustomWall:
return Text.ObjectCustomWallDescription
case golfObjectType.GravityBox:
return Text.ObjectGravityBoxDescription
}
return ""
}
static makeDefault(type) {
const obj = defaultObjects[type].copy()
obj.uid = GolfObject.makeRandomUid()
return obj
}
}
const placableObjects = [
new GolfObject(golfObjectType.Start),
new GolfObject(golfObjectType.Hole).setVisibility(gs => gs.mode != gameMode.Duell),
new GolfObject(golfObjectType.Lava).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.Cannon).setSize(new Vector2d(80, 80)),
new GolfObject(golfObjectType.CustomWall).setSize(new Vector2d(120, 40)).setResizable(true),
new GolfObject(golfObjectType.GravityBox).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.DuellHole1).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.DuellHole2).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.Eraser),
]
const defaultObjects = {
[golfObjectType.Start]: placableObjects[0],
[golfObjectType.Hole]: placableObjects[1],
[golfObjectType.Lava]: placableObjects[2],
[golfObjectType.Cannon]: placableObjects[3],
[golfObjectType.CustomWall]: placableObjects[4],
[golfObjectType.GravityBox]: placableObjects[5],
[golfObjectType.DuellHole1]: placableObjects[6],
[golfObjectType.DuellHole2]: placableObjects[7],
}
class ScoreboardMaker {
static scoreboardHeaderImgSrc = "../assets/scoreboard-header.png"
static async getImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
})
}
static drawLine(context, p1, p2, width=2, color="black") {
context.beginPath()
context.strokeStyle = color
context.lineWidth = width
context.moveTo(p1.x, p1.y)
context.lineTo(p2.x, p2.y)
context.stroke()
}
static async makeImg(players) {
const canvas = document.createElement("canvas")
const context = canvas.getContext("2d")
const headerImg = await this.getImg(this.scoreboardHeaderImgSrc)
const fontFamily = "Arial"
const fontSize = 40
context.font = `${fontSize}px ${fontFamily}`
const imagePadding = 20
const tablePadding = 20
const tableOffset = new Vector2d(0, 0)
const headerImgPadding = 40
const rowHeight = 30
const minNameWidth = context.measureText("00").width
const nameWidths = players.map(p => Math.max(context.measureText(p.name).width, minNameWidth))
const columnWidths = [context.measureText("000").width].concat(nameWidths)
const columnXs = []
const rowYs = []
let sum = 0
for (let i = 0; i < columnWidths.length; i++) {
columnXs.push(sum + tablePadding + tableOffset.x + imagePadding)
sum += columnWidths[i] + tablePadding * 2
}
const columnWidthSum = columnWidths.reduce((p, c) => p + c, 0)
const imgWidth = imagePadding * 2 + columnWidthSum + columnWidths.length * 2 * tablePadding
const headerImgWidth = Math.min(imgWidth - imagePadding * 2, 400)
const headerImgHeight = headerImgWidth * (headerImg.naturalHeight / headerImg.naturalWidth)
const imgHeight = imagePadding * 2 + headerImgHeight + headerImgPadding + (columnWidths.length + 1) * (rowHeight + tablePadding * 2)
for (let i = 0; i < columnWidths.length + 1; i++) {
rowYs.push(i * (rowHeight + tablePadding * 2) + tablePadding + imagePadding + headerImgHeight + headerImgPadding)
}
canvas.width = imgWidth
canvas.height = imgHeight
context.font = `${fontSize}px ${fontFamily}`
context.fillStyle = "white"
context.fillRect(0, 0, canvas.width, canvas.height)
context.drawImage(headerImg, imagePadding, imagePadding, headerImgWidth, headerImgHeight)
const tableContent = Array.from({length: rowYs.length})
.map(() => Array.from({length: columnXs.length}, () => ""))
tableContent[0][0] = "R#"
for (let i = 0; i < players.length; i++) {
tableContent[0][i + 1] = players[i].name
tableContent[players.length + 1][i + 1] = players[i].score.toString()
tableContent[i + 1][0] = "  " + (i + 1).toString()
for (let r = 0; r < players[i].roundScores.length; r++) {
const score = players[i].roundScores[r]
tableContent[r + 1][i + 1] = score.toString()
}
}
const tablePos = (r, c) => new Vector2d(columnXs[c], rowYs[r])
context.fillStyle = "black"
for (let colIndex = 0; colIndex < columnXs.length; colIndex++) {
for (let rowIndex = 0; rowIndex < rowYs.length; rowIndex++) {
const pos = tablePos(rowIndex, colIndex)
if (rowIndex == rowYs.length - 1) {
context.font = `bold ${fontSize}px ${fontFamily}`
} else {
context.font = `${fontSize}px ${fontFamily}`
}
context.fillText(tableContent[rowIndex][colIndex], pos.x, pos.y)
}
}
for (let i = 0; i < players.length - 1; i++) {
this.drawLine(context,
tablePos(i + 1, 1).addY(tablePadding).addX(-tablePadding),
tablePos(i + 1, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 2, "#ccc")
this.drawLine(context,
tablePos(1, i + 2).addX(-tablePadding).addY(-rowHeight - tablePadding),
tablePos(players.length, i + 2).addX(-tablePadding)
.addY(tablePadding * 2 + rowHeight), 2, "#ccc")
}
this.drawLine(context,
tablePos(0, 0).addY(tablePadding),
tablePos(0, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 3)
this.drawLine(context,
tablePos(players.length, 0).addY(tablePadding),
tablePos(players.length, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 3)
this.drawLine(context,
tablePos(0, 1).addX(-tablePadding).addY(-rowHeight),
tablePos(players.length, 1).addX(-tablePadding)
.addY(tablePadding * 2 + rowHeight), 3)
for (let i = 0; i < players.length; i++) {
}
return canvas.toDataURL()
}
}
class BoardGenerator {
constructor(screenSizes) {
this.screenSizes = screenSizes
}
generateLinearCourse() {
const phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
const course = new Course([phones.shift()])
while (phones.length) {
const prevPhone = course.phones.slice(-1)[0]
const phone = phones.shift()
const bottomMidX = (prevPhone.bottomLeft.x + prevPhone.bottomRight.x) / 2
const topMidX = (phone.topLeft.x + phone.topRight.x) / 2
phone.translate(new Vector2d(bottomMidX - topMidX, prevPhone.maxXY.y))
course.addPhone(phone)
}
return course
}
getConnectingLines(prevPhone, phone) {
return [
new PhoneConnectionLine(
new Vector2d(0, 0),
new Vector2d(Math.min(prevPhone.size.x, phone.size.x), 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, 0),
new Vector2d(prevPhone.size.x, Math.min(phone.size.y, prevPhone.size.y))
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.maxXY.x - phone.maxXY.x, 0), prevPhone.size.y),
new Vector2d(prevPhone.size.x, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, Math.max(0, prevPhone.maxXY.y - phone.maxXY.y)),
new Vector2d(0, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.maxXY.x - phone.maxXY.x, 0), 0),
new Vector2d(prevPhone.size.x, 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, Math.max(0, prevPhone.maxXY.y - phone.maxXY.y)),
new Vector2d(prevPhone.size.x, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, prevPhone.size.y),
new Vector2d(Math.min(prevPhone.size.x, phone.size.x), prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, 0),
new Vector2d(0, Math.min(phone.size.y, prevPhone.size.y))
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, 0),
new Vector2d(prevPhone.size.x - Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2),
new Vector2d(prevPhone.size.x, prevPhone.size.y - Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2)
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, prevPhone.size.y),
new Vector2d(prevPhone.size.x - Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2),
new Vector2d(0, prevPhone.size.y - Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2)
),
]
}
getPhoneAlignOptions(prevPhone, phone) {
return [
new Vector2d(0, -phone.size.y),
new Vector2d(prevPhone.size.x, 0),
new Vector2d(prevPhone.maxXY.x - phone.maxXY.x, prevPhone.size.y),
new Vector2d(-phone.size.x, prevPhone.maxXY.y - phone.maxXY.y),
new Vector2d(prevPhone.maxXY.x - phone.maxXY.x, -phone.size.y),
new Vector2d(prevPhone.size.x, prevPhone.maxXY.y - phone.maxXY.y),
new Vector2d(0, prevPhone.size.y),
new Vector2d(-phone.size.x, 0),
new Vector2d(
(prevPhone.minXY.x + prevPhone.maxXY.x
- phone.minXY.x - phone.maxXY.x) / 2,
-phone.size.y
),
new Vector2d(
prevPhone.size.x,
(prevPhone.minXY.y + prevPhone.maxXY.y
- phone.minXY.y - phone.maxXY.y) / 2,
),
new Vector2d(
(prevPhone.minXY.x + prevPhone.maxXY.x
- phone.minXY.x - phone.maxXY.x) / 2,
prevPhone.size.y
),
new Vector2d(
-phone.size.x,
(prevPhone.minXY.y + prevPhone.maxXY.y
- phone.minXY.y - phone.maxXY.y) / 2,
),
]
}
getStartHolePositions(phone) {
return [
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0),
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0),
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0)
]
}
generateRandomCourse({linear=false}={}) {
let phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
let course = new Course([phones.shift()])
course.alignOptions = []
let phoneTries = 0
let totalTries = 0
while (phones.length) {
const prevPhone = course.phones.slice(-1)[0]
const phone = phones.shift()
if ((!linear && Math.random() < 0.5) || (linear && phone.size.x > phone.size.y)) {
phone.rotate(Math.PI / 2)
}
phone.translate(prevPhone.minXY.sub(phone.minXY))
const translateOptions = this.getPhoneAlignOptions(prevPhone, phone)
let alignOption = Math.floor(Math.random() * translateOptions.length)
if (linear) alignOption = 10
course.alignOptions.push(alignOption)
const lineOptions = this.getConnectingLines(prevPhone, phone)
course.addLine(lineOptions[alignOption].translate(phone.minXY))
phone.translate(translateOptions[alignOption])
course.addPhone(phone)
const previousPhones = course.phones.slice(0, -2)
const overlapsPrevious = previousPhones.some(p => {
return p.hasOverlap(phone)
})
if (overlapsPrevious) {
phones.unshift(course.phones.pop())
course.alignOptions.pop()
course.lines.pop()
phoneTries++
} else {
phoneTries = 0
}
if (phoneTries > 20) {
phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
course.alignOptions = []
course.phones = [phones.shift()]
course.lines = []
phoneTries = 0
totalTries++
}
if (totalTries > 10000) {
throw new Error("Couldn't generate course [too many tries]")
}
}
return course
}
placeStartAndHole(board) {
const start = defaultObjects[golfObjectType.Start].copy()
const hole = defaultObjects[golfObjectType.Hole].copy()
if (board.course.phones.length > 1) {
const firstAlignOption = board.course.alignOptions[0]
let lastAlignOption = board.course.alignOptions.slice(-1)[0]
lastAlignOption = Math.floor(lastAlignOption / 4) * 4 + ((lastAlignOption + 2) % 4)
const translateStartOptions = this.getStartHolePositions(board.course.phones[0])
const translateHoleOptions = this.getStartHolePositions(board.course.phones.slice(-1)[0])
const firstMiddle = calcAveragePos(board.course.phones[0].points)
const lastMiddle = calcAveragePos(board.course.phones.slice(-1)[0].points)
start.setPos(firstMiddle.add(translateStartOptions[firstAlignOption]))
hole.setPos(lastMiddle.add(translateHoleOptions[lastAlignOption]))
} else {
const middle = calcAveragePos(board.course.phones[0].points)
const delta = middle.sub(board.course.phones[0].corners[0]).scale(0.6)
start.setPos(middle.sub(delta))
hole.setPos(middle.add(delta))
}
board.objects.push(start, hole)
}
generate() {
const board = new Board()
board.course = this.generateRandomCourse({linear: Math.random() < 0.1})
this.placeStartAndHole(board)
return board
}
static async placeObjectsRandomly(board, {
objectType = golfObjectType.Lava,
maxTries = 10,
numObjects = 3
}={}) {
function kickAllBallsRandom() {
for (const ball of board.balls) {
const speed = 100 + Math.random() * 50
const angle = Math.random() * Math.PI * 2
const dir = Vector2d.fromAngle(angle).scale(speed)
ball.kick(dir)
}
}
async function testWithBalls({
numBalls = 100,
numKicks = board.course.phones.length * 2,
stepsPerKick = 100
}={}) {
if (!board.startPos || board.endPositions.length == 0) {
return true
}
const prevBallCollisionEnabled = board.ballCollisionEnabled
board.ballCollisionEnabled = false
let balls = []
for (let i = 0; i < numBalls; i++) {
const ball = board.spawnBall()
balls.push(ball)
}
for (let n = 0; n < numKicks; n++) {
board.addPhysicsEvent(kickAllBallsRandom, n * stepsPerKick + 1)
}
for (let i = 0; i < numKicks; i++) {
board.simulateStepsEfficiently(stepsPerKick)
await new Promise(resolve => setTimeout(resolve, 0))
}
board.ballCollisionEnabled = prevBallCollisionEnabled
const success = balls.some(b => b.inHole)
const ballUids = balls.map(b => b.uid)
board.balls = board.balls.filter(b => !ballUids.includes(b.uid))
return success
}
function getRandomCoursePos() {
let randomPhone = undefined
const areaSum = board.course.phones.reduce((p, c) => p + c.area, 0)
const r = Math.random() * areaSum
let cumulativeSum = 0
for (const phone of board.course.phones) {
cumulativeSum += phone.area
if (cumulativeSum >= r) {
randomPhone = phone
break
}
}
console.assert(randomPhone !== undefined)
return randomPhone.randomPosInside()
}
for (let i = 0; i < maxTries; i++) {
const addedObjectUids = []
for (let i = 0; i < numObjects; i++) {
const randomLava = GolfObject.makeDefault(objectType)
randomLava.setPos(getRandomCoursePos())
randomLava.setAngle(Math.random() * 2 * Math.PI)
randomLava.setSize(randomLava.size.scale(0.8 + Math.random() * 0.4))
board.objects.push(randomLava)
addedObjectUids.push(randomLava.uid)
}
if (await testWithBalls()) {
return true
} else {
board.objects = board.objects.filter(o => !addedObjectUids.includes(o.uid))
}
}
return false
}
}
class AudioPlayer {
static spriteAudioMap = {}
static spriteIndexMap = {}
static soundsEnabled = true
static speechEnabled = true
static loadAudio(src) {
return new Promise((resolve, reject) => {
const element = document.createElement("audio")
element.style.display = "none"
document.body.appendChild(element)
element.addEventListener("canplaythrough", resolve)
element.addEventListener("error", reject)
element.src = src
element.preload = "true"
element.load()
this.spriteAudioMap[src].push(element)
setTimeout(resolve, 500)
})
}
static hasLoaded = false
static async load() {
if (this.hasLoaded) {
return
}
for (const src of Object.values(AudioSprite)) {
this.spriteAudioMap[src] = []
this.spriteIndexMap[src] = 0
}
const promises = []
for (let i = 0; i < 5; i++) {
promises.push(...Object.values(AudioSprite).map(s => this.loadAudio(s)))
}
await Promise.all(promises)
this.hasLoaded = true
}
static play(sprite, {volume=1.}={}) {
if (!this.soundsEnabled || !this.hasLoaded) {
return
}
if (!this.spriteAudioMap[sprite]) {
return
}
this.load()
const audios = this.spriteAudioMap[sprite]
const index = (this.spriteIndexMap[sprite]++) % audios.length
const audio = audios[index]
if (!audio) {
return
}
audio.volume = volume
return audio.play()
}
static randomNote({volume=1.}={}) {
const index = Math.floor(Math.random() * allNoteSprites.length)
return this.play(allNoteSprites[index], {volume: volume})
}
static plop() {
return this.play(AudioSprite.Plop)
}
static say(text, {rate = 1., lang="de-DE"}={}) {
if (!this.speechEnabled || !window.speechSynthesis) {
return
}
const message = new SpeechSynthesisUtterance()
message.text = text
message.rate = rate
message.lang = lang
window.speechSynthesis.speak(message)
}
}
let gameState = new GameState(
gamePhase.Hello,
gameMode.None,
new Board()
)
function updateHtmlSection(phase) {
for (let section of document.querySelectorAll("main > section[data-phase]")) {
if (section.dataset.phase == gamePhaseNames[phase]) {
section.style.display = "grid"
section.classList.add("visible")
} else {
section.style.display = "none"
section.classList.remove("visible")
}
}
const fillPlaceholders = (attr, value) => {
for (let element of document.querySelectorAll("[data-fill]")) {
if (element.dataset.fill == attr) {
element.textContent = value
}
}
}
fillPlaceholders("num-connected-devices", rtc?.connections.length)
fillPlaceholders("tournament-builder-name", gameState.tournamentBuilder?.name)
fillPlaceholders("tournament-active-name", gameState.tournamentActivePlayer?.name)
fillPlaceholders("tournament-max-kicks", gameState.tournamentMaxKicks)
fillPlaceholders("duell-active-name", gameState.duellActivePlayer?.name)
fillPlaceholders("duell-inactive-name", gameState.duellInactivePlayer?.name)
fillPlaceholders("duell-winner-name", gameState.duellWinner?.name)
}
async function generateScoreboard() {
const scoreboardSrc = await ScoreboardMaker.makeImg(gameState.players)
for (let element of document.querySelectorAll("img.scoreboard")) {
element.src = scoreboardSrc
}
}
async function shareScoreboard() {
const scoreboardSrc = await ScoreboardMaker.makeImg(gameState.players)
const blob = await (await fetch(scoreboardSrc)).blob()
const file = new File([blob], 'multigolf2-scoreboard.png', {type: blob.type})
navigator.share({
title: Text.MultigolfScoreboard,
text: Text.ShareText,
files: [file],
})
}
let setBeforeUnloadListener = false
function changeGamePhase(newPhase, force=false) {
if (!setBeforeUnloadListener) {
addEventListener("beforeunload", event => {
event.preventDefault()
return Text.LeavingWarning
})
}
if (gameState.phase >= newPhase && !force) {
return
}
gameState.phase = newPhase
updateHtmlSection(newPhase)
if (newPhase == gamePhase.ConstructionChoice) {
const hasLayout = gameState.board.course.phones.length > 0
keepLayoutButton.style.display = hasLayout ? "block" : "none"
} else if (newPhase == gamePhase.ConstructionAuto) {
generateBoardTemplates()
} else if (newPhase == gamePhase.ConstructionCustom) {
gameState.board.resetConfig()
} else if (newPhase == gamePhase.ConfigGame) {
generateConfigHtml()
}
headerElement.scrollIntoView({behavior: "smooth"})
}
function chooseGamemode(mode) {
if (gameState.phase != gamePhase.ModeChoice) {
return
}
gameState.tournamentBuilderIndex = 0
if (gameState.board.endPositions.length == 2) {
gameState.board.endPositions = gameState.board.endPositions.slice(1)
}
gameState.mode = mode
if (mode == gameMode.Sandbox) {
startConnectionProcess()
} else if (mode == gameMode.Tournament) {
changeGamePhase(gamePhase.PlayerSetupTournament)
} else if (mode == gameMode.Duell) {
changeGamePhase(gamePhase.PlayerSetupDuell)
}
}
function registerPlayers() {
if (![gamePhase.PlayerSetupDuell, gamePhase.PlayerSetupTournament].includes(gameState.phase)) {
return
}
const isValidName = name => {
if (name.length > 30) {
customAlert(Text.NameTooLong(name.slice(0, 30)))
return false
}
return name
}
const players = []
const nameInputs = document.querySelectorAll(`input[data-game-mode="${gameState.mode}"]`)
for (let nameInput of nameInputs) {
const name = nameInput.value.trim()
if (!name) {
continue
}
if (isValidName(name)) {
players.push(new Player(name))
} else {
return
}
}
if (gameState.mode == gameMode.Duell && players.length != 2) {
customAlert(Text.PleaseFillOutFields)
return
}
if (gameState.mode == gameMode.Tournament && players.length == 0) {
customAlert(Text.FilloutOneName)
return
}
const playerNames = new Set()
for (let player of players) {
const n = player.name.toLowerCase()
if (playerNames.has(player.name)) {
customAlert(Text.TwoPlayersSameName)
return
}
playerNames.add(n)
}
gameState.players = players
startConnectionProcess()
}
const gameConfigSettings = [
{
name: Text.DeviceGravity,
description: Text.DeviceGravityDescription,
warning: Text.DeviceGravityWarning,
getValue: () => gameState.board.deviceGravityEnabled,
setValue: val => gameState.board.deviceGravityEnabled = val,
type: "boolean",
showIf: () => true
},
{
name: Text.BallCollisions,
description: Text.BallCollisionsDescription,
getValue: () => gameState.board.ballCollisionEnabled,
setValue: val => gameState.board.ballCollisionEnabled = val,
type: "boolean",
showIf: () => [gameMode.Sandbox, gameMode.Tournament].includes(gameState.mode)
},
{
name: Text.Soundeffects,
description: Text.SoundeffectsDescription,
getValue: () => AudioPlayer.soundsEnabled,
setValue: val => AudioPlayer.soundsEnabled = val,
type: "boolean",
showIf: () => true
},
{
name: Text.ReadNames,
description: Text.ReadNamesDescription,
getValue: () => AudioPlayer.speechEnabled,
setValue: val => AudioPlayer.speechEnabled = val,
type: "boolean",
showIf: () => gameState.mode == gameMode.Tournament
},
{
name: Text.MaximumKicksPerRound,
description: Text.MaximumKicksPerRoundDescription,
getValue: () => gameState.tournamentMaxKicks,
setValue: val => gameState.tournamentMaxKicks = val,
type: "integer", min: 1, max: 100,
showIf: () => gameState.mode == gameMode.Tournament
}
]
async function generateConfigHtml() {
gameConfigContainer.innerHTML = ""
for (const setting of gameConfigSettings) {
if (!setting.showIf()) continue
const container = document.createElement("div")
const titleRow = document.createElement("div")
titleRow.classList.add("titlerow")
const name = document.createElement("div")
name.textContent = setting.name
name.classList.add("name")
const inputContainer = document.createElement("div")
inputContainer.classList.add("input-container")
let inputElement = null
if (setting.type == "boolean") {
inputElement = document.createElement("input")
inputElement.type = "checkbox"
inputElement.checked = setting.getValue()
inputElement.onchange = () => {
setting.setValue(inputElement.checked)
}
} else if (setting.type == "integer") {
inputElement= document.createElement("input")
inputElement.type = "number"
inputElement.value = setting.getValue()
inputElement.min = setting.min
inputElement.max = setting.max
inputElement.oninput = () => {
const stringValue = inputElement.value.trim()
if (/^-?[0-9]+$/.test(stringValue)) {
inputElement.style.color = "black"
} else {
inputElement.style.color = "red"
return
}
const value = parseInt(stringValue)
if ((setting.min ?? -Infinity) > value
|| (setting.max ?? Infinity) < value
) {
inputElement.style.color = "red"
return
}
setting.setValue(value)
}
} else {
throw new Error(`Unknown Setting type "${setting.type}"`)
}
const description = document.createElement("div")
description.textContent = setting.description
description.classList.add("description")
container.appendChild(titleRow)
titleRow.appendChild(name)
inputContainer.appendChild(inputElement)
titleRow.appendChild(inputContainer)
container.appendChild(description)
if (setting.warning) {
const warning = document.createElement("div")
warning.textContent = setting.warning
warning.classList.add("warning")
container.appendChild(warning)
}
gameConfigContainer.appendChild(container)
}
}
async function generateBoardTemplates() {
if (gameState.phase != gamePhase.ConstructionAuto) {
return
}
layoutChoiceContainer.innerHTML = ""
const displaySizes = rtc.connections.map(r => r.clientDisplaySize).filter(r => r != null)
if (displaySizes.length == 0) return
const boardGenerator = new BoardGenerator(displaySizes)
for (let i = 0; i < 3; i++) {
const layoutContainer = document.createElement("div")
layoutContainer.classList.add("layout-choice")
const canvas = document.createElement("canvas")
const context = canvas.getContext("2d")
const button = document.createElement("button")
button.textContent = "Choose Layout"
const boardOption = boardGenerator.generate()
setTimeout(() => {
BoardRenderer.render(boardOption, context, {drawConnectionLines: true})
}, 100)
button.onclick = () => {
gameState.board = boardOption.copy()
finishConstruction()
}
layoutContainer.appendChild(canvas)
layoutContainer.appendChild(button)
layoutChoiceContainer.appendChild(layoutContainer)
}
}
function playNewGame() {
changeGamePhase(gamePhase.ModeChoice, true)
}
function syncGamestate(rtcs) {
rtcs ??= rtc.connections
for (const rtc of rtcs) {
const message = new DataMessage(
dataMessageType.GAMESTATE,
gameState.toObject(rtc.index))
rtc.sendMessage(message)
}
}
function physicsLoop() {
if (gameState.update()) {
syncGamestate()
updateHtmlSection(gameState.phase)
}
window.requestAnimationFrame(physicsLoop)
}
function onDataMessage(dataMessage, rtc) {
if (dataMessage.type == dataMessageType.PING) {
if (rtc.receivePing(dataMessage) && gameState.phase == gamePhase.ConstructionAuto) {
generateBoardTemplates()
}
} else if (
gameState.phase == gamePhase.ConstructionCustom &&
dataMessage.type == dataMessageType.CONSTRUCTION_LINE
) {
const constructionLine = ConstructionLine.fromObject(dataMessage.data.line)
const phoneModel = PhoneCoordinates.fromObject(dataMessage.data.phone)
gameState.board.addConstructionLine(
constructionLine, phoneModel,
Date.now(), rtc.index
)
} else if (
gameState.phase == gamePhase.Loading &&
dataMessage.type == dataMessageType.SEND_DIMENSIONS
) {
gameState.board.course = Course.fromObject(dataMessage.data.course)
gameState.phase = gamePhase.ConstructionAuto
finishConstruction()
} else if (
gameState.phase == gamePhase.Placing &&
dataMessage.type == dataMessageType.PLACE_OBJECT
) {
const object = GolfObject.fromObject(dataMessage.data.object)
if (object.type == golfObjectType.Start) {
gameState.board.objects = gameState.board.objects.filter(o => o.type != golfObjectType.Start)
}
gameState.board.objects.push(object)
syncGamestate()
} else if (
gameState.phase == gamePhase.Placing &&
dataMessage.type == dataMessageType.REMOVE_OBJECT
) {
gameState.board.objects = gameState.board.objects.filter(o => o.uid != dataMessage.data.uid)
syncGamestate()
} else if (
gameState.phase == gamePhase.Placing &&
dataMessage.type == dataMessageType.CHANGE_OBJECT
) {
const changedObject = GolfObject.fromObject(dataMessage.data.object)
gameState.board.updateObject(changedObject)
syncGamestate()
} else if (
gamePhase.isPlaying(gameState.phase) &&
dataMessage.type == dataMessageType.KICK_BALL
) {
const ball = gameState.board.balls.find(b => b.uid == dataMessage.data.ballUid)
if (ball) {
if (gameState.mode == gameMode.Tournament) {
gameState.onTournamentKick(ball)
}
ball.kick(Vector2d.fromObject(dataMessage.data.direction))
updateHtmlSection(gameState.phase)
} else {
console.error("Couldn't find ball with id", dataMessage.data.ballUid)
}
syncGamestate()
} else if (
dataMessage.type == dataMessageType.DEVICE_ORIENTATION
) {
if (gamePhase.isPlaying(gameState.phase)) {
const gravity = Vector2d.fromObject(dataMessage.data)
if (Math.abs(gravity.x) < 0.1) gravity.x = 0
if (Math.abs(gravity.y) < 0.1) gravity.y = 0
const phone = gameState.board.course.phones[dataMessage.data.deviceIndex - 1]
if (phone) {
phone.gravity = gravity
syncGamestate()
} else {
console.log(`[Warning] Tried updating phone gravity of index ${dataMessage.data.deviceIndex}`)
}
}
} else {
console.log("received unknown message", dataMessage)
}
}
function onRtcReconnect(rtc) {
updatePlayerlist()
syncGamestate([rtc])
}
let renderingIntervalIsSet = false
let isPhysicsLoopRunning = false
async function startGame() {
if (!renderingIntervalIsSet) {
setInterval(() => {
if (gameState.board.course.phones.length > 0) {
boardCanvasFieldset.style.display = "grid"
BoardRenderer.render(gameState.board, boardContext, {
drawConnectionLines: gameState.phase >= gamePhase.ConstructionChoice && gameState.phase <= gamePhase.Placing
})
} else {
boardCanvasFieldset.style.display = "none"
}
if (!gameState.board.balls.some(b => b.isMoving())) {
syncGamestate()
}
if (gameState.phase == gamePhase.PlayingTournament) {
generateScoreboard()
}
}, 500)
renderingIntervalIsSet = true
}
if (!isPhysicsLoopRunning) {
physicsLoop()
isPhysicsLoopRunning = true
}
if (rtc.connections.length == 1) {
changeGamePhase(gamePhase.Loading, true)
syncGamestate()
rtc.connections[0].sendMessage(new DataMessage(
dataMessageType.REQUEST_DIMENSIONS))
} else {
changeGamePhase(gamePhase.ConstructionChoice, true)
}
syncGamestate()
}
async function finishConstruction() {
if (![
gamePhase.ConstructionChoice,
gamePhase.ConstructionAuto,
gamePhase.ConstructionCustom
].includes(gameState.phase)) {
return
}
if (gameState.board.course.phones.length == 0) {
return customAlert(Text.NotConstructedYet)
}
if (gameState.board.course && gameState.board.course.getOverlaps().length > 0) {
if (!(await customConfirm(Text.CourseHasOverlap))) {
return
}
}
changeGamePhase(gamePhase.Placing)
preparePlacing()
syncGamestate()
}
let busyPlacingObjects = false
function placeRandomObjects(numObjects, objectType) {
if (gameState.phase != gamePhase.Placing || busyPlacingObjects) {
return
}
busyPlacingObjects = true
BoardGenerator.placeObjectsRandomly(gameState.board, {numObjects, objectType}).then(() => busyPlacingObjects = false)
}
function preparePlacing() {
for (const container of document.querySelectorAll(".object-selection-container")) {
container.innerHTML = ""
const allObjectContainers = []
for (const obj of placableObjects) {
if (!obj.visibility(gameState)) {
continue
}
const object = document.createElement("div")
const title = document.createElement("div")
const headImg = document.createElement("div")
const objectImg = document.createElement("img")
const description = document.createElement("div")
object.classList.add("object")
title.classList.add("title")
headImg.classList.add("head-img")
description.classList.add("description")
title.textContent = obj.name
objectImg.src = obj.sprite
description.textContent = gameState.replaceText(obj.description)
headImg.appendChild(objectImg)
object.appendChild(title)
object.appendChild(headImg)
object.appendChild(description)
if (gameState.placingObjectType == obj.type) {
object.classList.add("selected")
}
object.addEventListener("click", () => {
for (let element of allObjectContainers) {
element.classList.remove("selected")
}
object.classList.add("selected")
gameState.placingObjectType = obj.type
syncGamestate()
})
container.appendChild(object)
allObjectContainers.push(object)
}
}
}
function finishPlacing() {
if (gameState.phase != gamePhase.Placing) {
return
}
if (!gameState.board.startPos) {
customAlert(Text.NoStartYet)
return
}
if (gameState.board.endPositions.length == 0) {
customAlert(Text.NoHoleYet)
return
}
if (gameState.mode == gameMode.Duell) {
if (!gameState.board.objects.find(o => o.type == golfObjectType.DuellHole1)) {
customAlert(Text.HaventPlacedHoleFor(gameState.replaceText("<duell-player-1>")))
return
}
if (!gameState.board.objects.find(o => o.type == golfObjectType.DuellHole2)) {
customAlert(Text.HaventPlacedHoleFor(gameState.replaceText("<duell-player-2>")))
return
}
}
startPlaying()
}
function startPlaying() {
if (gameState.phase >= gamePhase.__LOWEST_PLAYING) {
return
}
switch(gameState.mode) {
case gameMode.Duell:
changeGamePhase(gamePhase.PlayingDuell)
gameState.startDuellRound()
break
case gameMode.Sandbox:
changeGamePhase(gamePhase.PlayingSandbox)
gameState.startSandboxRound()
break
case gameMode.Tournament:
changeGamePhase(gamePhase.PlayingTournament)
gameState.startTournamentRound()
break
}
syncGamestate()
}
function back() {
switch (gameState.phase) {
case gamePhase.ModeChoice:
return changeGamePhase(gamePhase.Hello, true)
case gamePhase.PlayerSetupTournament:
return changeGamePhase(gamePhase.ModeChoice, true)
case gamePhase.PlayerSetupDuell:
return changeGamePhase(gamePhase.ModeChoice, true)
case gamePhase.Connecting:
if (gameState.mode == gameMode.Tournament) {
return changeGamePhase(gamePhase.PlayerSetupTournament, true)
} else if (gameState.mode == gameMode.Duell) {
return changeGamePhase(gamePhase.PlayerSetupDuell, true)
} else {
return changeGamePhase(gamePhase.ModeChoice, true)
}
case gamePhase.ConfigGame:
return changeGamePhase(gamePhase.Connecting, true)
case gamePhase.TournamentExplanation:
case gamePhase.DuellExplanation:
return changeGamePhase(gamePhase.ConfigGame, true)
case gamePhase.ConstructionChoice:
if (gameState.mode == gameMode.Tournament) {
return changeGamePhase(gamePhase.TournamentExplanation, true)
} else if (gameState.mode == gameMode.Duell) {
return changeGamePhase(gamePhase.DuellExplanation, true)
} else {
return changeGamePhase(gamePhase.ConfigGame, true)
}
case gamePhase.ConstructionAuto:
case gamePhase.ConstructionCustom:
return changeGamePhase(gamePhase.ConstructionChoice, true)
case gamePhase.Placing:
if (rtc.connections.length == 1) {
if (gameState.mode == gameMode.Tournament) {
return changeGamePhase(gamePhase.TournamentExplanation, true)
} else if (gameState.mode == gameMode.Duell) {
return changeGamePhase(gamePhase.DuellExplanation, true)
} else {
return changeGamePhase(gamePhase.ConfigGame, true)
}
} else {
return changeGamePhase(gamePhase.ConstructionChoice, true)
}
}
}
const logOutput = document.querySelector("#log-output")
const qrImg = document.querySelector("#qr-img")
const playerListContainer = document.querySelector("#player-list-container")
const finishPlayersButton = document.querySelector("#finish-players-button")
const boardCanvas = document.querySelector("#board-canvas")
const boardContext = boardCanvas.getContext("2d")
const boardCanvasFieldset = document.querySelector("#board-canvas-fieldset")
const playerListFieldset = document.querySelector("#player-list-fieldset")
const layoutChoiceContainer = document.querySelector("#layout-choice-container")
const gameConfigContainer = document.querySelector("#game-config-container")
const keepLayoutButton = document.querySelector("#keep-layout-button")
const headerElement = document.querySelector("header")
function logToConnectionLog(message) {
if (logOutput.textContent.length > 0) {
logOutput.textContent += "\n"
}
logOutput.textContent += message
}
let rtc = null
function updatePlayerlist() {
if (!rtc) {
return
}
playerListFieldset.style.display = "grid"
playerListContainer.innerHTML = ""
if (rtc.connections.length == 0) {
playerListContainer.textContent = Text.OnceYouConnectPlayers
}
for (let i = 0; i < rtc.connections.length; i++) {
const playerContainer = document.createElement("div")
playerContainer.classList.add("player-status-container")
const circularIndicator = document.createElement("div")
circularIndicator.classList.add("circle-indicator")
const playerNameElement = document.createElement("div")
playerNameElement.classList.add("player-name")
playerContainer.appendChild(circularIndicator)
playerContainer.appendChild(playerNameElement)
const connection = rtc.connections[i]
playerNameElement.textContent = Text.DeviceNum(connection.index)
const connectionStatus = connection.getStatus()
circularIndicator.classList.add(connectionStatus.color)
playerContainer.title = connectionStatus.message ?? ""
playerListContainer.appendChild(playerContainer)
}
}
async function finishPlayers() {
if (gameState.phase != gamePhase.Connecting) return
if (rtc.connections.length == 0) {
customAlert(Text.NoDevicesError)
return
}
updatePlayerlist()
changeGamePhase(gamePhase.ConfigGame)
}
async function finishConfig() {
if (gameState.phase != gamePhase.ConfigGame) return
if (gameState.mode == gameMode.Tournament) {
changeGamePhase(gamePhase.TournamentExplanation)
} else if (gameState.mode == gameMode.Duell) {
changeGamePhase(gamePhase.DuellExplanation)
} else {
startGame()
}
}
let setUpdatePlayerListInterval = false
function startConnectionProcess() {
if (gameState.phase >= gamePhase.Connecting) {
return
}
if (!setUpdatePlayerListInterval) {
setInterval(() => {
updatePlayerlist()
if (rtc && gameState.phase == gamePhase.Connecting) {
rtc.removeLostConnections()
}
}, 1000)
setUpdatePlayerListInterval = true
}
updatePlayerlist()
changeGamePhase(gamePhase.Connecting)
if (!rtc) {
rtc = new RtcHostManager({
logFunction: (message) => {
logToConnectionLog(message)
},
onClientUrlAvailable: async (clientUrl) => {
if (new URLSearchParams(location.search).has("debug")) {
console.log("QR CODE URL", clientUrl + "&nofullscreen")
console.log("QR CODE URL DEBUG", clientUrl.replace("https://multi.golf", "localhost:8000") + "&nofullscreen")
}
qrImg.innerHTML = "" // clear current qr code
new QRCode(qrImg, clientUrl)
},
onDataMessage: (message, connection) => {
onDataMessage(message, connection)
},
allowConnectionOverride: () => gameState.phase == gamePhase.Connecting
})
rtc.start()
fetch("https://www.noel-friedrich.de/multigolf2/api/count_start.php")
}
}
updateHtmlSection(gameState.phase)
const noSleep = new NoSleep()
document.addEventListener("click", function enableNoSleep() {
document.removeEventListener("click", enableNoSleep, false)
noSleep.enable()
}, false)
async function main() {
await BoardRenderer.load()
window.AudioPlayer = AudioPlayer
window.AudioPlayer.load()
document.querySelector("#loading-indicator").style.display = "none"
}
main()
const feedbackForms = document.querySelectorAll(".feedback-form")
for (const formContainer of feedbackForms) {
const textarea = formContainer.querySelector("textarea")
const submitButton = formContainer.querySelector("button")
let busy = false
submitButton.addEventListener("click", async () => {
const feedbackText = textarea.value
if (feedbackText.length == 0 || busy) {
return
}
if (feedbackText.length > 1000) {
return alert(Text.FeedbackTooLong)
}
buse = true
const formData = new FormData()
formData.append("message", feedbackText)
const response = await fetch("https://www.noel-friedrich.de/multigolf2/api/give_feedback.php", {
method: "POST", body: formData })
const data = await response.json()
if (data.ok) {
const successText = document.createElement("p")
successText.classList.add("success")
successText.textContent = Text.ThanksForFeedback
formContainer.appendChild(successText)
} else {
const errorText = document.createElement("p")
errorText.classList.add("error")
errorText.textContent = data.error
formContainer.appendChild(errorText)
}
textarea.remove()
submitButton.remove()
})
}
