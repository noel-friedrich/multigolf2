const Lang = {
DE: "Deutsch",
EN: "English",
get() {
return document.documentElement.lang == "en"
? Lang.EN : Lang.DE
}
}
const Text = {
ConnectionFailed: {
[Lang.EN]: "Connection failed.",
[Lang.DE]: "Verbindung fehlgeschlagen.",
},
TryingAgainInSeconds: seconds => ({
[Lang.EN]: `⌛ Trying again in ${seconds} seconds.`,
[Lang.DE]: `⌛ Versuche nochmal in ${seconds} sekunden`
}),
TryingAgainIn10: {
[Lang.EN]: "⌛ Trying again in 10 seconds.",
[Lang.DE]: "⌛ Versuche nochmal in 10 sekunden"
},
ConnectingToHost: {
[Lang.EN]: "Connecting to Host...",
[Lang.DE]: "Verbinde zu Server..."
},
ConnectedToHost: {
[Lang.EN]: "Connected to Host.",
[Lang.DE]: "Verbindung erfolgreich."
},
ConnectionEstablished: {
[Lang.EN]: "✅ Connection established.",
[Lang.DE]: "✅ Verbindung erfolgreich.",
},
ConnectionDied: {
[Lang.EN]: "❌ Connection died",
[Lang.DE]: "❌ Verbindung abgebrochen.",
},
CouldNotConnect: {
[Lang.EN]: "❌ Could not connect to Host.",
[Lang.DE]: "❌ Verbindung fehlgeschlagen.",
},
CreatedPool: poolUid => ({
[Lang.EN]: `✅ Created Game (${poolUid})`,
[Lang.DE]: `✅ Spiel erstellt (${poolUid})`
}),
InitializingPeerToPeer: {
[Lang.EN]: "🫂 Initializing Peer-To-Peer...",
[Lang.DE]: "🫂 Verbindung wird aufgebaut...",
},
SuccessfullySentObject: objName => ({
[Lang.EN]: `✅ ${objName} successfully sent.`,
[Lang.DE]: `✅ ${objName} gesendet.`,
}),
FailedSendingObject: (name, err) => ({
[Lang.EN]: `⚠️ Couldn't upload ${name}: ${err}`,
[Lang.EN]: `⚠️ Upload von ${name} fehlgeschlagen: ${err}`,
}),
CouldntFetchServer: err => ({
[Lang.EN]: `❌ Couldn't fetch Server: ${err}`,
[Lang.DE]: `❌ Server blöd: ${err}`,
}),
GoodConnection: {
[Lang.EN]: "Good Connection",
[Lang.DE]: "Gute Verbindung"
},
ConnectionBeingInitialized: {
[Lang.EN]: "Connection is being initialized",
[Lang.DE]: "Verbindung wird hergestellt"
},
ConnectionTimedOut: {
[Lang.EN]: "Connecton timed out",
[Lang.DE]: "Verbindung abgebrochen"
},
ConnectionIsSlow: pingMs => ({
[Lang.EN]: `Connection is slow (${pingMs}ms Ping)`,
[Lang.DE]: `Verbindung ist langsam (${pingMs}ms Ping)`
}),
ConnectionInvitation: {
[Lang.EN]: "Connection Invitation",
[Lang.DE]: "Verbindungs-Einladung"
},
RTCAnswer: {
[Lang.EN]: "RTC Answer",
[Lang.DE]: "RTC Antwort"
},
ConnectionAnswer: {
[Lang.EN]: "Connection Answer",
[Lang.DE]: "Verbindungs-Antwort"
},
PleaseEnterCode: {
[Lang.EN]: "Please enter an ID.",
[Lang.DE]: "Bitte gib eine ID ein.",
},
CodeMustBeCharsLong: numChars => ({
[Lang.EN]: `ID must be ${numChars} characters long.`,
[Lang.DE]: `ID muss ${numChars} Buchstaben lang sein.`
}),
IsServerDown: {
[Lang.EN]: "Couldn't request site: Server down?",
[Lang.DE]: "Server hat nicht geantwortet: Server down?"
},
UnknownID: {
[Lang.EN]: "Unknown ID",
[Lang.DE]: "Unbekannte ID"
},
MultigolfScoreboard: {
[Lang.EN]: "Multigolf Scoreboard",
[Lang.DE]: "Multigolf Ergebnisse"
},
ShareText: {
[Lang.EN]: "Look! Scores! We played Multigolf! You should too!",
[Lang.DE]: "Guck mal! Wir haben Multigolf gespielt!"
},
LeavingWarning: {
[Lang.EN]: "You're in an active game of multigolf. Leaving this website will break the game!",
[Lang.DE]: "Du bist in einem aktiven Multigolf-Spiel. Das Verlassen der Website beendet das Spiel!"
},
NameTooLong: name => ({
[Lang.EN]: `Name "${name}..." is too long.`,
[Lang.DE]: `Der Name "${name}..." ist zu lang.`,
}),
PleaseFillOutFields: {
[Lang.EN]: "Please fill out all fields.",
[Lang.DE]: "Bitte fülle alle Felder aus."
},
FilloutOneName: {
[Lang.EN]: "Fill out at least one name to continue.",
[Lang.DE]: "Bitte fülle mindestens einen Namen aus."
},
TwoPlayersSameName: {
[Lang.EN]: "Two players cannot have the same name.",
[Lang.DE]: "Es kann sich kein Name doppeln."
},
DeviceGravity: {
[Lang.EN]: "Device Gravity",
[Lang.DE]: "Gerät-Gravitation"
},
DeviceGravityDescription: {
[Lang.EN]: "If enabled, phones that are tilted in real life will apply a gravity effect on balls.",
[Lang.DE]: "Wenn aktiviert wird die Orientierung von Handys als Gravitation einberechnet."
},
DeviceGravityWarning: {
[Lang.EN]: "Only works for phones with accelorometers.",
[Lang.DE]: "Funktioniert nur für Handys mit Zugriff auf Beschleunigungssensor"
},
BallCollisions: {
[Lang.EN]: "Ball Collisisions",
[Lang.DE]: "Ball-Kollisionen"
},
BallCollisionsDescription: {
[Lang.EN]: "If enabled, balls can kick each other. If disabled, balls will fly over each other.",
[Lang.DE]: "Wenn aktiviert können Bälle sich gegenseitig schubsen."
},
Soundeffects: {
[Lang.EN]: "Soundeffects",
[Lang.DE]: "Soundeffekte"
},
SoundeffectsDescription: {
[Lang.EN]: "If enabled, the host device will play sound effects when balls collide with something.",
[Lang.DE]: "Wenn aktiviert spielen Soundeffekte auf dem Server-Gerät wenn Bälle mit etwas kollidieren."
},
ReadNames: {
[Lang.EN]: "Read Names",
[Lang.DE]: "Namen Vorlesen"
},
ReadNamesDescription: {
[Lang.EN]: "If enabled, the host device will read the name of the player whose turn it is out loud.",
[Lang.DE]: "Wenn aktiviert wird das Server-Gerät den Namen des aktiven Spielers vorlesen."
},
MaximumKicksPerRound: {
[Lang.EN]: "Maximum Kicks per Round",
[Lang.DE]: "Maximale Schläge pro Runde"
},
MaximumKicksPerRoundDescription: {
[Lang.EN]: "Decide how many kicks each player can have per round before failing and getting a 2 point penalty.",
[Lang.DE]: "Entscheide wieviele Schläge jede Spielerin bekommt, bevor sie 2 Strafpunkte bekommt."
},
OnceYouConnectPlayers: {
[Lang.EN]: "Once you connect players, they will show up here.",
[Lang.DE]: "Sobald du Geräte verbindest, tauchen sie hier auf."
},
DeviceNum: num => ({
[Lang.EN]: `Device #${num}`,
[Lang.DE]: `Gerät #${num}`,
}),
NoDevicesError: {
[Lang.EN]: "You haven't connected any devices yet. Connect one and try again!",
[Lang.DE]: "Du hast noch keine Geräte verbunden. Verbinde mindestens eines und versuche nochmal!"
},
CourseHasOverlap: {
[Lang.EN]: "Your course has overlapping parts. Try reconnecting the phones in a different way and draw lines in the same directions on connecting phones. Do you still want to proceed?",
[Lang.DE]: "Der Kurs hat überlappende Teile. Versuche, die Geräte neu miteinander zu verbinden. Willst du trotzdem weiter (nicht empfohlen)?"
},
NoStartYet: {
[Lang.EN]: "You haven't placed a start yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Start. Platzier einen und probier nochmal."
},
NoHoleYet: {
[Lang.EN]: "You haven't placed a hole yet. Place one and try again.",
[Lang.DE]: "Dem Kurs fehlt ein Loch. Platzier eins und probier nochmal."
},
HaventPlacedHoleFor: name => ({
[Lang.EN]: `You haven't placed a hole for ${name} yet.`,
[Lang.DE]: `Du hast noch kein Loch für ${name} platziert.`
}),
ObjectStart: {
[Lang.EN]: "Start",
[Lang.DE]: "Start"
},
ObjectHole: {
[Lang.EN]: "Hole",
[Lang.DE]: "Loch"
},
ObjectLava: {
[Lang.EN]: "Lava",
[Lang.DE]: "Lava"
},
ObjectCannon: {
[Lang.EN]: "Cannon",
[Lang.DE]: "Kanone"
},
ObjectEraser: {
[Lang.EN]: "Eraser",
[Lang.DE]: "Radierer"
},
ObjectDuellHole: num => ({
[Lang.EN]: `Hole ${num}`,
[Lang.DE]: `Loch ${num}`,
}),
ObjectCustomWall: {
[Lang.EN]: "Extra Wall",
[Lang.DE]: "Extra Wand"
},
ObjectGravityBox: {
[Lang.EN]: "Gravity Box",
[Lang.DE]: "Gravitations-Box"
},
ObjectStartDescription: {
[Lang.EN]: "Place where all balls start",
[Lang.DE]: "Platz wo alle Bälle starten"
},
ObjectHoleDescription: {
[Lang.EN]: "Goal that all balls must reach",
[Lang.DE]: "Ziel, welches alle Bälle erreichen müssen"
},
ObjectLavaDescription: {
[Lang.EN]: "Balls falling into Lava are reset to the start",
[Lang.DE]: "In Lava fallen = Zum Start zurück"
},
ObjectCannonDescription: {
[Lang.EN]: "Rotates and shoots balls",
[Lang.DE]: "Dreht sich und schießt Bälle weg"
},
ObjectEraserDescriptiom: {
[Lang.EN]: "Erase placed objects",
[Lang.DE]: "Radiere platzierte Objekte"
},
ObjectDuellHoleDescription: playername => ({
[Lang.EN]: `Goal that ${playername} has to reach`,
[Lang.DE]: `Ziel das ${playername} erreichen muss`
}),
ObjectCustomWallDescription: {
[Lang.EN]: "A wall that balls will bounce off",
[Lang.DE]: "Eine Wand an der Bälle abprallen"
},
ObjectGravityBoxDescription: {
[Lang.EN]: "Balls inside will experience gravity",
[Lang.DE]: "Bälle werden in die Richtung geschubst"
},
NotConstructedYet: {
[Lang.EN]: "You haven't constructed a course layout yet.",
[Lang.DE]: "Du hast noch kein Layout erstellt."
},
ThanksForFeedback: {
[Lang.EN]: "Thanks for the feedback! You're the best!",
[Lang.DE]: "Feedback erfolgreich abgeschickt! Vielen Dank!"
},
FeedbackTooLong: {
[Lang.EN]: "That's too long feedback for this box. Maybe send me an email instead?",
[Lang.DE]: "Das ist zu viel Feedback für diese Box. Vielleicht ist eine Email besser?"
},
StartChallenge: {
[Lang.EN]: "Start Challenge",
[Lang.DE]: "Challenge Starten"
},
WantToTryAgain: {
[Lang.EN]: "You lost the Challenge. Do you want to try again?",
[Lang.DE]: "Du hast die Challenge verloren. Willst du es nochmal probieren?"
},
YouLost: {
[Lang.EN]: "You Lost!",
[Lang.DE]: "Verloren!"
},
YouWonLong: kicksLeft => ({
[Lang.EN]: `Hoooorayyy! You won the Challenge! Congratulations! You even have ${kicksLeft} kicks left!`,
[Lang.DE]: `Huuurraaaa! Du hast die Challenge bezwungen! Herzlichen Glückwunsch! Du hast sogar ${kicksLeft} Schläge übrig!`
}),
YouWon: {
[Lang.EN]: "You Won!",
[Lang.DE]: "Gewonnen!"
},
YourPackHighscore: (packName, score) => ({
[Lang.EN]: `At your best attempt at ${packName}, you had ${score} kicks left.`,
[Lang.DE]: `Beim besten Versuch bei diesem Pack hattest du ${score} Schläge übrig.`
})
}
function getLangText(textObject) {
return textObject[Lang.get()]
}
for (const [key, val] of Object.entries(Text)) {
if (typeof val === "function") {
Text[key] = function () {
return getLangText(val(...arguments))
}
} else {
Object.defineProperty(Text, key, {
get: () => getLangText(val)
})
}
}
Object.freeze(Text)
const Sprite = {
BallBlue:      "../assets/compressed/objects/balls/blue.png",
BallCyan:      "../assets/compressed/objects/balls/cyan.png",
BallLightblue: "../assets/compressed/objects/balls/light_blue.png",
BallOrange:    "../assets/compressed/objects/balls/orange.png",
BallPink:      "../assets/compressed/objects/balls/pink.png",
BallRed:       "../assets/compressed/objects/balls/red.png",
BallViolet:    "../assets/compressed/objects/balls/violet.png",
BallWhite:     "../assets/compressed/objects/balls/white.png",
BallYellow:    "../assets/compressed/objects/balls/yellow.png",
BallRainbow:   "../assets/compressed/objects/balls/rainbow.png",
Grid:          "../assets/compressed/objects/grid.png",
Hole:          "../assets/compressed/objects/hole.png",
Start:         "../assets/compressed/objects/start.png",
DuellHole1:    "../assets/compressed/objects/duellHole1.png",
DuellHole2:    "../assets/compressed/objects/duellHole2.png",
Lava:          "../assets/compressed/objects/lava.png",
Cannon:        "../assets/compressed/objects/cannon.png",
GravityBox:    "../assets/compressed/objects/gravity-box.png",
/* BallBlue:      "../assets/objects/balls/blue.svg",
BallCyan:      "../assets/objects/balls/cyan.svg",
BallLightblue: "../assets/objects/balls/light_blue.svg",
BallOrange:    "../assets/objects/balls/orange.svg",
BallPink:      "../assets/objects/balls/pink.svg",
BallRed:       "../assets/objects/balls/red.svg",
BallViolet:    "../assets/objects/balls/violet.svg",
BallWhite:     "../assets/objects/balls/white.svg",
BallYellow:    "../assets/objects/balls/yellow.svg",
BallRainbow:   "../assets/objects/balls/rainbow.svg",
Grid:          "../assets/objects/grid.svg",
Hole:          "../assets/objects/hole.svg",
Start:         "../assets/objects/start.svg",
DuellHole1:    "../assets/objects/duellHole1.svg",
DuellHole2:    "../assets/objects/duellHole2.svg",
Lava:          "../assets/objects/lava.svg",
Cannon:        "../assets/objects/cannon.svg",
GravityBox:    "../assets/objects/gravity-box.svg", */
Eraser:        "../assets/objects/eraser.svg",
ZoomIcon:      "../assets/zoom-icon.svg",
CustomWall:    "../assets/objects/wall.svg",
}
const AudioSprite = {
Plop: "../assets/audio/plop.mp3",
WinSound: "../assets/audio/win_sound.mp3",
Lava: "../assets/audio/lava.mp3",
Bonk: "../assets/audio/bonk.mp3",
Shot: "../assets/audio/shot.mp3",
Cannon: "../assets/audio/cannon.mp3",
Note1: "../assets/audio/notes/1.mp3",
Note2: "../assets/audio/notes/2.mp3",
Note3: "../assets/audio/notes/3.mp3",
Note4: "../assets/audio/notes/4.mp3",
Note5: "../assets/audio/notes/5.mp3",
Note6: "../assets/audio/notes/6.mp3",
Note7: "../assets/audio/notes/7.mp3",
Note8: "../assets/audio/notes/8.mp3",
Note9: "../assets/audio/notes/9.mp3",
}
const allNoteSprites = [
AudioSprite.Note1,
AudioSprite.Note2,
AudioSprite.Note3,
AudioSprite.Note4,
AudioSprite.Note5,
AudioSprite.Note6,
AudioSprite.Note7,
AudioSprite.Note8,
AudioSprite.Note9
]
const AllBallSprites = [
Sprite.BallBlue,
Sprite.BallRed,
Sprite.BallYellow,
Sprite.BallPink,
Sprite.BallOrange,
Sprite.BallCyan,
Sprite.BallViolet,
Sprite.BallLightblue,
Sprite.BallWhite,
]
function setSpritePath(prePath) {
const spriteObjects = [Sprite, AudioSprite]
const spriteLists = [allNoteSprites, AllBallSprites]
for (const obj of spriteObjects) {
for (const [key, value] of Object.entries(obj)) {
obj[key] = prePath + value
}
}
for (const lst of spriteLists) {
for (let i = 0; i < lst.length; i++) {
lst[i] = prePath + lst[i]
}
}
try {
golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
} catch (e) {
console.log("Couldn't update golfObjectTypeSpriteMap")
if (!(e instanceof ReferenceError)) {
throw e
}
}
}
/*
The MIT License (MIT)
Copyright (c) Rich Tibbett
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const noSleep_webm = "data:video/webm;base64,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"
const noSleep_mp4 = "data:video/mp4;base64,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"
const oldIOS = () =>
typeof navigator !== "undefined" &&
parseFloat(
(
"" +
(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(
navigator.userAgent
) || [0, ""])[1]
)
.replace("undefined", "3_2")
.replace("_", ".")
.replace("_", "")
) < 10 &&
!window.MSStream;
const nativeWakeLock = () => "wakeLock" in navigator;
class NoSleep {
constructor() {
this.enabled = false;
if (nativeWakeLock()) {
this._wakeLock = null;
const handleVisibilityChange = () => {
if (this._wakeLock !== null && document.visibilityState === "visible") {
this.enable();
}
};
document.addEventListener("visibilitychange", handleVisibilityChange);
document.addEventListener("fullscreenchange", handleVisibilityChange);
} else if (oldIOS()) {
this.noSleepTimer = null;
} else {
this.noSleepVideo = document.createElement("video");
this.noSleepVideo.setAttribute("title", "No Sleep");
this.noSleepVideo.setAttribute("playsinline", "");
this._addSourceToVideo(this.noSleepVideo, "webm", noSleep_webm);
this._addSourceToVideo(this.noSleepVideo, "mp4", noSleep_mp4);
this.noSleepVideo.addEventListener("loadedmetadata", () => {
if (this.noSleepVideo.duration <= 1) {
this.noSleepVideo.setAttribute("loop", "");
} else {
this.noSleepVideo.addEventListener("timeupdate", () => {
if (this.noSleepVideo.currentTime > 0.5) {
this.noSleepVideo.currentTime = Math.random();
}
});
}
});
}
}
_addSourceToVideo(element, type, dataURI) {
var source = document.createElement("source");
source.src = dataURI;
source.type = `video/${type}`;
element.appendChild(source);
}
get isEnabled() {
return this.enabled;
}
enable() {
if (nativeWakeLock()) {
return navigator.wakeLock
.request("screen")
.then((wakeLock) => {
this._wakeLock = wakeLock;
this.enabled = true;
console.log("Wake Lock active.");
this._wakeLock.addEventListener("release", () => {
console.log("Wake Lock released.");
});
})
.catch((err) => {
this.enabled = false;
console.error(`${err.name}, ${err.message}`);
throw err;
});
} else if (oldIOS()) {
this.disable();
console.warn(`
NoSleep enabled for older iOS devices. This can interrupt
active or long-running network requests from completing successfully.
See https://github.com/richtr/NoSleep.js/issues/15 for more details.
`);
this.noSleepTimer = window.setInterval(() => {
if (!document.hidden) {
window.location.href = window.location.href.split("#")[0];
window.setTimeout(window.stop, 0);
}
}, 15000);
this.enabled = true;
return Promise.resolve();
} else {
let playPromise = this.noSleepVideo.play();
return playPromise
.then((res) => {
this.enabled = true;
return res;
})
.catch((err) => {
this.enabled = false;
throw err;
});
}
}
disable() {
if (nativeWakeLock()) {
if (this._wakeLock) {
this._wakeLock.release();
}
this._wakeLock = null;
} else if (oldIOS()) {
if (this.noSleepTimer) {
console.warn(`
NoSleep now disabled for older iOS devices.
`);
window.clearInterval(this.noSleepTimer);
this.noSleepTimer = null;
}
} else {
this.noSleepVideo.pause();
}
this.enabled = false;
}
}
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
static fromObject(obj) {
if (obj == null) return null
if (obj.x == undefined || obj.y == undefined) {
throw new Error(`Vector object must have x and y properties`)
}
return new Vector2d(obj.x, obj.y)
}
toObject() {
return {
x: this.x,
y: this.y
}
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get squaredLength() {
return this.x * this.x + this.y * this.y
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
scaleX(x) {
return new Vector2d(this.x * x, this.y)
}
scaleY(y) {
return new Vector2d(this.x, this.y * y)
}
iscaleX(x) {
this.x *= x
}
iscaleY(y) {
this.y *= y
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
distanceSquared(v) {
return this.sub(v).squaredLength
}
cross(v) {
return this.x * v.y - this.y * v.x
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
this.x = x
this.y = y
}
setVector2d(v) {
this.x = v.x
this.y = v.y
}
interpolate(v, t) {
return this.add(v.sub(this).scale(t))
}
iinterpolate(v, t) {
this.iadd(v.sub(this).scale(t))
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
toArray() {
return [this.x, this.y]
}
normalizeToCanvas(canvas) {
return new Vector2d(
this.x / canvas.width,
this.y / canvas.height
)
}
static fromTouchEvent(event, element, {scaleToCanvasSize = true}={}) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX && event.clientY) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
const vec = new Vector2d(x - rect.left, y - rect.top)
if (scaleToCanvasSize && element.tagName == "CANVAS" && element.width && element.height) {
vec.iscaleX(element.width / element.clientWidth)
vec.iscaleY(element.height / element.clientHeight)
}
return vec
}
static fromEvent(event, element) {
return Vector2d.fromTouchEvent(event, element)
}
clampX(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.x - clampValue) <= maxDelta) {
newVector.x = clampValue
}
}
return newVector
}
clampY(clampValues, maxDelta) {
const newVector = this.copy()
for (let clampValue of clampValues) {
if (Math.abs(newVector.y - clampValue) <= maxDelta) {
newVector.y = clampValue
}
}
return newVector
}
min() {
return Math.min(this.x, this.y)
}
max() {
return Math.max(this.x, this.y)
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
iround() {
this.x = Math.round(this.x)
this.y = Math.round(this.y)
}
toString() {
return `${this.x}, ${this.y}`
}
static fromString(str) {
const parts = str.split(",")
if (parts.length != 2) {
throw new Error("String must be made up of two numbers seperated by comma")
}
const x = parseFloat(parts[0])
const y = parseFloat(parts[1])
if (isNaN(x) || isNaN(y)) {
throw new Error("String contains invalid number(s)")
}
return new Vector2d(x, y)
}
}
function calcLineIntersection(s1, e1, s2, e2) {
const denominator = (e2.y - s2.y)*(e1.x - s1.x) - (e2.x - s2.x)*(e1.y - s1.y)
if (denominator == 0) {
return null
}
const ua = ((e2.x - s2.x) * (s1.y - s2.y) - (e2.y - s2.y) * (s1.x - s2.x)) / denominator
const ub = ((e1.x - s1.x) * (s1.y - s2.y) - (e1.y - s1.y) * (s1.x - s2.x)) / denominator
if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null
return new Vector2d(
s1.x + ua * (e1.x - s1.x),
s1.y + ua * (e1.y - s1.y),
)
}
function calcAveragePos(vecs) {
return vecs.reduce((p,c) => p.add(c), new Vector2d(0,0)).scale(1 / vecs.length)
}
class ConstructionLine {
constructor(startPos, endPos) {
this.startPos = startPos
this.endPos = endPos
}
get start() {
return this.startPos
}
get end() {
return this.endPos
}
static fromObject(obj) {
return new ConstructionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end)
)
}
toObject() {
return {
start: this.startPos.toObject(),
end: this.endPos.toObject()
}
}
}
class PhoneCoordinates {
constructor(topLeft, topRight, bottomLeft, bottomRight, angle, scalar, gravity) {
this.topLeft = topLeft
this.topRight = topRight
this.bottomLeft = bottomLeft
this.bottomRight = bottomRight
this.angle = angle ?? 0
this.scalar = scalar ?? 1
this.gravity = gravity ?? new Vector2d(0, 0)
}
static fromWidthHeight(width, height) {
return new PhoneCoordinates(
new Vector2d(0, 0),
new Vector2d(width, 0),
new Vector2d(0, height),
new Vector2d(width, height),
0, 1,
new Vector2d(0, 0)
)
}
toObject() {
return {
coords: [
this.topLeft.toObject(),
this.topRight.toObject(),
this.bottomLeft.toObject(),
this.bottomRight.toObject(),
],
angle: this.angle,
scalar: this.scalar,
gravity: this.gravity.toObject()
}
}
static fromObject(obj) {
return new PhoneCoordinates(
...obj.coords.map(coord => Vector2d.fromObject(coord)),
obj.angle,
obj.scalar,
Vector2d.fromObject(obj.gravity)
)
}
get points() {
return [this.topLeft, this.topRight, this.bottomRight, this.bottomLeft]
}
get midPos() {
return this.topLeft.add(this.bottomRight).scale(0.5)
}
randomPosInside() {
const x = Math.random()
const y = Math.random()
return this.topLeft.add(this.topRight.sub(this.topLeft).scale(x))
.add(this.bottomLeft.sub(this.topLeft).scale(y))
}
scale(scalar) {
this.scalar *= scalar
for (let vec of this.points) {
vec.iscale(scalar)
}
}
rotate(angle) {
this.angle += angle
for (let vec of this.points) {
vec.irotate(angle)
}
}
translate(point) {
for (let vec of this.points) {
vec.iadd(point)
}
}
copy() {
return PhoneCoordinates.fromObject(this.toObject())
}
get width() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.topRight.rotate(-this.angle)
return rotated2.x - rotated1.x
}
get height() {
const rotated1 = this.topLeft.rotate(-this.angle)
const rotated2 = this.bottomLeft.rotate(-this.angle)
return rotated2.y - rotated1.y
}
get area() {
return this.size.x * this.size.y
}
creditCardScalingFactor(screenSize) {
return this.height / screenSize.y
}
screenPosToBoardPos(screenPos, screenSize) {
const scaledScreenPos = screenPos.copy()
scaledScreenPos.iscaleX(this.width / screenSize.x)
scaledScreenPos.iscaleY(this.height / screenSize.y)
const pos = scaledScreenPos.rotate(this.angle)
return this.topLeft.add(pos.scale(this.scalar))
}
boardPosToScreenPos(boardPos, screenSize) {
const relativePos = boardPos.sub(this.topLeft).scale(1 / this.scalar)
const rawScreenPos = relativePos.rotate(-this.angle)
rawScreenPos.iscaleX(screenSize.x / this.width)
rawScreenPos.iscaleY(screenSize.y / this.height)
return rawScreenPos
}
containsPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY
}
distanceToPos(pos) {
const minX = Math.min(this.topLeft.x, this.bottomRight.x)
const minY = Math.min(this.topLeft.y, this.bottomRight.y)
const maxX = Math.max(this.topLeft.x, this.bottomRight.x)
const maxY = Math.max(this.topLeft.y, this.bottomRight.y)
const dx = Math.max(minX - pos.x, 0, pos.x - maxX)
const dy = Math.max(minY - pos.y, 0, pos.y - maxY)
return Math.sqrt(dx * dx + dy * dy)
}
get walls() {
return [
[this.points[0], this.points[1]],
[this.points[1], this.points[2]],
[this.points[2], this.points[3]],
[this.points[3], this.points[0]],
]
}
get corners() {
return this.points
}
get minXY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get maxXY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get minXmaxY() {
return new Vector2d(
Math.min(this.topLeft.x, this.bottomRight.x),
Math.max(this.topLeft.y, this.bottomRight.y)
)
}
get maxXminY() {
return new Vector2d(
Math.max(this.topLeft.x, this.bottomRight.x),
Math.min(this.topLeft.y, this.bottomRight.y)
)
}
get size() {
return this.maxXY.sub(this.minXY)
}
hasOverlap(other) {
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (intersection) return true
}
}
return false
}
getOverlap(other) {
const wallIntersections = []
for (const [p1, p2] of this.walls) {
for (const [p3, p4] of other.walls) {
const intersection = calcLineIntersection(p1, p2, p3, p4)
if (!intersection) continue
wallIntersections.push(intersection)
}
}
const uniqueIntersections = []
const epsilon = 0.1
const insidePoints = this.points.filter(p => other.distanceToPos(p) < epsilon)
.concat(other.points.filter(p => this.distanceToPos(p) < epsilon))
for (const point of wallIntersections.concat(insidePoints)) {
let foundSimilar = false
for (const other of uniqueIntersections) {
if (point.distance(other) < epsilon) {
foundSimilar = true
break
}
}
if (!foundSimilar) {
uniqueIntersections.push(point)
}
}
if (uniqueIntersections.length == 4) {
const minXY = new Vector2d(
Math.min(...uniqueIntersections.map(p => p.x)),
Math.min(...uniqueIntersections.map(p => p.y)),
)
const maxXY = new Vector2d(
Math.max(...uniqueIntersections.map(p => p.x)),
Math.max(...uniqueIntersections.map(p => p.y)),
)
const size = maxXY.sub(minXY)
return new PhoneCoordinates(
minXY, minXY.addX(size.x),
minXY.addY(size.y), maxXY
)
} else {
return null
}
}
}
class PhoneConnectionLine {
getRandomColor() {
const hue = Math.round(Math.random() * 360)
if (hue > 65 && hue < 185) {
return this.getRandomColor()
}
return `hsl(${hue}deg 100% 50%)`
}
constructor(start, end, color="random") {
this.start = start ?? new Vector2d(0, 0)
this.end = end ?? new Vector2d(1, 0)
if (color == "random") {
this.color = this.getRandomColor()
} else {
this.color = color
}
}
get length() {
return this.start.distance(this.end)
}
get points() {
return [this.start, this.end]
}
translate(vec) {
this.start.iadd(vec)
this.end.iadd(vec)
return this
}
rotate(angle) {
for (let vec of this.points) {
vec.irotate(angle)
}
}
scale(scalar) {
for (let vec of this.points) {
vec.iscale(scalar)
}
}
static fromObject(obj) {
return new PhoneConnectionLine(
Vector2d.fromObject(obj.start),
Vector2d.fromObject(obj.end),
obj.color
)
}
toObject() {
return {
start: this.start.toObject(),
end: this.end.toObject(),
color: this.color
}
}
}
class Course {
constructor(phones, lines) {
this.phones = phones ?? []
this.lines = lines ?? []
}
reset() {
this.phones = []
this.lines = []
}
toObject() {
return {
phones: this.phones.map(p => p.toObject()),
lines: this.lines.map(l => l.toObject()),
}
}
static fromObject(obj) {
return new Course(
obj.phones.map(p => PhoneCoordinates.fromObject(p)),
obj.lines?.map(l => PhoneConnectionLine.fromObject(l))
)
}
copy() {
return Course.fromObject(this.toObject())
}
scale(scalar) {
this.phones.forEach(p => p.scale(scalar))
this.lines.forEach(l => l.scale(scalar))
}
rotate(angle) {
this.phones.forEach(p => p.rotate(angle))
this.lines.forEach(l => l.rotate(angle))
}
translate(point) {
this.phones.forEach(p => p.translate(point))
this.lines.forEach(l => l.translate(point))
}
addPhone(phone) {
this.phones.push(phone)
}
addLine(line) {
this.lines.push(line)
}
containsPos(pos) {
return this.phones.some(p => p.containsPos(pos))
}
getOverlaps() {
const overlaps = []
for (let i = 0; i < this.phones.length; i++) {
for (let j = 0; j < this.phones.length; j++) {
if (i >= j) continue
const overlap = this.phones[i].getOverlap(this.phones[j])
if (overlap) {
overlaps.push(overlap)
}
}
}
return overlaps
}
}
class Ball {
constructor(pos, vel, inHole, radius, spriteUrl, kicks, active, uid, rotationAngle, lastImmobilePos, immobileTickCount, objectMemory, generallyAbleToCollide) {
this.pos = pos
this.vel = vel ?? new Vector2d(0, 0)
this.inHole = inHole ?? false
this.radius = radius ?? 18
this.spriteUrl = spriteUrl ?? Sprite.BallWhite
this.kicks = kicks ?? 0
this.active = active ?? true
this.uid = uid
this.rotationAngle = rotationAngle ?? 0
this.lastImmobilePos = lastImmobilePos ?? this.pos.copy()
this.immobileTickCount = immobileTickCount ?? 0
this.objectMemory = objectMemory ?? new Map() // {objectUid => dynamicMap<key, value>}
this.generallyAbleToCollide = generallyAbleToCollide ?? true
this.outOfBoundsTickCount = 0
this.movingTickCount = 0
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
i: this.inHole,
r: this.radius,
s: this.spriteUrl,
k: this.kicks,
a: this.active,
u: this.uid,
ro: this.rotationAngle,
l: this.lastImmobilePos,
im: this.immobileTickCount,
o: Array.from(this.objectMemory.entries()).map(([k, v]) => [k, Array.from(v.entries())]),
g: this.generallyAbleToCollide
}
}
static fromObject(obj) {
return new Ball(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.i,
obj.r,
obj.s,
obj.k,
obj.a,
obj.u,
obj.ro,
obj.l,
obj.im,
(obj.o !== undefined) ? new Map(obj.o.map(([k, v]) => [k, new Map(v)])) : new Map(),
obj.g
)
}
kick(direction) {
if (this.inHole) {
return
}
this.vel.iadd(direction.scale(0.6))
this.kicks++
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Shot)
}
}
isMoving() {
return this.vel.length > 0
}
_getClosestWall(pos, board) {
let closestWall = null
let smallestDistance = Infinity
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance} = this._distanceToWall(p1, p2, pos)
if (distance < smallestDistance) {
closestWall = [p1, p2]
smallestDistance = distance
}
}
}
return closestWall
}
_getCollidingCorners(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingCorners = []
for (const wallObject of walledObjects) {
for (const corner of wallObject.corners) {
const distance = corner.distance(this.pos)
if (distance < this.radius) {
collidingCorners.push({
type: "corner",
distance, point: corner
})
}
}
}
return collidingCorners
}
_getCollidingWalls(board) {
const walledObjects = board.course.phones
.concat(board.objects.filter(o => o.type == golfObjectType.CustomWall))
const collidingWalls = []
const epsilon = 0.01
for (let wallObject of walledObjects) {
for (let [p1, p2] of wallObject.walls) {
const {distance, closestPoint} = this._distanceToWall(p1, p2, this.pos)
if (distance <= this.radius) {
let overlapCount = 0
for (const box of board.course.phones) {
const boxDist = box.distanceToPos(closestPoint)
if (boxDist < epsilon) {
overlapCount++
if (overlapCount > 1) {
break
}
}
}
if (overlapCount < 2) {
collidingWalls.push({
points: [p1, p2], distance,
type: "wall"
})
}
}
}
}
return collidingWalls
}
_getClosestEndPos(pos, board) {
let closestPos = board.endPositions[0]
let smallestDistance = Infinity
for (let endPos of board.endPositions) {
const distance = endPos.distance(pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestPos = endPos
}
}
return closestPos.copy()
}
_distanceToWall(p1, p2, point) {
let p2toP1 = p2.sub(p1)
let p2toPoint = point.sub(p1)
let d = p2toP1.dot(p2toPoint) / (p2toP1.length ** 2)
if (d < 0) {
return {distance: p1.distance(point), closestPoint: p1.copy()}
} else if (d > 1) {
return {distance: p2.distance(point), closestPoint: p2.copy()}
} else {
let closestPoint = p1.add(p2toP1.scale(d))
return {distance: closestPoint.distance(point), closestPoint}
}
}
_isInCustomWall(pos, board) {
return board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(pos))
}
_reflectAtWall(p1, p2, dir) {
const wallDir = p2.sub(p1)
const wallNormal = new Vector2d(-wallDir.y, wallDir.x)
const angleDifference = dir.angle - wallNormal.angle
return dir.rotate(-angleDifference * 2).scale(-1)
}
_getIntersectingObjects(board, objectType=null) {
return board.objects.filter(o => {
return o.intersects(this.pos) && (
objectType == null || o.type == objectType
)
})
}
readyToCollide(board) {
return !this.inHole && board.startPos.distance(this.pos) > 2 * this.radius
}
calcBallCollisions(board) {
if (!this.readyToCollide(board) || !this.generallyAbleToCollide) {
return
}
for (let ball of board.balls) {
if (ball.uid == this.uid) {
continue
}
if (!ball.readyToCollide(board) || !ball.generallyAbleToCollide) {
continue
}
const collision = ball.pos.distance(this.pos) <= (ball.radius + this.radius)
if (collision) {
const [v1, v2, x1, x2] = [this.vel, ball.vel, this.pos, ball.pos]
const v1p = v1.sub(x1.sub(x2).scale(v1.sub(v2).dot(x1.sub(x2)) / (x1.sub(x2).length ** 2)))
const v2p = v2.sub(x2.sub(x1).scale(v2.sub(v1).dot(x2.sub(x1)) / (x2.sub(x1).length ** 2)))
this.vel = v1p
ball.vel = v2p
this.pos.iadd(this.vel)
ball.pos.iadd(ball.vel)
ball.immobileTickCount = 0
this.immobileTickCount = 0
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Bonk)
}
}
}
}
updatePhysics(board) {
const stepCount = Math.max(Math.ceil(this.vel.length / 5), 1)
let isUnderAcceleration = false
if (board.deviceGravityEnabled && this.isMoving() && !this.inHole) {
for (let i = 0; i < board.course.phones.length; i++) {
if (board.course.phones[i].containsPos(this.pos)) {
const gravity = board.course.phones[i].gravity
.rotate(board.course.phones[i].angle)
if (!gravity) break
if (gravity.length > 0) {
this.vel.iadd(gravity)
isUnderAcceleration = true
}
break
}
}
}
if (this.isMoving() && !this.inHole) {
const gravityBoxes = this._getIntersectingObjects(board, golfObjectType.GravityBox)
for (const box of gravityBoxes) {
const gravity = Vector2d.fromAngle(box.angle - Math.PI / 2).scale(0.5)
this.vel.iadd(gravity)
isUnderAcceleration = true
}
}
if (this.isMoving() && this.vel.length < 0.3 && !isUnderAcceleration) {
this.vel.iscale(0)
}
let isActivelyMoving = false
this.vel.iscale(0.97)
this.vel.iscale(1 / stepCount)
this._objectInteractedFlag = false
for (let i = 0; i < stepCount; i++) {
if (this.physicsStep(board)) {
isActivelyMoving = true
}
}
this.vel.iscale(stepCount)
if (this.pos.distance(this.lastImmobilePos) > this.radius) {
this.immobileTickCount = 0
this.lastImmobilePos = this.pos.copy()
} else {
this.immobileTickCount++
}
if (this.immobileTickCount > 60 * 2 && this.isMoving()) {
this.vel.iscale(0)
}
if (!board.course.containsPos(this.pos) ||
board.objects.filter(o => o.type == golfObjectType.CustomWall)
.some(o => o.intersects(this.pos))) {
this.outOfBoundsTickCount++
if (this.outOfBoundsTickCount > 10) {
this.resetPos(board.startPos)
this.outOfBoundsTickCount = 0
}
} else {
this.outOfBoundsTickCount = 0
}
if (this.isMoving() || isActivelyMoving) {
this.movingTickCount++
if (this.movingTickCount > 60 * 10) {
this.vel.iscale(0)
}
} else {
this.movingTickCount = 0
}
}
isInMovement() {
return this.movingTickCount > 0
}
resetPos(startPos) {
this.pos = startPos.copy()
this.vel.iscale(0)
this.rotationAngle = 0
this.generallyAbleToCollide = true
}
interactWithLava(board, object) {
if (!this.inHole) {
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Lava)
}
board.spawnParticleExplosion(this.pos,
{forceSpeed: this.vel.length, color: "#f9480a"})
return this.resetPos(board.startPos)
}
}
interactWithCannon(board, object) {
const objectData = this.getObjectMemory(object.uid)
let cannonProgress = 0
if (objectData.has("progress")) {
cannonProgress = objectData.get("progress")
} else {
objectData.set("progress", cannonProgress)
}
const shootDir = Vector2d.fromAngle(object.angle + Math.PI / 2)
const bellyPos = object.pos.add(shootDir.scale(-object.size.max() * 0.17))
const nozzlePos = object.pos.add(shootDir.scale(object.size.max() * 0.37))
const desiredPos = cannonProgress < 30 ? bellyPos
: cannonProgress < 100 ? bellyPos.interpolate(nozzlePos, (cannonProgress - 30) / 70)
: nozzlePos
if (cannonProgress > 30 && cannonProgress < 100) {
this.rotationAngle += 0.05
}
this.rotationAngle += Math.PI / 140
this.pos.iinterpolate(desiredPos, Math.min(cannonProgress / 50, 1))
this.vel.iscale(0)
this.generallyAbleToCollide = false
if (cannonProgress >= 140) {
this.vel.setVector2d(shootDir.scale(object.size.max() / 2))
this.pos.iadd(shootDir.scale(object.size.max() / 2))
this.resetObjectMemory(object.uid)
for (let i = 0; i < 20; i++) {
const particle = new Particle(nozzlePos.copy())
particle.vel = shootDir.scale(10 + Math.random() * 10)
particle.vel.irotate(Math.random() * 0.4 - 0.2)
particle.color = "black"
board.particles.push(particle)
}
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.Cannon)
}
this.generallyAbleToCollide = true
}
objectData.set("progress", cannonProgress + 1)
return true
}
getObjectMemory(objectUid) {
if (!this.objectMemory.has(objectUid)) {
this.objectMemory.set(objectUid, new Map())
}
const objectData = this.objectMemory.get(objectUid)
objectData.set("expire-count", 100)
return objectData
}
resetObjectMemory(objectUid) {
if (this.objectMemory.has(objectUid)) {
this.objectMemory.delete(objectUid)
}
}
updateObjectMemories() {
for (const [objectUid, objectData] of this.objectMemory.entries()) {
if (objectData.has("expire-count")) {
const count = objectData.get("expire-count")
objectData.set("expire-count", count - 1)
if (count <= 1) {
this.objectMemory.delete(objectUid)
}
}
}
}
interactStepWithObject(board, object) {
if (this._objectInteractedFlag) {
return
}
this._objectInteractedFlag = true
switch(object.type) {
case golfObjectType.Lava:
return this.interactWithLava(board, object)
case golfObjectType.Cannon:
return this.interactWithCannon(board, object)
}
this._objectInteractedFlag = false
}
physicsStep(board) {
let madeWallCollision = false
let isActivelyMoving = false
this.pos.iadd(this.vel)
const touchingObjects = board.objects.filter(o => o.intersects(this.pos))
for (const object of touchingObjects) {
if (this.interactStepWithObject(board, object)) {
isActivelyMoving = true
}
}
this.updateObjectMemories()
const collidingObjects = this._getCollidingCorners(board).concat(this._getCollidingWalls(board))
collidingObjects.sort((a, b) => a.distance - b.distance)
if (collidingObjects.length > 0 && this.generallyAbleToCollide) {
if (collidingObjects[0].type == "corner") {
const collidingCorner = collidingObjects[0].point
const cornerDir = this.pos.sub(collidingCorner)
const collisionStrength = -2 * this.vel.dot(cornerDir) / cornerDir.squaredLength
this.pos.isub(this.vel)
this.vel.iadd(cornerDir.scale(collisionStrength))
this.pos.iadd(this.vel.scale(0.95))
madeWallCollision = true
} else {
for (const [p1, p2] of collidingObjects.filter(o => o.type == "wall").map(o => o.points)) {
this.pos.isub(this.vel)
this.vel = this._reflectAtWall(p1, p2, this.vel)
this.pos.iadd(this.vel.scale(0.8))
}
}
madeWallCollision = true
}
if (board.ballCollisionEnabled) {
this.calcBallCollisions(board)
}
const endPos = this._getClosestEndPos(this.pos, board)
if (endPos && !this.inHole) {
const distance = endPos.distance(this.pos)
if (distance <= this.radius * 1.35 && this.vel.length < 40) {
this.inHole = true
if (window.AudioPlayer) {
window.AudioPlayer.play(AudioSprite.WinSound)
}
}
}
if (this.inHole) {
this.radius = Math.max(0, this.radius - 0.13)
this.pos = this.pos.lerp(endPos, 0.1)
this.rotationAngle += 0.4
this.vel.iscale(0.8)
} else {
this.rotationAngle += this.vel.length / 40
}
if (madeWallCollision && window.AudioPlayer) {
window.AudioPlayer.randomNote({
volume: Math.min(this.vel.length / 10 * 0.9 + 0.1, 1.)
})
}
return isActivelyMoving
}
translate(point) {
this.pos.iadd(point)
}
scale(scalar) {
this.radius *= scalar
this.pos.iscale(scalar)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
}
const PARTICLE_MAX_TICKS = 30
class Particle {
constructor(pos, vel, color, radius, ticksAlive) {
this.pos = pos ?? new Vector2d(0, 0)
this.vel = vel ?? new Vector2d(0, 0)
this.color = color ?? "white"
this.radius = radius ?? 5
this.ticksAlive = 0
this.alive = true
}
die() {
this.alive = false
}
get opacity() {
return Math.max(1 - this.ticksAlive / PARTICLE_MAX_TICKS, 0)
}
updatePhysics(board) {
if (!this.alive) {
return
}
this.pos.iadd(this.vel)
if (!board.course.containsPos(this.pos)) {
this.die()
}
if (this.ticksAlive > PARTICLE_MAX_TICKS) {
this.die()
}
this.ticksAlive++
}
toObject() {
return {
p: this.pos.toObject(),
v: this.vel.toObject(),
c: this.color,
r: this.radius,
t: this.ticksAlive
}
}
static fromObject(obj) {
return new Particle(
Vector2d.fromObject(obj.p),
Vector2d.fromObject(obj.v),
obj.c, obj.r, obj.t
)
}
}
class Board {
static physicsTimestep = 17 // approximately 60 fps
constructor(course, objects, balls, physicsTime, ballCollisionEnabled, deviceGravityEnabled, particlesEnabled, particles, styling) {
this.course = course ?? new Course()
this.objects = objects ?? []
this.balls = balls ?? []
this.particles = particles ?? []
this.physicsTime = physicsTime ?? Date.now()
this.styling = styling ?? new BoardStyling()
this.ballCollisionEnabled = ballCollisionEnabled ?? true
this.deviceGravityEnabled = deviceGravityEnabled ?? true
this.particlesEnabled = particlesEnabled ?? true
this.constructionLineBuffer = []
this.courseHistory = [this.course.copy()]
this.physicsStepCount = 0
this.physicsStepEvents = []
}
resetConfig() {
this.balls = []
this.objects = []
this.course.reset()
this.courseHistory = [this.course.copy()]
}
addPhysicsEvent(callback, relativeStepIndex) {
this.physicsStepEvents.push([this.physicsStepCount + relativeStepIndex, callback])
}
spawnParticleExplosion(pos, {color=undefined, forceSpeed=undefined, numParticles=50, radius=undefined}={}) {
if (!this.particlesEnabled) {
return
}
const plusminus = Math.ceil(numParticles * 0.3)
numParticles += Math.round((Math.random() - 0.5) * 2 * plusminus)
const angleStep = 1 / numParticles * Math.PI * 2
for (let i = 0; i < numParticles; i++) {
let speed = forceSpeed ?? 2
speed *= 0.7 + Math.random() * 0.6
const angle = (i + Math.random()) * angleStep
const vel = Vector2d.fromAngle(angle).scale(speed)
const particle = new Particle(pos.copy(), vel, color, radius)
this.particles.push(particle)
}
}
clearPhysicsEvents() {
this.physicsStepEvents.splice(0, this.physicsStepEvents.length)
}
get movableThings() {
return this.objects.concat(this.balls).concat([this.course])
}
translate(point) {
for (const thing of this.movableThings) {
thing.translate(point)
}
}
rotate(angle) {
for (const thing of this.movableThings) {
thing.rotate(angle)
}
}
scale(scalar) {
for (const thing of this.movableThings) {
thing.scale(scalar)
}
}
updateObject(object) {
for (let i = 0; i < gameState.board.objects.length; i++) {
if (gameState.board.objects[i].uid == object.uid) {
gameState.board.objects[i] = object
return true
}
}
return false
}
getClosestObject(pos) {
let smallestDistance = Infinity
let closestObject = null
for (let object of this.objects) {
const distance = pos.distance(object.pos)
if (distance < smallestDistance) {
smallestDistance = distance
closestObject = object
}
}
return closestObject
}
intersectObject(pos) {
for (let i = this.objects.length - 1; i >= 0; i--) {
if (this.objects[i].intersects(pos)) {
return this.objects[i]
}
}
return null
}
get startPos() {
const startObject = this.objects.find(o => o.type == golfObjectType.Start)
if (startObject) {
return startObject.pos
} else {
return undefined
}
}
get endPositions() {
return this.objects.filter(o => (
o.type == golfObjectType.Hole
|| o.type == golfObjectType.DuellHole1
|| o.type == golfObjectType.DuellHole2
)).map(o => o.pos)
}
updateObjectPhysics() {
for (const object of this.objects.filter(o => o.type == golfObjectType.Cannon)) {
object.angle += Math.PI / 140
}
}
physicsStep() {
for (const ball of this.balls) {
ball.updatePhysics(this)
}
for (const particle of this.particles) {
particle.updatePhysics(this)
}
this.updateObjectPhysics()
this.particles = this.particles.filter(p => p.alive)
this.physicsTime += Board.physicsTimestep
}
updatePhysics(maxTime=Date.now(), maxSteps=500) {
let stepCount = 0
while (stepCount < maxSteps && this.physicsTime < maxTime) {
this.physicsStep()
this.physicsStepCount++
stepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
if (Math.abs(this.physicsTime - maxTime) > 10 * 1000) {
this.physicsTime = maxTime
}
}
simulateStepsEfficiently(numSteps, {
disableParticles = true
}={}) {
const prevParticlesEnabled = this.particlesEnabled
if (disableParticles) {
this.particlesEnabled = false
}
for (let i = 0; i < numSteps; i++) {
this.physicsStep()
this.physicsStepCount++
for (const [eventIndex, callback] of this.physicsStepEvents) {
if (eventIndex == this.physicsStepCount) {
callback()
}
}
this.physicsStepEvents = this.physicsStepEvents.filter(([i, _]) => i > this.physicsStepCount)
}
this.particlesEnabled = prevParticlesEnabled
}
spawnBall({
spriteUrl = "random"
}={}) {
if (!this.startPos) {
throw new Error("StartPos must be set before spawning ball")
}
if (spriteUrl == "random") {
spriteUrl = AllBallSprites[Math.floor(Math.random() * AllBallSprites.length)]
}
const ball = new Ball(
this.startPos.copy(), new Vector2d(0, 0),
false, 18, spriteUrl, 0, true,
Math.random().toString().slice(2), 0
)
this.balls.push(ball)
return ball
}
addConstructionLine(line, phone, timestamp, deviceIndex) {
this.constructionLineBuffer.push({
line, phone, timestamp, deviceIndex})
this.parseConstructionLines()
}
toObject() {
return {
course: this.course.toObject(),
objects: this.objects.map(o => o.toObject()),
balls: this.balls.map(b => b.toObject()),
physicsTime: this.physicsTime,
ballCollisionEnabled: this.ballCollisionEnabled,
deviceGravityEnabled: this.deviceGravityEnabled,
particlesEnabled: this.particlesEnabled,
particles: this.particles.map(p => p.toObject())
}
}
static fromObject(obj) {
return new Board(
Course.fromObject(obj.course),
obj.objects.map(o => GolfObject.fromObject(o)),
obj.balls.map(b => Ball.fromObject(b)),
obj.physicsTime, obj.ballCollisionEnabled,
obj.deviceGravityEnabled, obj.particlesEnabled,
obj.particles?.map(p => Particle.fromObject(p))
)
}
get currPhoneIndex() {
return Math.max(1, this.course.phones.length)
}
parseConstructionLines() {
this.constructionLineBuffer = this.constructionLineBuffer
.filter(c => Date.now() - c.timestamp < 2500)
if (this.constructionLineBuffer.length < 2) {
return
}
const removeIndeces = new Set()
for (let i = 0; i + 1 < this.constructionLineBuffer.length; i++) {
let a = this.constructionLineBuffer[i]
let b = this.constructionLineBuffer[i + 1]
if (a.deviceIndex > b.deviceIndex) {
[a, b] = [b, a] // swap values, make sure {a} has smaller deviceIndex
}
if (!this.connectTwoConstructionLines(a, b)) {
removeIndeces.add(i)
}
}
this.constructionLineBuffer = this.constructionLineBuffer
.filter((_, i) => !removeIndeces.has(i))
}
connectTwoConstructionLines(a, b) {
if (a.deviceIndex > this.currPhoneIndex || a.deviceIndex == b.deviceIndex) {
return false
}
if (a.deviceIndex < this.currPhoneIndex) {
while (this.course.phones.length > parseInt(a.deviceIndex) && this.courseHistory.length > 1) {
this.courseHistory.pop()
this.course = this.courseHistory.slice(-1)[0].copy()
}
}
if (this.course.phones.length == 0) {
this.course = new Course([a.phone.copy()])
this.courseHistory.push(this.course.copy())
}
const deltaA = a.line.endPos.sub(a.line.startPos)
const deltaB = b.line.endPos.sub(b.line.startPos)
const originA = a.line.startPos.copy()
const originB = b.line.startPos.copy()
this.course.scale(deltaB.length / deltaA.length)
originA.iscale(deltaB.length / deltaA.length)
this.course.rotate(deltaB.angle - deltaA.angle)
originA.irotate(deltaB.angle - deltaA.angle)
this.course.translate(originB.sub(originA))
this.course.addPhone(b.phone.copy())
this.course.addLine(new PhoneConnectionLine(b.line.startPos, b.line.endPos))
this.courseHistory.push(this.course.copy())
return true
}
copy() {
return Board.fromObject(this.toObject())
}
}
class BoardStyling {
constructor(gridSprite, customWallInner, customWallOuter, pullColor) {
this.gridSprite = gridSprite ?? Sprite.Grid
this.customWallInner = customWallInner ?? "white"
this.customWallOuter = customWallOuter ?? "black"
this.pullColor = pullColor ?? "rgba(0, 0, 0, 0.5)"
}
toObject() {
return {
g: this.gridSprite,
i: this.customWallInner,
o: this.customWallOuter,
p: this.pullColor
}
}
static fromObject(obj) {
return new BoardStyling(
obj.g, obj.i, obj.o, obj.p
)
}
}
const gamePhase = {
None: -1,
Hello: 0,
ModeChoice: 1,
PlayerSetupDuell: 2,
PlayerSetupTournament: 3,
Connecting: 4,
ConfigGame: 5,
TournamentExplanation: 6,
DuellExplanation: 7,
ConstructionChoice: 8,
ConstructionAuto: 9,
ConstructionCustom: 10,
Loading: 11,
Placing: 12,
PlayingDuell: 13,
PlayingSandbox: 14,
PlayingTournament: 15,
ShowingResultsOfTournament: 16,
ShowingResultsOfDuell: 17,
__LOWEST_PLAYING: 13,
__LOWEST_SHOWING_RESULTS: 16,
__MAX_VALUE: 18,
isPlaying(phase) {
return (
phase == gamePhase.PlayingDuell
|| phase == gamePhase.PlayingSandbox
|| phase == gamePhase.PlayingTournament
)
},
}
const gamePhaseNames = {
[gamePhase.None]: "none",
[gamePhase.Hello]: "hello",
[gamePhase.ModeChoice]: "mode-choice",
[gamePhase.PlayerSetupDuell]: "player-setup-duell",
[gamePhase.PlayerSetupTournament]: "player-setup-tournament",
[gamePhase.Connecting]: "connecting",
[gamePhase.ConfigGame]: "config-game",
[gamePhase.TournamentExplanation]: "tournament-explanation",
[gamePhase.DuellExplanation]: "duell-explanation",
[gamePhase.ConstructionChoice]: "construction-choice",
[gamePhase.ConstructionAuto]: "construction-auto",
[gamePhase.ConstructionCustom]: "construction-custom",
[gamePhase.Loading]: "loading",
[gamePhase.Placing]: "placing",
[gamePhase.PlayingDuell]: "playing-duell",
[gamePhase.PlayingTournament]: "playing-tournament",
[gamePhase.PlayingSandbox]: "playing-sandbox",
[gamePhase.ShowingResultsOfTournament]: "showing-results-of-tournament",
[gamePhase.ShowingResultsOfDuell]: "showing-results-of-duell",
}
const gameMode = {
Sandbox: "sandbox",
Tournament: "tournament",
Duell: "duell",
None: "none",
}
class Player {
constructor(name, roundScores=[]) {
this.name = name
this.roundScores = roundScores
}
get score() {
let sum = 0
for (let score of this.roundScores) {
sum += score
}
return sum
}
toObject() {
return {
name: this.name,
roundScores: this.roundScores
}
}
static fromObject(obj) {
return new Player(obj.name, obj.score, obj.roundScores)
}
addRound(score) {
this.roundScores.push(score)
}
}
class GameState {
constructor(phase, mode, board, players=[], deviceIndex=null,
placingObjectType=golfObjectType.Start,
tournamentBuilderIndex=0, tournamentBallIndex=0,
duellActivePlayerIndex=0, duellWinnerIndex=null,
tournamentMaxKicks=10) {
this.phase = phase
this.mode = mode
this.board = board
this.players = players
this.deviceIndex = deviceIndex
this.placingObjectType = placingObjectType
this.tournamentBuilderIndex = tournamentBuilderIndex
this.tournamentBallIndex = tournamentBallIndex
this.duellActivePlayerIndex = duellActivePlayerIndex
this.duellWinnerIndex = duellWinnerIndex
this.tournamentMaxKicks = tournamentMaxKicks
}
replaceText(txt) {
if (this.mode == gameMode.Duell && this.players.length >= 2) {
txt = txt.replaceAll("<duell-player-1>", this.players[0].name)
txt = txt.replaceAll("<duell-player-2>", this.players[1].name)
}
return txt
}
get duellActivePlayer() {
return this.players[this.duellActivePlayerIndex % this.players.length]
}
get duellInactivePlayer() {
return this.players[(this.duellActivePlayerIndex + 1) % this.players.length]
}
get duellWinner() {
return this.players[this.duellWinnerIndex]
}
get tournamentFinished() {
return this.tournamentBuilderIndex >= this.players.length
}
get tournamentBuilder() {
return this.players[this.tournamentBuilderIndex % this.players.length]
}
get tournamentBall() {
return this.board.balls[this.tournamentBallIndex % this.board.balls.length]
}
get tournamentActivePlayer() {
return this.players[this.tournamentBallIndex % this.players.length]
}
addPlayer(player) {
this.players.push(player)
}
get thisPhone() {
return this.board.course.phones[this.deviceIndex - 1]
}
getReferenceCanvas() {
return fullscreenCanvas
}
screenPosToBoardPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.screenPosToBoardPos(pos, screenSize)
}
boardPosToScreenPos(pos) {
if (!this.thisPhone) return pos
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.boardPosToScreenPos(pos, screenSize)
}
screenAngleToBoardAngle(angle) {
if (!this.thisPhone) return angle
return angle + this.thisPhone.angle
}
boardAngleToScreenAngle(angle) {
if (!this.thisPhone) return angle
return angle - this.thisPhone.angle
}
get scalingFactor() {
if (!this.thisPhone) return 1
return this.thisPhone.scalar
}
get creditCardScalingFactor() {
if (!this.thisPhone) return 1
const screenSize = new Vector2d(this.getReferenceCanvas().width, this.getReferenceCanvas().height)
return this.thisPhone.creditCardScalingFactor(screenSize)
}
get combinedScalingFactor() {
return this.creditCardScalingFactor * this.scalingFactor
}
toObject(deviceIndex) {
return {
phase: this.phase,
mode: this.mode,
board: this.board.toObject(),
players: this.players.map(p => p.toObject()),
index: deviceIndex ?? this.deviceIndex,
placingObjectType: this.placingObjectType,
tournamentBuilderIndex: this.tournamentBuilderIndex,
tournamentBallIndex: this.tournamentBallIndex,
duellActivePlayerIndex: this.duellActivePlayerIndex,
duellWinnerIndex: this.duellWinnerIndex,
tournamentMaxKicks: this.tournamentMaxKicks
}
}
static fromObject(obj) {
return new GameState(
obj.phase, obj.mode,
Board.fromObject(obj.board),
obj.players.map(p => Player.fromObject(p)),
obj.index,
obj.placingObjectType,
obj.tournamentBuilderIndex,
obj.tournamentBallIndex,
obj.duellActivePlayerIndex,
obj.duellWinnerIndex,
obj.tournamentMaxKicks)
}
updatePhysics(hostTime=Date.now()) {
this.board.updatePhysics(hostTime)
}
startSandboxRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateSandbox() {
this.board.balls = this.board.balls.filter(b => b.radius > 0)
}
startTournamentRound() {
this.board.balls = []
for (let i = 0; i < this.players.length; i++) {
const spriteUrl = AllBallSprites[i % AllBallSprites.length]
this.board.spawnBall({spriteUrl})
}
this.tournamentBallIndex = 0
this.board.balls.forEach(b => b.active = false)
this.tournamentBall.active = true
generateScoreboard()
}
endTournament() {
this.phase = gamePhase.ShowingResultsOfTournament
generateScoreboard()
}
endTournamentRound() {
if (this.board.balls.length == 0) {
return
}
this.phase = gamePhase.TournamentExplanation
for (let i = 0; i < this.players.length; i++) {
const roundIndex = this.tournamentBuilderIndex
if (!this.board.balls[i].inHole) {
this.players[i].roundScores[roundIndex] += 2
}
}
this.tournamentBuilderIndex++
this.board.balls.splice(0, this.board.balls.length)
if (this.tournamentFinished) {
this.endTournament()
}
this.board.objects = []
}
onTournamentKick(ball) {
let ballIndex = 0
for (let i = 0; i < this.board.balls.length; i++) {
ballIndex = i
if (ball.uid == this.board.balls[i].uid) {
break
}
}
this.tournamentBall.active = false
this.tournamentBallIndex = ballIndex + 1
this.tournamentBall.active = true
this.advanceTournamentBall(true)
}
advanceTournamentBall(forceSpeak=false) {
if (this.tournamentBall === undefined) {
return false
}
let prevPlayerName = this.tournamentActivePlayer.name
let inHoleCount = 0
while ((this.tournamentBall.inHole && this.tournamentBall.radius == 0)
|| (this.tournamentBall.kicks >= this.tournamentMaxKicks && !this.tournamentBall.isInMovement())) {
inHoleCount++
this.tournamentBall.active = false
this.tournamentBallIndex++
this.tournamentBall.active = true
if (inHoleCount >= this.players.length) {
return false
}
}
if (prevPlayerName != this.tournamentActivePlayer.name || forceSpeak) {
if (window.AudioPlayer && gamePhase.isPlaying(this.phase)) {
setTimeout(() => {
if (gamePhase.isPlaying(this.phase)) {
window.AudioPlayer.say(this.tournamentActivePlayer.name)
}
}, 1000)
}
}
return true
}
updateTournament() {
let madeChange = false
for (let i = 0; i < this.players.length; i++) {
let kicks = this.board.balls[i].kicks
const player = this.players[i]
const roundIndex = this.tournamentBuilderIndex
if (player.roundScores[roundIndex] === undefined) {
player.addRound(kicks)
madeChange = true
} else {
player.roundScores[roundIndex] = kicks
}
}
if (!this.advanceTournamentBall()) {
this.endTournamentRound()
madeChange = true
}
return madeChange
}
endDuell() {
this.phase = gamePhase.ShowingResultsOfDuell
this.board.balls = []
}
startDuellRound() {
this.board.balls = []
this.board.spawnBall({spriteUrl: Sprite.BallWhite})
}
updateDuell() {
const ball = this.board.balls[0]
if (ball.radius == 0 && ball.inHole) {
const closestObject = this.board.getClosestObject(ball.pos)
if (closestObject.type == golfObjectType.DuellHole1) {
this.duellWinnerIndex = 0
} else {
this.duellWinnerIndex = 1
}
this.endDuell()
return true
}
}
update(hostTime=Date.now()) {
this.updatePhysics(hostTime)
if (gamePhase.isPlaying(this.phase)) {
if (this.mode == gameMode.Tournament) {
return this.updateTournament()
} else if (this.mode == gameMode.Sandbox) {
return this.updateSandbox()
} else if (this.mode == gameMode.Duell) {
return this.updateDuell()
}
}
}
}
const GRID_BLOCK_SIZE = 20
class Renderer {
static spriteImgMap = {}
static async loadImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
img.dataset.sprite = src
})
}
static async load() {
const promises = Object.values(Sprite).map(s => this.loadImg(s))
for (const img of await Promise.all(promises)) {
this.spriteImgMap[img.dataset.sprite] = img
}
}
static startSize = new Vector2d(40, 40)
static endSize = new Vector2d(50, 50)
static updateCanvasSize(context, resolution) {
if (resolution) {
context.canvas.width = resolution.x
context.canvas.height = resolution.y
} else {
context.canvas.width = context.canvas.clientWidth
context.canvas.height = context.canvas.clientHeight
}
}
static drawSprite(context, centerPos, size, sprite, {
angle = 0,
imageSmoothing = false
}={}) {
const img = this.spriteImgMap[sprite]
if (!img) {
throw new Error(`Unknown Sprite: ${sprite}`)
}
context.imageSmoothingEnabled = imageSmoothing // as some sprites may be very small in size
context.save()
context.translate(centerPos.x, centerPos.y)
context.rotate(angle)
context.drawImage(img, -size.x / 2, -size.y / 2, size.x, size.y)
context.restore()
}
static get screenUnit() {
return Math.min(window.innerWidth, window.innerHeight) * 0.1
}
static renderNothing(gameState, context, touchInfo) {
context.canvas.style.display = "none"
document.body.style.overflow = "visible"
const fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || document.fullscreenElement
if (fullscreenElement) {
if (document.exitFullscreen) {
document.exitFullscreen()
} else if (document.msExitFullscreen) {
document.msExitFullscreen()
} else if (document.mozCancelFullScreen) {
document.mozCancelFullScreen()
} else if (document.webkitCancelFullScreen) {
document.webkitCancelFullScreen()
}
}
}
static drawCircle(context, pos, radius) {
context.beginPath()
context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI, false)
}
static renderConnectionLines(gameState, context, touchInfo) {
for (const line of gameState.board.course.lines) {
context.beginPath()
const startPos = gameState.boardPosToScreenPos(line.start)
const endPos = gameState.boardPosToScreenPos(line.end)
context.moveTo(startPos.x, startPos.y)
context.lineTo(endPos.x, endPos.y)
context.lineWidth = GRID_BLOCK_SIZE / gameState.combinedScalingFactor
context.strokeStyle = line.color
context.lineCap = "round"
context.stroke()
}
}
static renderConstruction(gameState, context, touchInfo) {
const canvas = context.canvas
canvas.style.display = "block"
context.fillStyle = "#79FFB6"
context.fillRect(0, 0, canvas.width, canvas.height)
context.textBaseline = "middle"
context.textAlign = "center"
context.font = `${this.screenUnit * 3}px Arial`
context.fillStyle = "black"
context.fillText(gameState.deviceIndex + ".", canvas.width / 2, canvas.height / 2)
if (touchInfo.isDown) {
if (touchInfo.lastDownPos) {
context.beginPath()
context.moveTo(touchInfo.lastDownPos.x, touchInfo.lastDownPos.y)
context.lineTo(touchInfo.currPos.x, touchInfo.currPos.y)
context.lineWidth = 30
context.lineCap = "round"
context.strokeStyle = "#bac4ff"
context.stroke()
}
context.fillStyle = "blue"
this.drawCircle(context, touchInfo.currPos, 25)
context.fill()
}
this.renderConnectionLines(gameState, context, touchInfo)
}
static drawObjectOutline(gameState, context, object) {
const screenCorners = object.getInnerCorners(-10)
.map(c => gameState.boardPosToScreenPos(c))
context.beginPath()
context.moveTo(screenCorners[0].x, screenCorners[0].y)
for (let i = 0; i < screenCorners.length; i++) {
const index = (i + 1) % screenCorners.length
context.lineTo(screenCorners[index].x, screenCorners[index].y)
}
context.strokeStyle = "blue"
context.lineWidth = 3 / gameState.combinedScalingFactor
context.lineCap = "round"
context.stroke()
const dragCornerSize = new Vector2d(GRID_BLOCK_SIZE, GRID_BLOCK_SIZE).scale(2 / gameState.combinedScalingFactor)
this.drawSprite(context, gameState.boardPosToScreenPos(object.dragCorner),
dragCornerSize, Sprite.ZoomIcon, {imageSmoothing: true})
}
static fillShape(context, corners, color) {
context.beginPath()
context.moveTo(corners[0].x, corners[0].y)
for (let i = 0; i < corners.length; i++) {
const index = (i + 1) % corners.length
context.lineTo(corners[index].x, corners[index].y)
}
context.fillStyle = color
context.fill()
}
static drawCustomWall(gameState, context, object) {
const innerCorners = object.getInnerCorners(GRID_BLOCK_SIZE / 4 * Math.sqrt(2))
const screenCorners = object.corners.map(corner => {
return gameState.boardPosToScreenPos(corner)})
const screenInnerCorners = innerCorners.map(corner => {
return gameState.boardPosToScreenPos(corner)})
this.fillShape(context, screenCorners, gameState.board.styling.customWallOuter)
this.fillShape(context, screenInnerCorners, gameState.board.styling.customWallInner)
}
static drawGravityArrow(context, pos, direction) {
direction = direction.rotate(-Math.PI / 2)
context.save()
context.translate(pos.x, pos.y)
context.rotate(direction.angle)
context.scale(direction.length, direction.length)
context.beginPath()
context.moveTo(-0.5, 0)
context.lineTo(0.5, 0)
context.lineTo(0, 1)
context.lineTo(-0.5, 0)
context.fillStyle = "#5cfaa3"
context.fill()
context.restore()
}
static drawGravityArrows(gameState, context, touchInfo) {
let arrowDirection = gameState.board.course.phones[gameState.deviceIndex - 1].gravity
if (!arrowDirection) return
arrowDirection = arrowDirection.scale(200 / gameState.scalingFactor)
if (arrowDirection.length < 30 / gameState.scalingFactor) {
arrowDirection = arrowDirection.normalized.scale(30 / gameState.scalingFactor)
}
let pos = new Vector2d(0, 0)
let gridSize = Math.max(arrowDirection.length * 2, 100 / gameState.scalingFactor)
for (let x = gridSize / 2; x < context.canvas.width; x += gridSize) {
for (let y = gridSize / 2; y < context.canvas.height; y += gridSize) {
pos.set(x, y)
this.drawGravityArrow(context, pos, arrowDirection)
}
}
}
static renderBoard(gameState, context, touchInfo, {
drawBalls = true,
drawSelection = true,
drawGravity = false,
drawConnectionLines = false,
}={}) {
context.canvas.style.display = "block"
const backgroundSizePx = GRID_BLOCK_SIZE * 8 / gameState.combinedScalingFactor
const backgroundSizePercent = Math.max(backgroundSizePx / context.canvas.width * 100, 1)
context.canvas.style.backgroundSize = `${backgroundSizePercent}%`
context.canvas.style.backgroundImage = `url(${gameState.board.styling.gridSprite})`
if (drawConnectionLines) {
this.renderConnectionLines(gameState, context, touchInfo)
}
if (drawGravity) {
this.drawGravityArrows(gameState, context, touchInfo)
}
for (const object of gameState.board.objects) {
if (object.type == golfObjectType.CustomWall) {
this.drawCustomWall(gameState, context, object)
} else {
const screenPos = gameState.boardPosToScreenPos(object.pos)
this.drawSprite(context, screenPos,
object.size.scale(1 / gameState.combinedScalingFactor),
object.sprite, {angle: gameState.boardAngleToScreenAngle(object.angle)})
}
}
if (drawSelection && touchInfo.focusedObject) {
this.drawObjectOutline(gameState, context, touchInfo.focusedObject)
}
if (!drawBalls) {
return
}
const renderBalls = gameState.board.balls.slice()
renderBalls.sort((a, b) => {
if (b.active) return -1
else return 0
})
for (let ball of renderBalls) {
const screenPos = gameState.boardPosToScreenPos(ball.pos)
const size = new Vector2d(ball.radius, ball.radius).scale(2 / gameState.combinedScalingFactor)
if (!ball.active && !ball.isMoving()) {
context.globalAlpha = 0.5
}
context.save()
context.translate(screenPos.x, screenPos.y)
context.rotate(gameState.boardAngleToScreenAngle(ball.rotationAngle))
this.drawSprite(context, new Vector2d(0, 0), size, ball.spriteUrl)
context.restore()
context.globalAlpha = 1.0
}
if (gameState.board.particlesEnabled) {
for (const particle of gameState.board.particles) {
context.globalAlpha = particle.opacity
const screenPos = gameState.boardPosToScreenPos(particle.pos)
context.fillStyle = particle.color
const size = particle.radius / gameState.combinedScalingFactor
context.fillRect(screenPos.x, screenPos.y, size, size)
}
context.globalAlpha = 1.0
}
}
static renderBallInteractions(gameState, context, touchInfo) {
if (!touchInfo.isDown || !touchInfo.focusedBall || !touchInfo.currPos) {
return
}
const ballScreenPos = gameState.boardPosToScreenPos(touchInfo.focusedBall.pos)
context.beginPath()
context.moveTo(ballScreenPos.x, ballScreenPos.y)
context.lineTo(touchInfo.currPos.x, touchInfo.currPos.y)
context.strokeStyle = gameState.board.styling.pullColor
context.lineWidth = touchInfo.focusedBall.radius / gameState.combinedScalingFactor
context.lineCap = "round"
context.stroke()
}
static renderPlacingTools(gameState, context, touchInfo) {
if (gameState.placingObjectType == golfObjectType.Eraser
&& touchInfo.isDown && touchInfo.currPos
) {
this.drawSprite(context, touchInfo.currPos, new Vector2d(60, 60), Sprite.Eraser,
{angle: gameState.boardAngleToScreenAngle(0)})
}
}
static renderChallengeBalls(gameState, context, touchInfo, challengeBalls) {
const fontSize = context.canvas.height * 0.06
const padding = 10
context.font = `bold ${fontSize}px monospace`
context.fillStyle = "black"
context.textAlign = "left"
context.textBaseline = "top"
context.fillText(challengeBalls, padding + fontSize, 10)
const ballSprite = gameState.board.balls[0]?.spriteUrl ?? Sprite.BallWhite
this.drawSprite(context, new Vector2d(1, 1).scale(padding + fontSize * 0.4),
new Vector2d(1, 1).scale(fontSize * 0.8), ballSprite)
}
static render(gameState, context, touchInfo, {
preventScrolling = true,
challengeBalls = undefined,
resolution = undefined
}={}) {
this.updateCanvasSize(context, resolution)
if (preventScrolling) {
document.body.style.overflow = "hidden"
}
if ([
gamePhase.ConstructionChoice,
gamePhase.ConstructionAuto,
gamePhase.ConstructionCustom
].includes(gameState.phase)) {
return this.renderConstruction(gameState, context, touchInfo)
}
if (gameState.phase == gamePhase.Placing) {
this.renderBoard(gameState, context, touchInfo,
{drawBalls: false, drawGravity: false, drawConnectionLines: true})
return this.renderPlacingTools(gameState, context, touchInfo)
}
if (gamePhase.isPlaying(gameState.phase)) {
this.renderBoard(gameState, context, touchInfo, {drawSelection: false, drawGravity: false})
if (challengeBalls !== undefined) {
this.renderChallengeBalls(gameState, context, touchInfo, challengeBalls)
}
return this.renderBallInteractions(gameState, context, touchInfo)
}
return this.renderNothing(gameState, context, touchInfo)
}
}
const golfObjectType = {
Start: "Start",
Hole: "Hole",
Lava: "Lava",
Cannon: "Cannon",
Eraser: "Eraser",
DuellHole1: "Hole 1",
DuellHole2: "Hole 2",
CustomWall: "Extra Wall",
GravityBox: "Gravity Box"
}
let golfObjectTypeSpriteMap = {
[golfObjectType.Start]: Sprite.Start,
[golfObjectType.Hole]: Sprite.Hole,
[golfObjectType.Lava]: Sprite.Lava,
[golfObjectType.Cannon]: Sprite.Cannon,
[golfObjectType.Eraser]: Sprite.Eraser,
[golfObjectType.DuellHole1]: Sprite.DuellHole1,
[golfObjectType.DuellHole2]: Sprite.DuellHole2,
[golfObjectType.CustomWall]: Sprite.CustomWall,
[golfObjectType.GravityBox]: Sprite.GravityBox
}
class GolfObject {
static makeRandomUid() {
return Math.random().toString().slice(2)
}
constructor(type, pos, size, angle, uid, resizable) {
this.type = type
this.pos = pos ?? new Vector2d(0, 0)
this.size = size ?? new Vector2d(40, 40)
this.angle = angle ?? 0
this.uid = uid ?? GolfObject.makeRandomUid()
this.resizable = resizable ?? false
this.visibility = () => true
}
setPos(pos) {
this.pos = pos
return this
}
translate(point) {
this.pos.iadd(point)
}
rotate(angle) {
this.pos.irotate(angle)
this.angle += angle
}
scale(scalar) {
this.pos.iscale(scalar)
this.size.iscale(scalar)
}
get topLeftPos() {
return this.pos.sub(this.size.scale(0.5).rotate(this.angle))
}
get relativeCorners() {
const halfSize = this.size.scale(0.5)
return [
halfSize.scale(-1),
halfSize.scaleY(-1),
halfSize,
halfSize.scaleX(-1)
].map(v => v.rotate(this.angle))
}
get corners() {
return this.relativeCorners.map(c => c.add(this.pos))
}
get walls() {
const corners = this.corners
return [
[corners[0], corners[1]],
[corners[1], corners[2]],
[corners[2], corners[3]],
[corners[3], corners[0]],
]
}
getInnerCorners(innerCornerDistance) {
const corners = this.corners
const innerCorners = []
for (let i = 0; i < corners.length; i++) {
const prevCorner = corners[i > 0 ? i - 1 : corners.length - 1]
const currCorner = corners[i]
const nextCorner = corners[(i + 1) % corners.length]
const prevDelta = prevCorner.sub(currCorner).normalized
const nextDelta = nextCorner.sub(currCorner).normalized
const innerNormDelta = prevDelta.add(nextDelta).normalized
const innerPoint = currCorner.add(innerNormDelta.scale(innerCornerDistance))
innerCorners.push(innerPoint)
}
return innerCorners
}
get dragCorner() {
return this.getInnerCorners(-10)[0]
}
intersects(point) {
const topLeft = this.topLeftPos.rotate(-this.angle)
const rotatedPoint = point.rotate(-this.angle)
return (
topLeft.x <= rotatedPoint.x && rotatedPoint.x <= (topLeft.x + this.size.x) &&
topLeft.y <= rotatedPoint.y && rotatedPoint.y <= (topLeft.y + this.size.y)
)
}
get radius() {
return this.topLeftPos.distance(this.pos)
}
set radius(newRadius) {
this.size = this.size.normalized.scale(newRadius * 2)
}
toObject() {
return {
t: this.type,
p: this.pos.toObject(),
s: this.size.toObject(),
a: this.angle,
u: this.uid,
r: this.resizable
}
}
static fromObject(obj) {
return new GolfObject(
obj.t ?? obj.type,
Vector2d.fromObject(obj.p ?? obj.pos),
Vector2d.fromObject(obj.s ?? obj.size),
obj.a ?? obj.angle,
obj.u ?? obj.uid,
obj.r ?? obj.resizable
)
}
get sprite() {
return golfObjectTypeSpriteMap[this.type]
}
copy() {
return GolfObject.fromObject(this.toObject())
}
setResizable(val) {
this.resizable = val
return this
}
setSize(size) {
this.size = size
return this
}
setAngle(angle) {
this.angle = angle
return this
}
setVisibility(func) {
this.visibility = func
return this
}
get name() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStart
case golfObjectType.Hole:
return Text.ObjectHole
case golfObjectType.Lava:
return Text.ObjectLava
case golfObjectType.Cannon:
return Text.ObjectCannon
case golfObjectType.Eraser:
return Text.ObjectEraser
case golfObjectType.DuellHole1:
return Text.ObjectDuellHole("1")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHole("2")
case golfObjectType.CustomWall:
return Text.ObjectCustomWall
case golfObjectType.GravityBox:
return Text.ObjectGravityBox
}
return ""
}
get description() {
switch (this.type) {
case golfObjectType.Start:
return Text.ObjectStartDescription
case golfObjectType.Hole:
return Text.ObjectHoleDescription
case golfObjectType.Lava:
return Text.ObjectLavaDescription
case golfObjectType.Cannon:
return Text.ObjectCannonDescription
case golfObjectType.Eraser:
return Text.ObjectEraserDescriptiom
case golfObjectType.DuellHole1:
return Text.ObjectDuellHoleDescription("<duell-player-1>")
case golfObjectType.DuellHole2:
return Text.ObjectDuellHoleDescription("<duell-player-2>")
case golfObjectType.CustomWall:
return Text.ObjectCustomWallDescription
case golfObjectType.GravityBox:
return Text.ObjectGravityBoxDescription
}
return ""
}
static makeDefault(type) {
const obj = defaultObjects[type].copy()
obj.uid = GolfObject.makeRandomUid()
return obj
}
}
const placableObjects = [
new GolfObject(golfObjectType.Start),
new GolfObject(golfObjectType.Hole).setVisibility(gs => gs.mode != gameMode.Duell),
new GolfObject(golfObjectType.Lava).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.Cannon).setSize(new Vector2d(80, 80)),
new GolfObject(golfObjectType.CustomWall).setSize(new Vector2d(120, 40)).setResizable(true),
new GolfObject(golfObjectType.GravityBox).setSize(new Vector2d(80, 80)).setResizable(true),
new GolfObject(golfObjectType.DuellHole1).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.DuellHole2).setVisibility(gs => gs.mode == gameMode.Duell),
new GolfObject(golfObjectType.Eraser),
]
const defaultObjects = {
[golfObjectType.Start]: placableObjects[0],
[golfObjectType.Hole]: placableObjects[1],
[golfObjectType.Lava]: placableObjects[2],
[golfObjectType.Cannon]: placableObjects[3],
[golfObjectType.CustomWall]: placableObjects[4],
[golfObjectType.GravityBox]: placableObjects[5],
[golfObjectType.DuellHole1]: placableObjects[6],
[golfObjectType.DuellHole2]: placableObjects[7],
}
class ScoreboardMaker {
static scoreboardHeaderImgSrc = "../assets/scoreboard-header.png"
static async getImg(src) {
return new Promise(resolve => {
const img = new Image()
img.onload = () => resolve(img)
img.src = src
})
}
static drawLine(context, p1, p2, width=2, color="black") {
context.beginPath()
context.strokeStyle = color
context.lineWidth = width
context.moveTo(p1.x, p1.y)
context.lineTo(p2.x, p2.y)
context.stroke()
}
static async makeImg(players) {
const canvas = document.createElement("canvas")
const context = canvas.getContext("2d")
const headerImg = await this.getImg(this.scoreboardHeaderImgSrc)
const fontFamily = "Arial"
const fontSize = 40
context.font = `${fontSize}px ${fontFamily}`
const imagePadding = 20
const tablePadding = 20
const tableOffset = new Vector2d(0, 0)
const headerImgPadding = 40
const rowHeight = 30
const minNameWidth = context.measureText("00").width
const nameWidths = players.map(p => Math.max(context.measureText(p.name).width, minNameWidth))
const columnWidths = [context.measureText("000").width].concat(nameWidths)
const columnXs = []
const rowYs = []
let sum = 0
for (let i = 0; i < columnWidths.length; i++) {
columnXs.push(sum + tablePadding + tableOffset.x + imagePadding)
sum += columnWidths[i] + tablePadding * 2
}
const columnWidthSum = columnWidths.reduce((p, c) => p + c, 0)
const imgWidth = imagePadding * 2 + columnWidthSum + columnWidths.length * 2 * tablePadding
const headerImgWidth = Math.min(imgWidth - imagePadding * 2, 400)
const headerImgHeight = headerImgWidth * (headerImg.naturalHeight / headerImg.naturalWidth)
const imgHeight = imagePadding * 2 + headerImgHeight + headerImgPadding + (columnWidths.length + 1) * (rowHeight + tablePadding * 2)
for (let i = 0; i < columnWidths.length + 1; i++) {
rowYs.push(i * (rowHeight + tablePadding * 2) + tablePadding + imagePadding + headerImgHeight + headerImgPadding)
}
canvas.width = imgWidth
canvas.height = imgHeight
context.font = `${fontSize}px ${fontFamily}`
context.fillStyle = "white"
context.fillRect(0, 0, canvas.width, canvas.height)
context.drawImage(headerImg, imagePadding, imagePadding, headerImgWidth, headerImgHeight)
const tableContent = Array.from({length: rowYs.length})
.map(() => Array.from({length: columnXs.length}, () => ""))
tableContent[0][0] = "R#"
for (let i = 0; i < players.length; i++) {
tableContent[0][i + 1] = players[i].name
tableContent[players.length + 1][i + 1] = players[i].score.toString()
tableContent[i + 1][0] = "  " + (i + 1).toString()
for (let r = 0; r < players[i].roundScores.length; r++) {
const score = players[i].roundScores[r]
tableContent[r + 1][i + 1] = score.toString()
}
}
const tablePos = (r, c) => new Vector2d(columnXs[c], rowYs[r])
context.fillStyle = "black"
for (let colIndex = 0; colIndex < columnXs.length; colIndex++) {
for (let rowIndex = 0; rowIndex < rowYs.length; rowIndex++) {
const pos = tablePos(rowIndex, colIndex)
if (rowIndex == rowYs.length - 1) {
context.font = `bold ${fontSize}px ${fontFamily}`
} else {
context.font = `${fontSize}px ${fontFamily}`
}
context.fillText(tableContent[rowIndex][colIndex], pos.x, pos.y)
}
}
for (let i = 0; i < players.length - 1; i++) {
this.drawLine(context,
tablePos(i + 1, 1).addY(tablePadding).addX(-tablePadding),
tablePos(i + 1, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 2, "#ccc")
this.drawLine(context,
tablePos(1, i + 2).addX(-tablePadding).addY(-rowHeight - tablePadding),
tablePos(players.length, i + 2).addX(-tablePadding)
.addY(tablePadding * 2 + rowHeight), 2, "#ccc")
}
this.drawLine(context,
tablePos(0, 0).addY(tablePadding),
tablePos(0, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 3)
this.drawLine(context,
tablePos(players.length, 0).addY(tablePadding),
tablePos(players.length, players.length).addY(tablePadding)
.addX(columnWidths[players.length]), 3)
this.drawLine(context,
tablePos(0, 1).addX(-tablePadding).addY(-rowHeight),
tablePos(players.length, 1).addX(-tablePadding)
.addY(tablePadding * 2 + rowHeight), 3)
for (let i = 0; i < players.length; i++) {
}
return canvas.toDataURL()
}
}
class BoardGenerator {
constructor(screenSizes) {
this.screenSizes = screenSizes
}
generateLinearCourse() {
const phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
const course = new Course([phones.shift()])
while (phones.length) {
const prevPhone = course.phones.slice(-1)[0]
const phone = phones.shift()
const bottomMidX = (prevPhone.bottomLeft.x + prevPhone.bottomRight.x) / 2
const topMidX = (phone.topLeft.x + phone.topRight.x) / 2
phone.translate(new Vector2d(bottomMidX - topMidX, prevPhone.maxXY.y))
course.addPhone(phone)
}
return course
}
getConnectingLines(prevPhone, phone) {
return [
new PhoneConnectionLine(
new Vector2d(0, 0),
new Vector2d(Math.min(prevPhone.size.x, phone.size.x), 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, 0),
new Vector2d(prevPhone.size.x, Math.min(phone.size.y, prevPhone.size.y))
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.maxXY.x - phone.maxXY.x, 0), prevPhone.size.y),
new Vector2d(prevPhone.size.x, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, Math.max(0, prevPhone.maxXY.y - phone.maxXY.y)),
new Vector2d(0, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.maxXY.x - phone.maxXY.x, 0), 0),
new Vector2d(prevPhone.size.x, 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, Math.max(0, prevPhone.maxXY.y - phone.maxXY.y)),
new Vector2d(prevPhone.size.x, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, prevPhone.size.y),
new Vector2d(Math.min(prevPhone.size.x, phone.size.x), prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, 0),
new Vector2d(0, Math.min(phone.size.y, prevPhone.size.y))
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, 0),
new Vector2d(prevPhone.size.x - Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, 0)
),
new PhoneConnectionLine(
new Vector2d(prevPhone.size.x, Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2),
new Vector2d(prevPhone.size.x, prevPhone.size.y - Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2)
),
new PhoneConnectionLine(
new Vector2d(Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, prevPhone.size.y),
new Vector2d(prevPhone.size.x - Math.max(prevPhone.minXY.x + prevPhone.maxXY.x - phone.minXY.x - phone.maxXY.x, 0) / 2, prevPhone.size.y)
),
new PhoneConnectionLine(
new Vector2d(0, Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2),
new Vector2d(0, prevPhone.size.y - Math.max(prevPhone.minXY.y + prevPhone.maxXY.y - phone.minXY.y - phone.maxXY.y, 0) / 2)
),
]
}
getPhoneAlignOptions(prevPhone, phone) {
return [
new Vector2d(0, -phone.size.y),
new Vector2d(prevPhone.size.x, 0),
new Vector2d(prevPhone.maxXY.x - phone.maxXY.x, prevPhone.size.y),
new Vector2d(-phone.size.x, prevPhone.maxXY.y - phone.maxXY.y),
new Vector2d(prevPhone.maxXY.x - phone.maxXY.x, -phone.size.y),
new Vector2d(prevPhone.size.x, prevPhone.maxXY.y - phone.maxXY.y),
new Vector2d(0, prevPhone.size.y),
new Vector2d(-phone.size.x, 0),
new Vector2d(
(prevPhone.minXY.x + prevPhone.maxXY.x
- phone.minXY.x - phone.maxXY.x) / 2,
-phone.size.y
),
new Vector2d(
prevPhone.size.x,
(prevPhone.minXY.y + prevPhone.maxXY.y
- phone.minXY.y - phone.maxXY.y) / 2,
),
new Vector2d(
(prevPhone.minXY.x + prevPhone.maxXY.x
- phone.minXY.x - phone.maxXY.x) / 2,
prevPhone.size.y
),
new Vector2d(
-phone.size.x,
(prevPhone.minXY.y + prevPhone.maxXY.y
- phone.minXY.y - phone.maxXY.y) / 2,
),
]
}
getStartHolePositions(phone) {
return [
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0),
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0),
new Vector2d(0, phone.size.y / 4),
new Vector2d(-phone.size.x / 4, 0),
new Vector2d(0, -phone.size.y / 4),
new Vector2d(phone.size.x / 4, 0)
]
}
generateRandomCourse({linear=false}={}) {
let phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
let course = new Course([phones.shift()])
course.alignOptions = []
let phoneTries = 0
let totalTries = 0
while (phones.length) {
const prevPhone = course.phones.slice(-1)[0]
const phone = phones.shift()
if ((!linear && Math.random() < 0.5) || (linear && phone.size.x > phone.size.y)) {
phone.rotate(Math.PI / 2)
}
phone.translate(prevPhone.minXY.sub(phone.minXY))
const translateOptions = this.getPhoneAlignOptions(prevPhone, phone)
let alignOption = Math.floor(Math.random() * translateOptions.length)
if (linear) alignOption = 10
course.alignOptions.push(alignOption)
const lineOptions = this.getConnectingLines(prevPhone, phone)
course.addLine(lineOptions[alignOption].translate(phone.minXY))
phone.translate(translateOptions[alignOption])
course.addPhone(phone)
const previousPhones = course.phones.slice(0, -2)
const overlapsPrevious = previousPhones.some(p => {
return p.hasOverlap(phone)
})
if (overlapsPrevious) {
phones.unshift(course.phones.pop())
course.alignOptions.pop()
course.lines.pop()
phoneTries++
} else {
phoneTries = 0
}
if (phoneTries > 20) {
phones = this.screenSizes.map(size => {
return PhoneCoordinates.fromWidthHeight(size.x, size.y)
})
course.alignOptions = []
course.phones = [phones.shift()]
course.lines = []
phoneTries = 0
totalTries++
}
if (totalTries > 10000) {
throw new Error("Couldn't generate course [too many tries]")
}
}
return course
}
placeStartAndHole(board) {
const start = defaultObjects[golfObjectType.Start].copy()
const hole = defaultObjects[golfObjectType.Hole].copy()
if (board.course.phones.length > 1) {
const firstAlignOption = board.course.alignOptions[0]
let lastAlignOption = board.course.alignOptions.slice(-1)[0]
lastAlignOption = Math.floor(lastAlignOption / 4) * 4 + ((lastAlignOption + 2) % 4)
const translateStartOptions = this.getStartHolePositions(board.course.phones[0])
const translateHoleOptions = this.getStartHolePositions(board.course.phones.slice(-1)[0])
const firstMiddle = calcAveragePos(board.course.phones[0].points)
const lastMiddle = calcAveragePos(board.course.phones.slice(-1)[0].points)
start.setPos(firstMiddle.add(translateStartOptions[firstAlignOption]))
hole.setPos(lastMiddle.add(translateHoleOptions[lastAlignOption]))
} else {
const middle = calcAveragePos(board.course.phones[0].points)
const delta = middle.sub(board.course.phones[0].corners[0]).scale(0.6)
start.setPos(middle.sub(delta))
hole.setPos(middle.add(delta))
}
board.objects.push(start, hole)
}
generate() {
const board = new Board()
board.course = this.generateRandomCourse({linear: Math.random() < 0.1})
this.placeStartAndHole(board)
return board
}
static async placeObjectsRandomly(board, {
objectType = golfObjectType.Lava,
maxTries = 10,
numObjects = 3
}={}) {
function kickAllBallsRandom() {
for (const ball of board.balls) {
const speed = 100 + Math.random() * 50
const angle = Math.random() * Math.PI * 2
const dir = Vector2d.fromAngle(angle).scale(speed)
ball.kick(dir)
}
}
async function testWithBalls({
numBalls = 100,
numKicks = board.course.phones.length * 2,
stepsPerKick = 100
}={}) {
if (!board.startPos || board.endPositions.length == 0) {
return true
}
const prevBallCollisionEnabled = board.ballCollisionEnabled
board.ballCollisionEnabled = false
let balls = []
for (let i = 0; i < numBalls; i++) {
const ball = board.spawnBall()
balls.push(ball)
}
for (let n = 0; n < numKicks; n++) {
board.addPhysicsEvent(kickAllBallsRandom, n * stepsPerKick + 1)
}
for (let i = 0; i < numKicks; i++) {
board.simulateStepsEfficiently(stepsPerKick)
await new Promise(resolve => setTimeout(resolve, 0))
}
board.ballCollisionEnabled = prevBallCollisionEnabled
const success = balls.some(b => b.inHole)
const ballUids = balls.map(b => b.uid)
board.balls = board.balls.filter(b => !ballUids.includes(b.uid))
return success
}
function getRandomCoursePos() {
let randomPhone = undefined
const areaSum = board.course.phones.reduce((p, c) => p + c.area, 0)
const r = Math.random() * areaSum
let cumulativeSum = 0
for (const phone of board.course.phones) {
cumulativeSum += phone.area
if (cumulativeSum >= r) {
randomPhone = phone
break
}
}
console.assert(randomPhone !== undefined)
return randomPhone.randomPosInside()
}
for (let i = 0; i < maxTries; i++) {
const addedObjectUids = []
for (let i = 0; i < numObjects; i++) {
const randomLava = GolfObject.makeDefault(objectType)
randomLava.setPos(getRandomCoursePos())
randomLava.setAngle(Math.random() * 2 * Math.PI)
randomLava.setSize(randomLava.size.scale(0.8 + Math.random() * 0.4))
board.objects.push(randomLava)
addedObjectUids.push(randomLava.uid)
}
if (await testWithBalls()) {
return true
} else {
board.objects = board.objects.filter(o => !addedObjectUids.includes(o.uid))
}
}
return false
}
}
class AudioPlayer {
static spriteAudioMap = {}
static spriteIndexMap = {}
static soundsEnabled = true
static speechEnabled = true
static loadAudio(src) {
return new Promise((resolve, reject) => {
const element = document.createElement("audio")
element.style.display = "none"
document.body.appendChild(element)
element.addEventListener("canplaythrough", resolve)
element.addEventListener("error", reject)
element.src = src
element.preload = "true"
element.load()
this.spriteAudioMap[src].push(element)
setTimeout(resolve, 500)
})
}
static hasLoaded = false
static async load() {
if (this.hasLoaded) {
return
}
for (const src of Object.values(AudioSprite)) {
this.spriteAudioMap[src] = []
this.spriteIndexMap[src] = 0
}
const promises = []
for (let i = 0; i < 5; i++) {
promises.push(...Object.values(AudioSprite).map(s => this.loadAudio(s)))
}
await Promise.all(promises)
this.hasLoaded = true
}
static play(sprite, {volume=1.}={}) {
if (!this.soundsEnabled || !this.hasLoaded) {
return
}
if (!this.spriteAudioMap[sprite]) {
return
}
this.load()
const audios = this.spriteAudioMap[sprite]
const index = (this.spriteIndexMap[sprite]++) % audios.length
const audio = audios[index]
if (!audio) {
return
}
audio.volume = volume
return audio.play()
}
static randomNote({volume=1.}={}) {
const index = Math.floor(Math.random() * allNoteSprites.length)
return this.play(allNoteSprites[index], {volume: volume})
}
static plop() {
return this.play(AudioSprite.Plop)
}
static say(text, {rate = 1., lang="de-DE"}={}) {
if (!this.speechEnabled || !window.speechSynthesis) {
return
}
const message = new SpeechSynthesisUtterance()
message.text = text
message.rate = rate
message.lang = lang
window.speechSynthesis.speak(message)
}
}
const levelpacksContainer = document.querySelector("#level-packs")
const levelCompleteLocalStorageKey = "monogolf-completed-levels"
const levelHighscoreLocalStorageKey = packId => `mono-highscore-${packId}`
function getUnlockedLevels() {
const item = localStorage.getItem(levelCompleteLocalStorageKey)
if (!item) return new Set()
const ids = item.toString().split(",")
.map(n => n.trim())
return new Set(ids)
}
function getHighscore(packId) {
return localStorage.getItem(levelHighscoreLocalStorageKey(packId))
}
function setHighscore(packId, score) {
let highscore = getHighscore(packId)
if (highscore !== null && highscore >= score) {
return
}
localStorage.setItem(levelHighscoreLocalStorageKey(packId), score)
}
function unlockLevel(packId, id) {
const unlocked = getUnlockedLevels()
unlocked.add(`${packId}:${id}`)
const str = Array.from(unlocked).join(",")
localStorage.setItem(levelCompleteLocalStorageKey, str)
}
function resetUnlockedLevels() {
localStorage.removeItem(levelCompleteLocalStorageKey)
}
function hasUnlockedLevel(packId, id) {
if (id <= 1) return true
const completed = getUnlockedLevels()
return completed.has(`${packId}:${id}`)
}
async function loadLevelData(path) {
const response = await fetch(path)
const data = await response.json()
return data
}
function makeLevelPackHtml(levelPackConfig) {
const levelPackContainer = document.createElement("div")
const header = document.createElement("div")
const headerH2 = document.createElement("h2")
const difficulty = document.createElement("p")
const description = document.createElement("p")
const author = document.createElement("p")
const levelsContainer = document.createElement("div")
const startChallengeButton = document.createElement("a")
const highscoreText = document.createElement("p")
levelPackContainer.classList.add("level-pack")
header.classList.add("header")
difficulty.classList.add("difficulty")
description.classList.add("description")
author.classList.add("author")
levelsContainer.classList.add("levels-container")
startChallengeButton.classList.add("linkbutton")
highscoreText.classList.add("highscore-text")
const highscore = getHighscore(levelPackConfig.id)
const lang = document.documentElement.lang
headerH2.textContent = levelPackConfig.name[lang]
difficulty.textContent = levelPackConfig["difficulty-name"][lang]
description.textContent = levelPackConfig.description[lang]
author.textContent = levelPackConfig.author
startChallengeButton.textContent = Text.StartChallenge
highscoreText.textContent = Text.YourPackHighscore(levelPackConfig.name[lang], highscore)
startChallengeButton.href = `../level?pack=${encodeURIComponent(levelPackConfig.id)}&challenge=true&id=1`
for (let i = 0; i < levelPackConfig.num_levels; i++) {
const element = document.createElement("a")
element.classList.add("level")
if (hasUnlockedLevel(levelPackConfig.id, i + 1)) {
element.classList.add("completed")
element.href = `../level?pack=${encodeURIComponent(levelPackConfig.id)}&id=${encodeURIComponent(i + 1)}`
}
element.dataset.difficulty = levelPackConfig.difficulty
element.textContent = i + 1
levelsContainer.appendChild(element)
}
header.appendChild(headerH2)
header.appendChild(difficulty)
levelPackContainer.appendChild(header)
levelPackContainer.appendChild(description)
levelPackContainer.appendChild(author)
levelPackContainer.appendChild(levelsContainer)
levelPackContainer.appendChild(startChallengeButton)
if (highscore !== null) {
levelPackContainer.appendChild(highscoreText)
}
return levelPackContainer
}
async function updateHtmlLevels() {
const levelPackConfigs = await loadLevelData("level-data/all-packs.json")
const difficultyMap = {
"easy": 1, "medium": 2, "hard": 3
}
levelPackConfigs.sort((a, b) => {
return difficultyMap[a.difficulty] - difficultyMap[b.difficulty]
})
for (const levelPackConfig of levelPackConfigs) {
const levelPackContainer = makeLevelPackHtml(levelPackConfig)
levelpacksContainer.appendChild(levelPackContainer)
}
}
let level = null
let levelConfig = null
let levels = []
let gameState = null
let ball = null
const touchInfo = {
isDown: false,
lastDownPos: null,
lastUpPos: null,
currPos: null,
lastDownTime: null,
lastUpTime: null,
focusedBall: null,
focusedObject: null,
draggingObject: false
}
function onEventDown(event) {
touchInfo.isDown = true
touchInfo.currPos = Vector2d.fromTouchEvent(event, levelCanvas)
touchInfo.lastDownPos = touchInfo.currPos.copy()
touchInfo.lastDownTime = Date.now()
if (!gameState) return
const boardPos = gameState.screenPosToBoardPos(touchInfo.currPos)
let smallestDistance = Infinity
let closestBall = null
for (const ball of gameState.board.balls) {
if (ball.isInMovement() || !ball.active) {
continue
}
const distance = ball.pos.distance(boardPos)
if (distance < smallestDistance) {
smallestDistance = distance
closestBall = ball
}
}
if (smallestDistance < 100) {
touchInfo.focusedBall = closestBall
}
}
function onEventMove(event) {
touchInfo.currPos = Vector2d.fromTouchEvent(event, levelCanvas)
}
function onEventUp(event) {
touchInfo.isDown = false
touchInfo.currPos = null
touchInfo.lastUpPos = Vector2d.fromTouchEvent(event, levelCanvas)
touchInfo.lastUpTime = Date.now()
if (!touchInfo.focusedBall || !touchInfo.lastDownPos || !touchInfo.lastUpPos || !gameState) {
return
}
const lastUpScreenPos = gameState.screenPosToBoardPos(touchInfo.lastUpPos)
const strength = Math.min(touchInfo.focusedBall.pos.distance(lastUpScreenPos) * 0.2, 50)
const touchUpBoardPos = gameState.screenPosToBoardPos(touchInfo.lastUpPos)
const direction = touchInfo.focusedBall.pos.sub(touchUpBoardPos).normalized.scale(-strength)
touchInfo.focusedBall.kick(direction)
challengeKicks--
localStorage.setItem("challenge-kicks", challengeKicks)
touchInfo.focusedBall = null
touchInfo.draggingObject = false
}
const canvasAspectRatio = 9 / 16
const displayAspectRatio = 9 / 17
const directionLoopLengthMs = 2000
const levelCanvas = document.querySelector("#level-canvas")
const levelBody = document.querySelector(".level-body")
const levelHeader = document.querySelector(".level-header")
const levelContainer = document.querySelector(".level-container")
const levelContext = levelCanvas.getContext("2d")
const logoImg = document.querySelector("#logo-img")
const levelIdOutput = document.querySelector("#level-id-output")
if (!hasUnlockedLevel(packId, levelId) && levelId != "editor" && !challengeMode) {
goBackToLevelChoice()
}
document.body.addEventListener("touchstart", onEventDown)
document.body.addEventListener("touchmove", onEventMove)
document.body.addEventListener("touchend", onEventUp)
document.body.addEventListener("mousedown", onEventDown)
document.body.addEventListener("mousemove", onEventMove)
document.body.addEventListener("mouseup", onEventUp)
let hasGoneToNextLevel = false
async function goToNextLevel() {
if (hasGoneToNextLevel) {
return
}
if (levelId == "editor") {
return loadLevel("editor")
}
hasGoneToNextLevel = true
const nextLevelId = parseInt(levelId) + 1
const nextLevelExists = levels.find(l => l.id == nextLevelId)
if (!nextLevelExists && challengeKicks >= 0 && challengeMode) {
localStorage.removeItem("challenge-kicks")
setHighscore(packId, challengeKicks)
await customAlert(Text.YouWonLong(challengeKicks), {header: Text.YouWon})
}
if (nextLevelExists && hasUnlockedLevel(packId, nextLevelId)) {
loadLevel(nextLevelId)
} else {
return goBackToLevelChoice()
}
challengeKicks++
localStorage.setItem("challenge-kicks", challengeKicks)
}
function resizeCanvas() {
if (gameState) {
canvasPadding = Math.round(5 / gameState.combinedScalingFactor)
}
const displaySize = new Vector2d(100 * displayAspectRatio, displayAspectRatio)
const maxWidth = window.innerWidth - 20
const maxHeight = window.innerHeight - 20
const realSizeRatio = maxWidth / maxHeight
if (realSizeRatio < displayAspectRatio) {
displaySize.x = maxWidth
displaySize.y = maxWidth / displayAspectRatio
} else {
displaySize.y = maxHeight
displaySize.x = maxHeight * displayAspectRatio
}
const canvasBodyHeight = displayAspectRatio / canvasAspectRatio * displaySize.y
const canvasHeaderHeight = displaySize.y - canvasBodyHeight
levelContainer.style.width = `${displaySize.x}px`
levelContainer.style.height = `${displaySize.y}px`
levelContainer.style.gridTemplateRows = `${canvasHeaderHeight}px ${canvasBodyHeight}px`
levelCanvas.style.width = `${displaySize.x}px`
levelCanvas.style.height = `${canvasBodyHeight}px`
levelHeader.style.width = `${displaySize.x}px`
levelHeader.style.height = `${canvasHeaderHeight}px`
levelHeader.style.setProperty("--height", `${canvasHeaderHeight}px`)
}
let isLoading = true
const startTimestamp = Date.now()
function drawLoading() {
if (!logoImg.complete) {
return
}
const t = ((Date.now() - startTimestamp) % 1000) / 1000
const logoSize = Math.min(levelCanvas.width, levelCanvas.height) * 0.5
levelCanvas.width = levelCanvas.clientWidth
levelCanvas.height = levelCanvas.clientHeight
levelContext.save()
levelContext.translate(levelCanvas.width / 2, levelCanvas.height / 2)
levelContext.rotate(t * Math.PI * 2)
levelContext.drawImage(logoImg, -logoSize / 2, -logoSize / 2, logoSize, logoSize)
levelContext.restore()
}
setInterval(() => {
if (isLoading) {
drawLoading()
}
})
async function gameLoop() {
gameState.update()
const challengeBalls = challengeMode ? challengeKicks : undefined
Renderer.render(gameState, levelContext, touchInfo, {
challengeBalls,
})
if (ball && ball.inHole && ball.radius == 0) {
unlockLevel(packId, level.id + 1)
goToNextLevel()
}
if (challengeMode && challengeKicks <= 0 && !ball.isInMovement() && !ball.inHole) {
localStorage.removeItem("challenge-kicks")
if (await customConfirm(Text.WantToTryAgain, {header: Text.YouLost})) {
location.reload()
} else {
goBackToLevelChoice()
}
}
window.requestAnimationFrame(gameLoop)
}
function loadLevel(id) {
if (id == "editor") {
try {
levelId = "editor"
const str = localStorage.getItem("level-maker-temp")
level = {
id: 0,
difficulty: "easy",
gameState: JSON.parse(str)
}
levelIdOutput.textContent = "??"
} catch (e) {
goBackToLevelChoice()
}
} else {
level = levels.find(l => l.id == id)
levelId = id
levelIdOutput.textContent = levelId.toString().padStart(2, "0")
}
if (!level) {
goBackToLevelChoice()
}
gameState = GameState.fromObject(level.gameState)
gameState.phase = gamePhase.PlayingSandbox
gameState.getReferenceCanvas = () => levelCanvas
gameState.board.physicsTime = Date.now()
gameState.board.particlesEnabled = true
let ballSprite = "random"
if (levelConfig && levelConfig.styling) {
if (levelConfig.styling.grid)
gameState.board.styling.gridSprite = URL_BASE_PATH + levelConfig.styling.grid
if (levelConfig.styling.ball)
ballSprite = URL_BASE_PATH + levelConfig.styling.ball
if (levelConfig.styling.colors) {
const colors = levelConfig.styling.colors
if (colors.customWallInner)
gameState.board.styling.customWallInner = colors.customWallInner
if (colors.customWallOuter)
gameState.board.styling.customWallOuter = colors.customWallOuter
if (colors.pullColor)
gameState.board.styling.pullColor = colors.pullColor
}
}
ball = gameState.board.spawnBall({spriteUrl: ballSprite})
const url = new URL(window.location.href)
url.searchParams.set("id", levelId)
window.history.pushState(null, "", url.toString())
if (challengeMode) {
localStorage.setItem("challenge-level", levelId)
}
hasGoneToNextLevel = false
}
async function downloadPack(url) {
const result = await fetch(url)
const data = await result.json()
levels.push(...data.levels)
levelConfig = data.config
}
async function main() {
resizeCanvas()
drawLoading()
await Renderer.load()
window.AudioPlayer = AudioPlayer
await window.AudioPlayer.load()
if (challengeMode) {
let localKicks = localStorage.getItem("challenge-kicks")
let localLevel = localStorage.getItem("challenge-level")
if (localKicks === null || localLevel === null || localKicks < 1) {
localKicks = 10
localLevel = 1
}
levelId = localLevel
challengeKicks = localKicks
}
if (levelId != "editor") {
await downloadPack(`../mono/level-data/packs/${packId}.json`)
}
loadLevel(levelId)
isLoading = false
resizeCanvas()
gameLoop()
addEventListener("resize", resizeCanvas)
}
main()
